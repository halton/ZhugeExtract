[{"filePath":"/Users/halton/work/ZhugeExtract/backend/src/config/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/backend/src/database/index.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'db' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":79,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":79,"endColumn":11}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { drizzle } from 'drizzle-orm/postgres-js'\nimport postgres from 'postgres'\nimport { config } from '../config/index.js'\nimport * as schema from './schema.js'\n\nlet connection: postgres.Sql | null = null\nlet db: ReturnType<typeof drizzle> | null = null\n\nexport async function setupDatabase() {\n  if (db) {\n    return db\n  }\n\n  try {\n    // åˆ›å»ºPostgreSQLè¿æ¥\n    connection = postgres(config.DATABASE_URL, {\n      max: config.DB_POOL_SIZE,\n      idle_timeout: 20,\n      connect_timeout: 10,\n    })\n\n    // åˆ›å»ºDrizzleå®ä¾‹\n    db = drizzle(connection, { \n      schema,\n      logger: config.NODE_ENV === 'development'\n    })\n\n    // æµ‹è¯•è¿æ¥\n    await connection`SELECT 1 as test`\n    console.log('âœ… Database connected successfully')\n\n    return db\n\n  } catch (error) {\n    console.error('âŒ Database connection failed:', error)\n    throw error\n  }\n}\n\nexport async function closeDatabase() {\n  if (connection) {\n    await connection.end()\n    connection = null\n    db = null\n    console.log('ğŸ”„ Database connection closed')\n  }\n}\n\nexport function getDatabase() {\n  if (!db) {\n    throw new Error('Database not initialized. Call setupDatabase() first.')\n  }\n  return db\n}\n\n// å¥åº·æ£€æŸ¥\nexport async function checkDatabaseHealth() {\n  try {\n    if (!connection) {\n      throw new Error('No database connection')\n    }\n\n    const result = await connection`SELECT NOW() as current_time`\n    return {\n      status: 'healthy',\n      timestamp: result[0].current_time,\n      pool_size: config.DB_POOL_SIZE\n    }\n  } catch (error) {\n    return {\n      status: 'unhealthy',\n      error: error instanceof Error ? error.message : 'Unknown error'\n    }\n  }\n}\n\n// æ•°æ®åº“è¿ç§»å’Œåˆå§‹åŒ–\nexport async function initializeDatabase() {\n  const db = getDatabase()\n  \n  try {\n    // è¿™é‡Œå¯ä»¥æ·»åŠ åˆå§‹åŒ–æ•°æ®\n    console.log('ğŸ“Š Database initialized successfully')\n  } catch (error) {\n    console.error('âŒ Database initialization failed:', error)\n    throw error\n  }\n}\n\nexport { schema }\nexport type Database = NonNullable<typeof db>","usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/backend/src/database/schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/backend/src/middleware/auth.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'reply' is defined but never used. Allowed unused args must match /^_/u.","line":66,"column":71,"nodeType":null,"messageId":"unusedVar","endLine":66,"endColumn":76}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { FastifyRequest, FastifyReply } from 'fastify'\nimport { AuthService } from '../services/auth.service.js'\n\nconst authService = new AuthService()\n\ndeclare module 'fastify' {\n  interface FastifyRequest {\n    user?: {\n      userId: string\n      email: string\n      username: string\n      sessionId: string\n    }\n  }\n}\n\nexport async function authMiddleware(request: FastifyRequest, reply: FastifyReply) {\n  try {\n    const authHeader = request.headers.authorization\n    \n    if (!authHeader) {\n      return reply.status(401).send({\n        success: false,\n        error: {\n          code: 'MISSING_TOKEN',\n          message: 'ç¼ºå°‘è®¤è¯ä»¤ç‰Œ'\n        }\n      })\n    }\n\n    const token = authHeader.replace(/^Bearer\\s+/, '')\n    \n    if (!token) {\n      return reply.status(401).send({\n        success: false,\n        error: {\n          code: 'INVALID_TOKEN_FORMAT',\n          message: 'ä»¤ç‰Œæ ¼å¼æ— æ•ˆ'\n        }\n      })\n    }\n\n    // éªŒè¯ä»¤ç‰Œ\n    const payload = await authService.verifyToken(token)\n    \n    // å°†ç”¨æˆ·ä¿¡æ¯æ·»åŠ åˆ°è¯·æ±‚å¯¹è±¡\n    request.user = {\n      userId: payload.userId,\n      email: payload.email,\n      username: payload.username,\n      sessionId: payload.sessionId\n    }\n\n  } catch (error) {\n    return reply.status(401).send({\n      success: false,\n      error: {\n        code: 'TOKEN_VERIFICATION_FAILED',\n        message: error instanceof Error ? error.message : 'ä»¤ç‰ŒéªŒè¯å¤±è´¥'\n      }\n    })\n  }\n}\n\n// å¯é€‰è®¤è¯ä¸­é—´ä»¶ï¼ˆä¸å¼ºåˆ¶è¦æ±‚è®¤è¯ï¼‰\nexport async function optionalAuthMiddleware(request: FastifyRequest, reply: FastifyReply) {\n  try {\n    const authHeader = request.headers.authorization\n    \n    if (authHeader) {\n      const token = authHeader.replace(/^Bearer\\s+/, '')\n      \n      if (token) {\n        const payload = await authService.verifyToken(token)\n        request.user = {\n          userId: payload.userId,\n          email: payload.email,\n          username: payload.username,\n          sessionId: payload.sessionId\n        }\n      }\n    }\n    \n    // å³ä½¿æ²¡æœ‰è®¤è¯ä¹Ÿç»§ç»­æ‰§è¡Œ\n  } catch (error) {\n    // å¿½ç•¥è®¤è¯é”™è¯¯ï¼Œç»§ç»­æ‰§è¡Œ\n    request.log.warn('Optional auth failed:', error)\n  }\n}\n\n// è§’è‰²æ£€æŸ¥ä¸­é—´ä»¶\nexport function requireRole(roles: string[]) {\n  return async (request: FastifyRequest, reply: FastifyReply) => {\n    if (!request.user) {\n      return reply.status(401).send({\n        success: false,\n        error: {\n          code: 'AUTHENTICATION_REQUIRED',\n          message: 'éœ€è¦è®¤è¯'\n        }\n      })\n    }\n\n    // è·å–ç”¨æˆ·è¯¦ç»†ä¿¡æ¯ä»¥æ£€æŸ¥è§’è‰²\n    const user = await authService.getUserById(request.user.userId)\n    \n    if (!user) {\n      return reply.status(401).send({\n        success: false,\n        error: {\n          code: 'USER_NOT_FOUND',\n          message: 'ç”¨æˆ·ä¸å­˜åœ¨'\n        }\n      })\n    }\n\n    // æ£€æŸ¥ç”¨æˆ·è§’è‰²ï¼ˆè¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå®é™…é¡¹ç›®ä¸­å¯èƒ½éœ€è¦æ›´å¤æ‚çš„è§’è‰²ç³»ç»Ÿï¼‰\n    const userRole = user.subscriptionTier || 'free'\n    \n    if (!roles.includes(userRole)) {\n      return reply.status(403).send({\n        success: false,\n        error: {\n          code: 'INSUFFICIENT_PERMISSIONS',\n          message: 'æƒé™ä¸è¶³'\n        }\n      })\n    }\n  }\n}\n\n// èµ„æºæ‰€æœ‰è€…æ£€æŸ¥ä¸­é—´ä»¶\nexport function requireOwnership(getResourceUserId: (request: FastifyRequest) => Promise<string>) {\n  return async (request: FastifyRequest, reply: FastifyReply) => {\n    if (!request.user) {\n      return reply.status(401).send({\n        success: false,\n        error: {\n          code: 'AUTHENTICATION_REQUIRED',\n          message: 'éœ€è¦è®¤è¯'\n        }\n      })\n    }\n\n    try {\n      const resourceUserId = await getResourceUserId(request)\n      \n      if (resourceUserId !== request.user.userId) {\n        return reply.status(403).send({\n          success: false,\n          error: {\n            code: 'ACCESS_DENIED',\n            message: 'æ— æƒè®¿é—®æ­¤èµ„æº'\n          }\n        })\n      }\n    } catch (error) {\n      return reply.status(500).send({\n        success: false,\n        error: {\n          code: 'OWNERSHIP_CHECK_FAILED',\n          message: 'èµ„æºæ‰€æœ‰æƒæ£€æŸ¥å¤±è´¥'\n        }\n      })\n    }\n  }\n}","usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/backend/src/routes/auth.ts","messages":[{"ruleId":"@typescript-eslint/ban-ts-comment","severity":2,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":209,"column":7,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":209,"endColumn":48,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[5972,6013],"text":"// @ts-expect-error - userå±æ€§åœ¨authenticateä¸­é—´ä»¶ä¸­æ·»åŠ "},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}]},{"ruleId":"@typescript-eslint/ban-ts-comment","severity":2,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":261,"column":7,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":261,"endColumn":20,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[7419,7432],"text":"// @ts-expect-error"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}]},{"ruleId":"@typescript-eslint/ban-ts-comment","severity":2,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":309,"column":7,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":309,"endColumn":20,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[8632,8645],"text":"// @ts-expect-error"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}]},{"ruleId":"@typescript-eslint/ban-ts-comment","severity":2,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":349,"column":7,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":349,"endColumn":20,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[9755,9768],"text":"// @ts-expect-error"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify'\nimport { z } from 'zod'\nimport { AuthService } from '../services/auth.service.js'\n\nconst authService = new AuthService()\n\n// éªŒè¯æ¨¡å¼\nconst registerSchema = z.object({\n  email: z.string().email('è¯·è¾“å…¥æœ‰æ•ˆçš„é‚®ç®±åœ°å€'),\n  username: z.string().min(3, 'ç”¨æˆ·åè‡³å°‘3ä¸ªå­—ç¬¦').max(50, 'ç”¨æˆ·åæœ€å¤š50ä¸ªå­—ç¬¦').regex(/^[a-zA-Z0-9_-]+$/, 'ç”¨æˆ·ååªèƒ½åŒ…å«å­—æ¯ã€æ•°å­—ã€ä¸‹åˆ’çº¿å’Œè¿å­—ç¬¦'),\n  password: z.string().min(8, 'å¯†ç è‡³å°‘8ä¸ªå­—ç¬¦').max(128, 'å¯†ç æœ€å¤š128ä¸ªå­—ç¬¦'),\n  displayName: z.string().max(100, 'æ˜¾ç¤ºåç§°æœ€å¤š100ä¸ªå­—ç¬¦').optional()\n})\n\nconst loginSchema = z.object({\n  email: z.string().email('è¯·è¾“å…¥æœ‰æ•ˆçš„é‚®ç®±åœ°å€'),\n  password: z.string().min(1, 'è¯·è¾“å…¥å¯†ç ')\n})\n\nconst refreshTokenSchema = z.object({\n  refreshToken: z.string().min(1, 'åˆ·æ–°ä»¤ç‰Œä¸èƒ½ä¸ºç©º')\n})\n\nconst changePasswordSchema = z.object({\n  currentPassword: z.string().min(1, 'è¯·è¾“å…¥å½“å‰å¯†ç '),\n  newPassword: z.string().min(8, 'æ–°å¯†ç è‡³å°‘8ä¸ªå­—ç¬¦').max(128, 'æ–°å¯†ç æœ€å¤š128ä¸ªå­—ç¬¦')\n})\n\nconst updateProfileSchema = z.object({\n  displayName: z.string().max(100, 'æ˜¾ç¤ºåç§°æœ€å¤š100ä¸ªå­—ç¬¦').optional(),\n  avatarUrl: z.string().url('è¯·è¾“å…¥æœ‰æ•ˆçš„å¤´åƒURL').optional(),\n  settings: z.record(z.any()).optional()\n})\n\nexport default async function authRoutes(fastify: FastifyInstance) {\n  \n  // ç”¨æˆ·æ³¨å†Œ\n  fastify.post('/register', {\n    schema: {\n      tags: ['Authentication'],\n      summary: 'ç”¨æˆ·æ³¨å†Œ',\n      body: {\n        type: 'object',\n        required: ['email', 'username', 'password'],\n        properties: {\n          email: { type: 'string', format: 'email', description: 'é‚®ç®±åœ°å€' },\n          username: { type: 'string', minLength: 3, maxLength: 50, description: 'ç”¨æˆ·å' },\n          password: { type: 'string', minLength: 8, maxLength: 128, description: 'å¯†ç ' },\n          displayName: { type: 'string', maxLength: 100, description: 'æ˜¾ç¤ºåç§°' }\n        }\n      },\n      response: {\n        201: {\n          type: 'object',\n          properties: {\n            success: { type: 'boolean' },\n            data: {\n              type: 'object',\n              properties: {\n                user: {\n                  type: 'object',\n                  properties: {\n                    id: { type: 'string' },\n                    email: { type: 'string' },\n                    username: { type: 'string' },\n                    displayName: { type: 'string' },\n                    createdAt: { type: 'string', format: 'date-time' }\n                  }\n                },\n                token: { type: 'string' },\n                refreshToken: { type: 'string' },\n                expiresAt: { type: 'string', format: 'date-time' }\n              }\n            },\n            message: { type: 'string' }\n          }\n        }\n      }\n    }\n  }, async (request: FastifyRequest, reply: FastifyReply) => {\n    try {\n      const data = registerSchema.parse(request.body)\n      \n      const result = await authService.register(data)\n      \n      return reply.status(201).send({\n        success: true,\n        data: result,\n        message: 'æ³¨å†ŒæˆåŠŸ'\n      })\n    } catch (error) {\n      return reply.status(400).send({\n        success: false,\n        error: {\n          code: 'REGISTRATION_FAILED',\n          message: error instanceof Error ? error.message : 'æ³¨å†Œå¤±è´¥'\n        }\n      })\n    }\n  })\n\n  // ç”¨æˆ·ç™»å½•\n  fastify.post('/login', {\n    schema: {\n      tags: ['Authentication'],\n      summary: 'ç”¨æˆ·ç™»å½•',\n      body: {\n        type: 'object',\n        required: ['email', 'password'],\n        properties: {\n          email: { type: 'string', format: 'email', description: 'é‚®ç®±åœ°å€' },\n          password: { type: 'string', description: 'å¯†ç ' }\n        }\n      },\n      response: {\n        200: {\n          type: 'object',\n          properties: {\n            success: { type: 'boolean' },\n            data: {\n              type: 'object',\n              properties: {\n                user: {\n                  type: 'object',\n                  properties: {\n                    id: { type: 'string' },\n                    email: { type: 'string' },\n                    username: { type: 'string' },\n                    displayName: { type: 'string' }\n                  }\n                },\n                token: { type: 'string' },\n                refreshToken: { type: 'string' },\n                expiresAt: { type: 'string', format: 'date-time' }\n              }\n            },\n            message: { type: 'string' }\n          }\n        }\n      }\n    }\n  }, async (request: FastifyRequest, reply: FastifyReply) => {\n    try {\n      const credentials = loginSchema.parse(request.body)\n      \n      const result = await authService.login(credentials)\n      \n      return reply.send({\n        success: true,\n        data: result,\n        message: 'ç™»å½•æˆåŠŸ'\n      })\n    } catch (error) {\n      return reply.status(401).send({\n        success: false,\n        error: {\n          code: 'LOGIN_FAILED',\n          message: error instanceof Error ? error.message : 'ç™»å½•å¤±è´¥'\n        }\n      })\n    }\n  })\n\n  // åˆ·æ–°ä»¤ç‰Œ\n  fastify.post('/refresh', {\n    schema: {\n      tags: ['Authentication'],\n      summary: 'åˆ·æ–°è®¿é—®ä»¤ç‰Œ',\n      body: {\n        type: 'object',\n        required: ['refreshToken'],\n        properties: {\n          refreshToken: { type: 'string', description: 'åˆ·æ–°ä»¤ç‰Œ' }\n        }\n      }\n    }\n  }, async (request: FastifyRequest, reply: FastifyReply) => {\n    try {\n      const { refreshToken } = refreshTokenSchema.parse(request.body)\n      \n      const result = await authService.refreshToken(refreshToken)\n      \n      return reply.send({\n        success: true,\n        data: result,\n        message: 'ä»¤ç‰Œåˆ·æ–°æˆåŠŸ'\n      })\n    } catch (error) {\n      return reply.status(401).send({\n        success: false,\n        error: {\n          code: 'TOKEN_REFRESH_FAILED',\n          message: error instanceof Error ? error.message : 'ä»¤ç‰Œåˆ·æ–°å¤±è´¥'\n        }\n      })\n    }\n  })\n\n  // ç™»å‡º\n  fastify.post('/logout', {\n    preHandler: [fastify.authenticate],\n    schema: {\n      tags: ['Authentication'],\n      summary: 'ç”¨æˆ·ç™»å‡º',\n      security: [{ Bearer: [] }]\n    }\n  }, async (request: FastifyRequest, reply: FastifyReply) => {\n    try {\n      // @ts-ignore - userå±æ€§åœ¨authenticateä¸­é—´ä»¶ä¸­æ·»åŠ \n      const { sessionId } = request.user\n      \n      await authService.logout(sessionId)\n      \n      return reply.send({\n        success: true,\n        message: 'ç™»å‡ºæˆåŠŸ'\n      })\n    } catch (error) {\n      return reply.status(500).send({\n        success: false,\n        error: {\n          code: 'LOGOUT_FAILED',\n          message: error instanceof Error ? error.message : 'ç™»å‡ºå¤±è´¥'\n        }\n      })\n    }\n  })\n\n  // è·å–å½“å‰ç”¨æˆ·ä¿¡æ¯\n  fastify.get('/me', {\n    preHandler: [fastify.authenticate],\n    schema: {\n      tags: ['Authentication'],\n      summary: 'è·å–å½“å‰ç”¨æˆ·ä¿¡æ¯',\n      security: [{ Bearer: [] }],\n      response: {\n        200: {\n          type: 'object',\n          properties: {\n            success: { type: 'boolean' },\n            data: {\n              type: 'object',\n              properties: {\n                id: { type: 'string' },\n                email: { type: 'string' },\n                username: { type: 'string' },\n                displayName: { type: 'string' },\n                avatarUrl: { type: 'string' },\n                settings: { type: 'object' },\n                subscriptionTier: { type: 'string' },\n                createdAt: { type: 'string', format: 'date-time' },\n                lastLoginAt: { type: 'string', format: 'date-time' }\n              }\n            }\n          }\n        }\n      }\n    }\n  }, async (request: FastifyRequest, reply: FastifyReply) => {\n    try {\n      // @ts-ignore\n      const { userId } = request.user\n      \n      const user = await authService.getUserById(userId)\n      \n      if (!user) {\n        return reply.status(404).send({\n          success: false,\n          error: {\n            code: 'USER_NOT_FOUND',\n            message: 'ç”¨æˆ·ä¸å­˜åœ¨'\n          }\n        })\n      }\n      \n      return reply.send({\n        success: true,\n        data: user\n      })\n    } catch (error) {\n      return reply.status(500).send({\n        success: false,\n        error: {\n          code: 'FETCH_USER_FAILED',\n          message: error instanceof Error ? error.message : 'è·å–ç”¨æˆ·ä¿¡æ¯å¤±è´¥'\n        }\n      })\n    }\n  })\n\n  // æ›´æ–°ç”¨æˆ·èµ„æ–™\n  fastify.put('/profile', {\n    preHandler: [fastify.authenticate],\n    schema: {\n      tags: ['Authentication'],\n      summary: 'æ›´æ–°ç”¨æˆ·èµ„æ–™',\n      security: [{ Bearer: [] }],\n      body: {\n        type: 'object',\n        properties: {\n          displayName: { type: 'string', maxLength: 100, description: 'æ˜¾ç¤ºåç§°' },\n          avatarUrl: { type: 'string', format: 'uri', description: 'å¤´åƒURL' },\n          settings: { type: 'object', description: 'ç”¨æˆ·è®¾ç½®' }\n        }\n      }\n    }\n  }, async (request: FastifyRequest, reply: FastifyReply) => {\n    try {\n      // @ts-ignore\n      const { userId } = request.user\n      const updates = updateProfileSchema.parse(request.body)\n      \n      const updatedUser = await authService.updateProfile(userId, updates)\n      \n      return reply.send({\n        success: true,\n        data: updatedUser,\n        message: 'èµ„æ–™æ›´æ–°æˆåŠŸ'\n      })\n    } catch (error) {\n      return reply.status(400).send({\n        success: false,\n        error: {\n          code: 'PROFILE_UPDATE_FAILED',\n          message: error instanceof Error ? error.message : 'èµ„æ–™æ›´æ–°å¤±è´¥'\n        }\n      })\n    }\n  })\n\n  // ä¿®æ”¹å¯†ç \n  fastify.post('/change-password', {\n    preHandler: [fastify.authenticate],\n    schema: {\n      tags: ['Authentication'],\n      summary: 'ä¿®æ”¹å¯†ç ',\n      security: [{ Bearer: [] }],\n      body: {\n        type: 'object',\n        required: ['currentPassword', 'newPassword'],\n        properties: {\n          currentPassword: { type: 'string', description: 'å½“å‰å¯†ç ' },\n          newPassword: { type: 'string', minLength: 8, maxLength: 128, description: 'æ–°å¯†ç ' }\n        }\n      }\n    }\n  }, async (request: FastifyRequest, reply: FastifyReply) => {\n    try {\n      // @ts-ignore\n      const { userId } = request.user\n      const { currentPassword, newPassword } = changePasswordSchema.parse(request.body)\n      \n      await authService.changePassword(userId, currentPassword, newPassword)\n      \n      return reply.send({\n        success: true,\n        message: 'å¯†ç ä¿®æ”¹æˆåŠŸï¼Œè¯·é‡æ–°ç™»å½•'\n      })\n    } catch (error) {\n      return reply.status(400).send({\n        success: false,\n        error: {\n          code: 'PASSWORD_CHANGE_FAILED',\n          message: error instanceof Error ? error.message : 'å¯†ç ä¿®æ”¹å¤±è´¥'\n        }\n      })\n    }\n  })\n}","usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/backend/src/server.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":46,"column":9,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":46,"endColumn":12,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1445,1448],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1445,1448],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":47,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":47,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1460,1463],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1460,1463],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":48,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":48,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1477,1480],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1477,1480],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'req' is defined but never used. Allowed unused args must match /^_/u.","line":138,"column":60,"nodeType":null,"messageId":"unusedVar","endLine":138,"endColumn":63},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'request' is defined but never used. Allowed unused args must match /^_/u.","line":148,"column":29,"nodeType":null,"messageId":"unusedVar","endLine":148,"endColumn":36},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'reply' is defined but never used. Allowed unused args must match /^_/u.","line":148,"column":38,"nodeType":null,"messageId":"unusedVar","endLine":148,"endColumn":43}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import Fastify from 'fastify'\nimport cors from '@fastify/cors'\nimport jwt from '@fastify/jwt'\nimport multipart from '@fastify/multipart'\nimport websocket from '@fastify/websocket'\nimport swagger from '@fastify/swagger'\nimport swaggerUi from '@fastify/swagger-ui'\n\nimport { config } from './config/index.js'\nimport { setupDatabase } from './database/index.js'\nimport { setupRedis } from './services/redis.js'\nimport { setupStorage } from './services/storage.js'\n\n// Routes\nimport authRoutes from './routes/auth.js'\nimport fileRoutes from './routes/files.js'\nimport shareRoutes from './routes/shares.js'\nimport syncRoutes from './routes/sync.js'\nimport analyticsRoutes from './routes/analytics.js'\nimport healthRoutes from './routes/health.js'\n\n// Middleware\nimport { authMiddleware } from './middleware/auth.js'\nimport { rateLimitMiddleware } from './middleware/rateLimit.js'\nimport { metricsMiddleware } from './middleware/metrics.js'\nimport { errorHandler } from './middleware/errorHandler.js'\n\nconst fastify = Fastify({\n  logger: {\n    level: config.LOG_LEVEL,\n    transport: config.NODE_ENV === 'development' ? {\n      target: 'pino-pretty',\n      options: {\n        colorize: true,\n        translateTime: 'HH:MM:ss Z',\n        ignore: 'pid,hostname'\n      }\n    } : undefined\n  }\n})\n\n// å£°æ˜ç±»å‹æ‰©å±•\ndeclare module 'fastify' {\n  interface FastifyInstance {\n    authenticate: (request: FastifyRequest, reply: FastifyReply) => Promise<void>\n    db: any\n    redis: any\n    storage: any\n  }\n}\n\nasync function buildServer() {\n  try {\n    // åŸºç¡€æ’ä»¶\n    await fastify.register(cors, {\n      origin: config.CORS_ORIGINS,\n      credentials: true\n    })\n\n    await fastify.register(jwt, {\n      secret: config.JWT_SECRET,\n      sign: {\n        expiresIn: config.JWT_EXPIRES_IN\n      }\n    })\n\n    await fastify.register(multipart, {\n      limits: {\n        fileSize: config.MAX_FILE_SIZE,\n        files: 1\n      }\n    })\n\n    await fastify.register(websocket)\n\n    // APIæ–‡æ¡£\n    await fastify.register(swagger, {\n      swagger: {\n        info: {\n          title: 'ZhugeExtract API',\n          description: 'Archive extraction and sharing service API',\n          version: '1.0.0'\n        },\n        host: `localhost:${config.PORT}`,\n        schemes: ['http', 'https'],\n        consumes: ['application/json', 'multipart/form-data'],\n        produces: ['application/json'],\n        securityDefinitions: {\n          Bearer: {\n            type: 'apiKey',\n            name: 'Authorization',\n            in: 'header'\n          }\n        }\n      }\n    })\n\n    await fastify.register(swaggerUi, {\n      routePrefix: '/docs',\n      uiConfig: {\n        docExpansion: 'full',\n        deepLinking: false\n      }\n    })\n\n    // æœåŠ¡åˆå§‹åŒ–\n    const db = await setupDatabase()\n    const redis = await setupRedis()\n    const storage = await setupStorage()\n\n    // æ³¨å†ŒæœåŠ¡åˆ°fastifyå®ä¾‹\n    fastify.decorate('db', db)\n    fastify.decorate('redis', redis)\n    fastify.decorate('storage', storage)\n\n    // è®¤è¯è£…é¥°å™¨\n    fastify.decorate('authenticate', authMiddleware)\n\n    // å…¨å±€ä¸­é—´ä»¶\n    await fastify.register(rateLimitMiddleware)\n    await fastify.register(metricsMiddleware)\n\n    // é”™è¯¯å¤„ç†\n    fastify.setErrorHandler(errorHandler)\n\n    // å¥åº·æ£€æŸ¥\n    await fastify.register(healthRoutes, { prefix: '/health' })\n\n    // APIè·¯ç”±\n    await fastify.register(authRoutes, { prefix: '/api/v1/auth' })\n    await fastify.register(fileRoutes, { prefix: '/api/v1/files' })\n    await fastify.register(shareRoutes, { prefix: '/api/v1/shares' })\n    await fastify.register(syncRoutes, { prefix: '/api/v1/sync' })\n    await fastify.register(analyticsRoutes, { prefix: '/api/v1/analytics' })\n\n    // WebSocketè·¯ç”±\n    fastify.register(async function (fastify) {\n      fastify.get('/ws', { websocket: true }, (connection, req) => {\n        connection.socket.on('message', (message) => {\n          // WebSocketæ¶ˆæ¯å¤„ç†é€»è¾‘\n          console.log('Received message:', message.toString())\n          connection.socket.send('Hello from server!')\n        })\n      })\n    })\n\n    // æ ¹è·¯å¾„\n    fastify.get('/', async (request, reply) => {\n      return {\n        message: 'ZhugeExtract Backend API',\n        version: '1.0.0',\n        documentation: '/docs',\n        health: '/health'\n      }\n    })\n\n    return fastify\n\n  } catch (error) {\n    fastify.log.error(error)\n    process.exit(1)\n  }\n}\n\nasync function start() {\n  try {\n    const server = await buildServer()\n    \n    await server.listen({\n      port: config.PORT,\n      host: config.HOST\n    })\n\n    console.log(`ğŸš€ Server ready at http://${config.HOST}:${config.PORT}`)\n    console.log(`ğŸ“š Documentation available at http://${config.HOST}:${config.PORT}/docs`)\n\n  } catch (error) {\n    console.error('âŒ Server startup failed:', error)\n    process.exit(1)\n  }\n}\n\n// ä¼˜é›…å…³é—­å¤„ç†\nprocess.on('SIGINT', async () => {\n  try {\n    await fastify.close()\n    console.log('ğŸ”„ Server closed gracefully')\n    process.exit(0)\n  } catch (error) {\n    console.error('âŒ Error during shutdown:', error)\n    process.exit(1)\n  }\n})\n\n// å¯åŠ¨æœåŠ¡å™¨\nif (import.meta.url === `file://${process.argv[1]}`) {\n  start()\n}\n\nexport { buildServer }","usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/backend/src/services/auth.service.ts","messages":[{"ruleId":"no-duplicate-imports","severity":2,"message":"'../database/schema.js' import is duplicated.","line":9,"column":1,"nodeType":"ImportDeclaration","messageId":"import","endLine":9,"endColumn":80},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Session' is defined but never used. Allowed unused vars must match /^_/u.","line":9,"column":30,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":37},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'passwordHash' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":355,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":355,"endColumn":25}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import bcrypt from 'bcryptjs'\nimport jwt from 'jsonwebtoken'\nimport { nanoid } from 'nanoid'\nimport { eq, and } from 'drizzle-orm'\n\nimport { getDatabase } from '../database/index.js'\nimport { users, sessions } from '../database/schema.js'\nimport { config } from '../config/index.js'\nimport type { User, NewUser, Session, NewSession } from '../database/schema.js'\n\nexport interface LoginCredentials {\n  email: string\n  password: string\n}\n\nexport interface RegisterData {\n  email: string\n  username: string\n  password: string\n  displayName?: string\n}\n\nexport interface AuthResult {\n  user: Omit<User, 'passwordHash'>\n  token: string\n  refreshToken: string\n  expiresAt: Date\n}\n\nexport interface TokenPayload {\n  userId: string\n  email: string\n  username: string\n  sessionId: string\n}\n\nexport class AuthService {\n  private db = getDatabase()\n\n  // ç”¨æˆ·æ³¨å†Œ\n  async register(data: RegisterData): Promise<AuthResult> {\n    const { email, username, password, displayName } = data\n\n    // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å·²å­˜åœ¨\n    const existingUser = await this.db\n      .select()\n      .from(users)\n      .where(eq(users.email, email))\n      .limit(1)\n\n    if (existingUser.length > 0) {\n      throw new Error('ç”¨æˆ·å·²å­˜åœ¨')\n    }\n\n    // æ£€æŸ¥ç”¨æˆ·åæ˜¯å¦å·²å­˜åœ¨\n    const existingUsername = await this.db\n      .select()\n      .from(users)\n      .where(eq(users.username, username))\n      .limit(1)\n\n    if (existingUsername.length > 0) {\n      throw new Error('ç”¨æˆ·åå·²è¢«ä½¿ç”¨')\n    }\n\n    // å¯†ç å“ˆå¸Œ\n    const passwordHash = await this.hashPassword(password)\n\n    // åˆ›å»ºç”¨æˆ·\n    const newUser: NewUser = {\n      email,\n      username,\n      passwordHash,\n      displayName: displayName || username,\n      emailVerified: false,\n    }\n\n    const [user] = await this.db\n      .insert(users)\n      .values(newUser)\n      .returning()\n\n    // åˆ›å»ºä¼šè¯\n    const authResult = await this.createSession(user)\n\n    return authResult\n  }\n\n  // ç”¨æˆ·ç™»å½•\n  async login(credentials: LoginCredentials): Promise<AuthResult> {\n    const { email, password } = credentials\n\n    // æŸ¥æ‰¾ç”¨æˆ·\n    const [user] = await this.db\n      .select()\n      .from(users)\n      .where(and(\n        eq(users.email, email),\n        eq(users.isActive, true)\n      ))\n      .limit(1)\n\n    if (!user) {\n      throw new Error('ç”¨æˆ·ä¸å­˜åœ¨æˆ–å·²è¢«ç¦ç”¨')\n    }\n\n    // éªŒè¯å¯†ç \n    const isValidPassword = await this.verifyPassword(password, user.passwordHash)\n    if (!isValidPassword) {\n      throw new Error('å¯†ç é”™è¯¯')\n    }\n\n    // æ›´æ–°æœ€åç™»å½•æ—¶é—´\n    await this.db\n      .update(users)\n      .set({ lastLoginAt: new Date() })\n      .where(eq(users.id, user.id))\n\n    // åˆ é™¤æ—§çš„ä¼šè¯ï¼ˆå¯é€‰ï¼šå•ç‚¹ç™»å½•ï¼‰\n    await this.revokeUserSessions(user.id)\n\n    // åˆ›å»ºæ–°ä¼šè¯\n    const authResult = await this.createSession(user)\n\n    return authResult\n  }\n\n  // åˆ·æ–°ä»¤ç‰Œ\n  async refreshToken(refreshToken: string): Promise<AuthResult> {\n    try {\n      // éªŒè¯åˆ·æ–°ä»¤ç‰Œ\n      const payload = jwt.verify(refreshToken, config.JWT_SECRET) as TokenPayload & { type: 'refresh' }\n\n      if (payload.type !== 'refresh') {\n        throw new Error('Invalid token type')\n      }\n\n      // æŸ¥æ‰¾ä¼šè¯\n      const [session] = await this.db\n        .select()\n        .from(sessions)\n        .where(and(\n          eq(sessions.id, payload.sessionId),\n          eq(sessions.refreshToken, refreshToken),\n          eq(sessions.isActive, true)\n        ))\n        .limit(1)\n\n      if (!session) {\n        throw new Error('ä¼šè¯ä¸å­˜åœ¨æˆ–å·²å¤±æ•ˆ')\n      }\n\n      // æ£€æŸ¥ä¼šè¯æ˜¯å¦è¿‡æœŸ\n      if (session.expiresAt < new Date()) {\n        await this.revokeSession(session.id)\n        throw new Error('ä¼šè¯å·²è¿‡æœŸ')\n      }\n\n      // æŸ¥æ‰¾ç”¨æˆ·\n      const [user] = await this.db\n        .select()\n        .from(users)\n        .where(and(\n          eq(users.id, session.userId),\n          eq(users.isActive, true)\n        ))\n        .limit(1)\n\n      if (!user) {\n        throw new Error('ç”¨æˆ·ä¸å­˜åœ¨æˆ–å·²è¢«ç¦ç”¨')\n      }\n\n      // ç”Ÿæˆæ–°çš„ä»¤ç‰Œ\n      const newTokens = this.generateTokens(user, session.id)\n\n      // æ›´æ–°ä¼šè¯\n      await this.db\n        .update(sessions)\n        .set({\n          token: newTokens.token,\n          refreshToken: newTokens.refreshToken,\n          lastUsedAt: new Date()\n        })\n        .where(eq(sessions.id, session.id))\n\n      return {\n        user: this.sanitizeUser(user),\n        ...newTokens,\n        expiresAt: new Date(Date.now() + this.parseTimeString(config.JWT_EXPIRES_IN))\n      }\n\n    } catch (error) {\n      throw new Error(`ä»¤ç‰Œåˆ·æ–°å¤±è´¥: ${  error instanceof Error ? error.message : 'Unknown error'}`)\n    }\n  }\n\n  // ç™»å‡º\n  async logout(sessionId: string): Promise<void> {\n    await this.revokeSession(sessionId)\n  }\n\n  // éªŒè¯ä»¤ç‰Œ\n  async verifyToken(token: string): Promise<TokenPayload> {\n    try {\n      const payload = jwt.verify(token, config.JWT_SECRET) as TokenPayload\n\n      // éªŒè¯ä¼šè¯æ˜¯å¦å­˜åœ¨ä¸”æ´»è·ƒ\n      const [session] = await this.db\n        .select()\n        .from(sessions)\n        .where(and(\n          eq(sessions.id, payload.sessionId),\n          eq(sessions.token, token),\n          eq(sessions.isActive, true)\n        ))\n        .limit(1)\n\n      if (!session) {\n        throw new Error('ä¼šè¯ä¸å­˜åœ¨æˆ–å·²å¤±æ•ˆ')\n      }\n\n      if (session.expiresAt < new Date()) {\n        await this.revokeSession(session.id)\n        throw new Error('ä¼šè¯å·²è¿‡æœŸ')\n      }\n\n      // æ›´æ–°æœ€åä½¿ç”¨æ—¶é—´\n      await this.db\n        .update(sessions)\n        .set({ lastUsedAt: new Date() })\n        .where(eq(sessions.id, session.id))\n\n      return payload\n\n    } catch (error) {\n      throw new Error(`ä»¤ç‰ŒéªŒè¯å¤±è´¥: ${  error instanceof Error ? error.message : 'Unknown error'}`)\n    }\n  }\n\n  // è·å–ç”¨æˆ·ä¿¡æ¯\n  async getUserById(userId: string): Promise<Omit<User, 'passwordHash'> | null> {\n    const [user] = await this.db\n      .select()\n      .from(users)\n      .where(and(\n        eq(users.id, userId),\n        eq(users.isActive, true)\n      ))\n      .limit(1)\n\n    return user ? this.sanitizeUser(user) : null\n  }\n\n  // æ›´æ–°ç”¨æˆ·èµ„æ–™\n  async updateProfile(userId: string, updates: Partial<Pick<User, 'displayName' | 'avatarUrl' | 'settings'>>): Promise<Omit<User, 'passwordHash'>> {\n    const [updatedUser] = await this.db\n      .update(users)\n      .set({\n        ...updates,\n        updatedAt: new Date()\n      })\n      .where(eq(users.id, userId))\n      .returning()\n\n    return this.sanitizeUser(updatedUser)\n  }\n\n  // ä¿®æ”¹å¯†ç \n  async changePassword(userId: string, currentPassword: string, newPassword: string): Promise<void> {\n    // è·å–ç”¨æˆ·ä¿¡æ¯\n    const [user] = await this.db\n      .select()\n      .from(users)\n      .where(eq(users.id, userId))\n      .limit(1)\n\n    if (!user) {\n      throw new Error('ç”¨æˆ·ä¸å­˜åœ¨')\n    }\n\n    // éªŒè¯å½“å‰å¯†ç \n    const isValidPassword = await this.verifyPassword(currentPassword, user.passwordHash)\n    if (!isValidPassword) {\n      throw new Error('å½“å‰å¯†ç é”™è¯¯')\n    }\n\n    // æ›´æ–°å¯†ç \n    const newPasswordHash = await this.hashPassword(newPassword)\n    await this.db\n      .update(users)\n      .set({\n        passwordHash: newPasswordHash,\n        updatedAt: new Date()\n      })\n      .where(eq(users.id, userId))\n\n    // æ’¤é”€æ‰€æœ‰ä¼šè¯ï¼Œå¼ºåˆ¶é‡æ–°ç™»å½•\n    await this.revokeUserSessions(userId)\n  }\n\n  // ç§æœ‰æ–¹æ³•\n  private async createSession(user: User): Promise<AuthResult> {\n    const sessionId = nanoid()\n    const tokens = this.generateTokens(user, sessionId)\n    const expiresAt = new Date(Date.now() + this.parseTimeString(config.JWT_REFRESH_EXPIRES_IN))\n\n    const newSession: NewSession = {\n      id: sessionId,\n      userId: user.id,\n      token: tokens.token,\n      refreshToken: tokens.refreshToken,\n      expiresAt,\n      isActive: true\n    }\n\n    await this.db.insert(sessions).values(newSession)\n\n    return {\n      user: this.sanitizeUser(user),\n      ...tokens,\n      expiresAt: new Date(Date.now() + this.parseTimeString(config.JWT_EXPIRES_IN))\n    }\n  }\n\n  private generateTokens(user: User, sessionId: string) {\n    const payload: TokenPayload = {\n      userId: user.id,\n      email: user.email,\n      username: user.username,\n      sessionId\n    }\n\n    const token = jwt.sign(payload, config.JWT_SECRET, {\n      expiresIn: config.JWT_EXPIRES_IN\n    })\n\n    const refreshToken = jwt.sign(\n      { ...payload, type: 'refresh' },\n      config.JWT_SECRET,\n      { expiresIn: config.JWT_REFRESH_EXPIRES_IN }\n    )\n\n    return { token, refreshToken }\n  }\n\n  private async hashPassword(password: string): Promise<string> {\n    return bcrypt.hash(password, config.BCRYPT_ROUNDS)\n  }\n\n  private async verifyPassword(password: string, hash: string): Promise<boolean> {\n    return bcrypt.compare(password, hash)\n  }\n\n  private sanitizeUser(user: User): Omit<User, 'passwordHash'> {\n    const { passwordHash, ...sanitizedUser } = user\n    return sanitizedUser\n  }\n\n  private async revokeSession(sessionId: string): Promise<void> {\n    await this.db\n      .update(sessions)\n      .set({ isActive: false })\n      .where(eq(sessions.id, sessionId))\n  }\n\n  private async revokeUserSessions(userId: string): Promise<void> {\n    await this.db\n      .update(sessions)\n      .set({ isActive: false })\n      .where(eq(sessions.userId, userId))\n  }\n\n  private parseTimeString(timeString: string): number {\n    const units = {\n      s: 1000,\n      m: 60 * 1000,\n      h: 60 * 60 * 1000,\n      d: 24 * 60 * 60 * 1000\n    }\n\n    const match = timeString.match(/^(\\d+)([smhd])$/)\n    if (!match) {\n      throw new Error(`Invalid time string: ${timeString}`)\n    }\n\n    const [, amount, unit] = match\n    return parseInt(amount) * units[unit as keyof typeof units]\n  }\n}","usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/src/App.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/src/components/ErrorBoundary.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/src/components/layout/Header.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/src/components/layout/MainLayout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/src/components/ui/ErrorBoundary.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/src/components/ui/FileTree.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/src/components/ui/FileUpload.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/src/components/ui/LoadingSpinner.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/src/components/ui/PreviewPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/src/components/ui/ProgressBar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/src/components/ui/ThemeProvider.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":79,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":79,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { createContext, useContext, useEffect, useState } from 'react'\n\ntype Theme = 'light' | 'dark' | 'system'\n\ninterface ThemeContextType {\n  theme: Theme\n  setTheme: (theme: Theme) => void\n  isDark: boolean\n}\n\nconst ThemeContext = createContext<ThemeContextType | undefined>(undefined)\n\ninterface ThemeProviderProps {\n  children: React.ReactNode\n  defaultTheme?: Theme\n}\n\nexport function ThemeProvider({ children, defaultTheme = 'system' }: ThemeProviderProps) {\n  const [theme, setTheme] = useState<Theme>(() => {\n    if (typeof window !== 'undefined') {\n      return (localStorage.getItem('zhuge-theme') as Theme) || defaultTheme\n    }\n    return defaultTheme\n  })\n\n  const [isDark, setIsDark] = useState(false)\n\n  useEffect(() => {\n    const root = window.document.documentElement\n\n    root.classList.remove('light', 'dark')\n\n    if (theme === 'system') {\n      const systemTheme = window.matchMedia('(prefers-color-scheme: dark)').matches\n        ? 'dark'\n        : 'light'\n\n      root.classList.add(systemTheme)\n      setIsDark(systemTheme === 'dark')\n    } else {\n      root.classList.add(theme)\n      setIsDark(theme === 'dark')\n    }\n  }, [theme])\n\n  useEffect(() => {\n    const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)')\n    \n    const handleChange = () => {\n      if (theme === 'system') {\n        const systemTheme = mediaQuery.matches ? 'dark' : 'light'\n        const root = window.document.documentElement\n        root.classList.remove('light', 'dark')\n        root.classList.add(systemTheme)\n        setIsDark(systemTheme === 'dark')\n      }\n    }\n\n    mediaQuery.addEventListener('change', handleChange)\n    return () => mediaQuery.removeEventListener('change', handleChange)\n  }, [theme])\n\n  const value: ThemeContextType = {\n    theme,\n    setTheme: (theme: Theme) => {\n      localStorage.setItem('zhuge-theme', theme)\n      setTheme(theme)\n    },\n    isDark,\n  }\n\n  return (\n    <ThemeContext.Provider value={value}>\n      {children}\n    </ThemeContext.Provider>\n  )\n}\n\nexport const useTheme = () => {\n  const context = useContext(ThemeContext)\n\n  if (context === undefined) {\n    throw new Error('useTheme must be used within a ThemeProvider')\n  }\n\n  return context\n}","usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/src/components/ui/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/src/contexts/ArchiveContext.tsx","messages":[{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":64,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":64,"endColumn":56},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":79,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":79,"endColumn":83},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":80,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":82,"endColumn":31},{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":249,"column":17,"nodeType":"Identifier","messageId":"namedExport","endLine":249,"endColumn":27},{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":258,"column":17,"nodeType":"Identifier","messageId":"namedExport","endLine":258,"endColumn":32},{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":263,"column":17,"nodeType":"Identifier","messageId":"namedExport","endLine":263,"endColumn":34}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { createContext, useContext, useReducer, useCallback } from 'react'\nimport type { Archive, ArchiveFile, ExtractionProgress, PreviewData, ErrorInfo } from '@/types'\nimport { getArchiveService } from '@/services'\n\ninterface ArchiveState {\n  archives: Archive[]\n  currentArchive: Archive | null\n  selectedFile: ArchiveFile | null\n  extractionProgress: ExtractionProgress | null\n  previewData: Map<string, PreviewData>\n  errors: ErrorInfo[]\n  isLoading: boolean\n}\n\ntype ArchiveAction =\n  | { type: 'SET_LOADING'; payload: boolean }\n  | { type: 'ADD_ARCHIVE'; payload: Archive }\n  | { type: 'SET_CURRENT_ARCHIVE'; payload: Archive | null }\n  | { type: 'SELECT_FILE'; payload: ArchiveFile | null }\n  | { type: 'SET_EXTRACTION_PROGRESS'; payload: ExtractionProgress | null }\n  | { type: 'SET_PREVIEW_DATA'; payload: { fileId: string; data: PreviewData } }\n  | { type: 'ADD_ERROR'; payload: ErrorInfo }\n  | { type: 'CLEAR_ERRORS' }\n  | { type: 'REMOVE_ARCHIVE'; payload: string }\n  | { type: 'CLEAR_ALL' }\n\nconst initialState: ArchiveState = {\n  archives: [],\n  currentArchive: null,\n  selectedFile: null,\n  extractionProgress: null,\n  previewData: new Map(),\n  errors: [],\n  isLoading: false,\n}\n\nfunction archiveReducer(state: ArchiveState, action: ArchiveAction): ArchiveState {\n  switch (action.type) {\n    case 'SET_LOADING':\n      return { ...state, isLoading: action.payload }\n\n    case 'ADD_ARCHIVE':\n      return {\n        ...state,\n        archives: [...state.archives, action.payload],\n        currentArchive: action.payload,\n        isLoading: false,\n      }\n\n    case 'SET_CURRENT_ARCHIVE':\n      return {\n        ...state,\n        currentArchive: action.payload,\n        selectedFile: null, // åˆ‡æ¢å‹ç¼©åŒ…æ—¶æ¸…é™¤é€‰æ‹©çš„æ–‡ä»¶\n      }\n\n    case 'SELECT_FILE':\n      return { ...state, selectedFile: action.payload }\n\n    case 'SET_EXTRACTION_PROGRESS':\n      return { ...state, extractionProgress: action.payload }\n\n    case 'SET_PREVIEW_DATA':\n      const newPreviewData = new Map(state.previewData)\n      newPreviewData.set(action.payload.fileId, action.payload.data)\n      return { ...state, previewData: newPreviewData }\n\n    case 'ADD_ERROR':\n      return {\n        ...state,\n        errors: [...state.errors, action.payload],\n        isLoading: false,\n      }\n\n    case 'CLEAR_ERRORS':\n      return { ...state, errors: [] }\n\n    case 'REMOVE_ARCHIVE':\n      const filteredArchives = state.archives.filter(a => a.id !== action.payload)\n      const newCurrentArchive = state.currentArchive?.id === action.payload \n        ? filteredArchives[0] || null \n        : state.currentArchive\n      \n      return {\n        ...state,\n        archives: filteredArchives,\n        currentArchive: newCurrentArchive,\n        selectedFile: state.currentArchive?.id === action.payload ? null : state.selectedFile,\n      }\n\n    case 'CLEAR_ALL':\n      return { ...initialState }\n\n    default:\n      return state\n  }\n}\n\ninterface ArchiveContextType {\n  state: ArchiveState\n  actions: {\n    setLoading: (loading: boolean) => void\n    addArchive: (archive: Archive) => void\n    setCurrentArchive: (archive: Archive | null) => void\n    selectFile: (file: ArchiveFile | null) => void\n    setExtractionProgress: (progress: ExtractionProgress | null) => void\n    setPreviewData: (fileId: string, data: PreviewData) => void\n    addError: (error: ErrorInfo) => void\n    clearErrors: () => void\n    removeArchive: (archiveId: string) => void\n    clearAll: () => void\n    // æ–°å¢é«˜çº§æ“ä½œ\n    loadArchive: (file: File, password?: string) => Promise<void>\n    generatePreview: (file: ArchiveFile, password?: string) => Promise<void>\n    downloadFile: (file: ArchiveFile, password?: string) => Promise<void>\n  }\n}\n\nconst ArchiveContext = createContext<ArchiveContextType | undefined>(undefined)\n\nexport function ArchiveProvider({ children }: { children: React.ReactNode }) {\n  const [state, dispatch] = useReducer(archiveReducer, initialState)\n  const archiveService = getArchiveService()\n\n  // Action creators\n  const actions = {\n    setLoading: useCallback((loading: boolean) => {\n      dispatch({ type: 'SET_LOADING', payload: loading })\n    }, []),\n\n    addArchive: useCallback((archive: Archive) => {\n      dispatch({ type: 'ADD_ARCHIVE', payload: archive })\n    }, []),\n\n    setCurrentArchive: useCallback((archive: Archive | null) => {\n      dispatch({ type: 'SET_CURRENT_ARCHIVE', payload: archive })\n    }, []),\n\n    selectFile: useCallback((file: ArchiveFile | null) => {\n      dispatch({ type: 'SELECT_FILE', payload: file })\n    }, []),\n\n    setExtractionProgress: useCallback((progress: ExtractionProgress | null) => {\n      dispatch({ type: 'SET_EXTRACTION_PROGRESS', payload: progress })\n    }, []),\n\n    setPreviewData: useCallback((fileId: string, data: PreviewData) => {\n      dispatch({ type: 'SET_PREVIEW_DATA', payload: { fileId, data } })\n    }, []),\n\n    addError: useCallback((error: ErrorInfo) => {\n      dispatch({ type: 'ADD_ERROR', payload: error })\n      // è‡ªåŠ¨æ¸…ç†é”™è¯¯ï¼š5ç§’åç§»é™¤\n      setTimeout(() => {\n        dispatch({ type: 'CLEAR_ERRORS' })\n      }, 5000)\n    }, []),\n\n    clearErrors: useCallback(() => {\n      dispatch({ type: 'CLEAR_ERRORS' })\n    }, []),\n\n    removeArchive: useCallback((archiveId: string) => {\n      dispatch({ type: 'REMOVE_ARCHIVE', payload: archiveId })\n    }, []),\n\n    clearAll: useCallback(() => {\n      dispatch({ type: 'CLEAR_ALL' })\n    }, []),\n\n    // é«˜çº§æ“ä½œ\n    loadArchive: useCallback(async (file: File, password?: string) => {\n      try {\n        dispatch({ type: 'SET_LOADING', payload: true })\n        dispatch({ type: 'CLEAR_ERRORS' })\n\n        const archive = await archiveService.loadArchive(\n          file,\n          password,\n          (progress) => {\n            dispatch({ type: 'SET_EXTRACTION_PROGRESS', payload: progress })\n          }\n        )\n\n        dispatch({ type: 'ADD_ARCHIVE', payload: archive })\n        dispatch({ type: 'SET_EXTRACTION_PROGRESS', payload: null })\n      } catch (error) {\n        const errorInfo: ErrorInfo = {\n          id: Date.now().toString(),\n          type: 'parsing',\n          message: error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯',\n          timestamp: new Date()\n        }\n        dispatch({ type: 'ADD_ERROR', payload: errorInfo })\n      } finally {\n        dispatch({ type: 'SET_LOADING', payload: false })\n      }\n    }, [archiveService]),\n\n    generatePreview: useCallback(async (file: ArchiveFile, password?: string) => {\n      try {\n        const previewData = await archiveService.generatePreview(file, password)\n        dispatch({ type: 'SET_PREVIEW_DATA', payload: { fileId: file.id, data: previewData } })\n      } catch (error) {\n        const errorInfo: ErrorInfo = {\n          id: Date.now().toString(),\n          type: 'preview',\n          message: `é¢„è§ˆå¤±è´¥: ${error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯'}`,\n          timestamp: new Date()\n        }\n        dispatch({ type: 'ADD_ERROR', payload: errorInfo })\n      }\n    }, [archiveService]),\n\n    downloadFile: useCallback(async (file: ArchiveFile, password?: string) => {\n      try {\n        await archiveService.downloadFile(\n          file,\n          password,\n          (progress) => {\n            dispatch({ type: 'SET_EXTRACTION_PROGRESS', payload: progress })\n          }\n        )\n        dispatch({ type: 'SET_EXTRACTION_PROGRESS', payload: null })\n      } catch (error) {\n        const errorInfo: ErrorInfo = {\n          id: Date.now().toString(),\n          type: 'extraction',\n          message: `ä¸‹è½½å¤±è´¥: ${error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯'}`,\n          timestamp: new Date()\n        }\n        dispatch({ type: 'ADD_ERROR', payload: errorInfo })\n      }\n    }, [archiveService]),\n  }\n\n  const contextValue: ArchiveContextType = {\n    state,\n    actions,\n  }\n\n  return (\n    <ArchiveContext.Provider value={contextValue}>\n      {children}\n    </ArchiveContext.Provider>\n  )\n}\n\nexport function useArchive() {\n  const context = useContext(ArchiveContext)\n  if (context === undefined) {\n    throw new Error('useArchive must be used within an ArchiveProvider')\n  }\n  return context\n}\n\n// ä¾¿æ·çš„Hookå¯¼å‡º\nexport function useArchiveState() {\n  const { state } = useArchive()\n  return state\n}\n\nexport function useArchiveActions() {\n  const { actions } = useArchive()\n  return actions\n}","usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/src/contexts/ThemeContext.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":76,"column":17,"nodeType":"Identifier","messageId":"namedExport","endLine":76,"endColumn":25}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { createContext, useContext, useState, useEffect } from 'react'\nimport type { Theme } from '@/types'\n\ninterface ThemeContextType {\n  theme: Theme\n  setTheme: (theme: Theme) => void\n  isDark: boolean\n}\n\nconst ThemeContext = createContext<ThemeContextType | undefined>(undefined)\n\nexport function ThemeProvider({ children }: { children: React.ReactNode }) {\n  const [theme, setTheme] = useState<Theme>(() => {\n    // ä»localStorageè¯»å–ä¸»é¢˜è®¾ç½®\n    const saved = localStorage.getItem('zhuge-extract-theme')\n    return (saved as Theme) || 'system'\n  })\n\n  const [isDark, setIsDark] = useState(false)\n\n  useEffect(() => {\n    // ä¿å­˜ä¸»é¢˜è®¾ç½®åˆ°localStorage\n    localStorage.setItem('zhuge-extract-theme', theme)\n\n    // è®¡ç®—å®é™…çš„æš—è‰²æ¨¡å¼çŠ¶æ€\n    const computeDarkMode = () => {\n      if (theme === 'dark') {\n        return true\n      }\n      if (theme === 'light') {\n        return false\n      }\n      // systemæ¨¡å¼ï¼šæ ¹æ®ç³»ç»Ÿåå¥½\n      return window.matchMedia('(prefers-color-scheme: dark)').matches\n    }\n\n    const updateDarkMode = () => {\n      const shouldBeDark = computeDarkMode()\n      setIsDark(shouldBeDark)\n      \n      // æ›´æ–°DOMç±»å\n      if (shouldBeDark) {\n        document.documentElement.classList.add('dark')\n      } else {\n        document.documentElement.classList.remove('dark')\n      }\n    }\n\n    updateDarkMode()\n\n    // ç›‘å¬ç³»ç»Ÿä¸»é¢˜å˜åŒ–\n    const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)')\n    const handleChange = () => {\n      if (theme === 'system') {\n        updateDarkMode()\n      }\n    }\n\n    mediaQuery.addEventListener('change', handleChange)\n    return () => mediaQuery.removeEventListener('change', handleChange)\n  }, [theme])\n\n  const contextValue: ThemeContextType = {\n    theme,\n    setTheme,\n    isDark,\n  }\n\n  return (\n    <ThemeContext.Provider value={contextValue}>\n      {children}\n    </ThemeContext.Provider>\n  )\n}\n\nexport function useTheme() {\n  const context = useContext(ThemeContext)\n  if (context === undefined) {\n    throw new Error('useTheme must be used within a ThemeProvider')\n  }\n  return context\n}","usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/src/main.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/src/pages/AboutPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/src/pages/HelpPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/src/pages/HomePage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/src/pages/PrivacyPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/src/services/archive-service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/src/services/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/src/services/wasm/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/src/services/wasm/libarchive-wrapper.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":262,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":262,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6740,6743],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6740,6743],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":280,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":280,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7217,7220],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7217,7220],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * LibArchive.js WebAssembly Wrapper\n * \n * è¿™ä¸ªæ¨¡å—å°è£…äº†libarchive.jsçš„WebAssemblyåŠŸèƒ½ï¼Œæä¾›äº†ç»Ÿä¸€çš„APIæ¥å¤„ç†å„ç§å‹ç¼©æ ¼å¼\n */\n\nimport { Archive as LibArchiveJS } from 'libarchive.js/main.js'\nimport { ArchiveFile, Archive, SupportedFormat, ExtractionProgress } from '@/types'\n\n// WebAssemblyæ¨¡å—åˆå§‹åŒ–çŠ¶æ€\nlet isLibArchiveInitialized = false\nlet libArchiveModule: typeof LibArchiveJS | null = null\n\n/**\n * åˆå§‹åŒ–LibArchive WebAssemblyæ¨¡å—\n */\nexport async function initializeLibArchive(): Promise<void> {\n  if (isLibArchiveInitialized && libArchiveModule) {\n    return\n  }\n\n  try {\n    // è®¾ç½®WebAssemblyæ–‡ä»¶è·¯å¾„\n    const wasmPath = new URL('libarchive.js/dist/libarchive.wasm', import.meta.url).href\n    \n    // åˆå§‹åŒ–LibArchiveæ¨¡å—\n    libArchiveModule = await LibArchiveJS.init({\n      locateFile: (path: string) => {\n        if (path.endsWith('.wasm')) {\n          return wasmPath\n        }\n        return path\n      }\n    })\n\n    isLibArchiveInitialized = true\n    console.log('LibArchive WebAssembly module initialized successfully')\n  } catch (error) {\n    console.error('Failed to initialize LibArchive:', error)\n    throw new Error(`WebAssembly initialization failed: ${error}`)\n  }\n}\n\n/**\n * æ£€æµ‹æ–‡ä»¶æ ¼å¼\n */\nexport function detectArchiveFormat(fileBuffer: ArrayBuffer): SupportedFormat {\n  const signature = new Uint8Array(fileBuffer.slice(0, 16))\n  \n  // ZIPæ ¼å¼ç­¾å (PK\\x03\\x04 æˆ– PK\\x05\\x06 æˆ– PK\\x07\\x08)\n  if (signature[0] === 0x50 && signature[1] === 0x4B) {\n    if ((signature[2] === 0x03 && signature[3] === 0x04) ||\n        (signature[2] === 0x05 && signature[3] === 0x06) ||\n        (signature[2] === 0x07 && signature[3] === 0x08)) {\n      return 'zip'\n    }\n  }\n  \n  // RARæ ¼å¼ç­¾å\n  if (signature[0] === 0x52 && signature[1] === 0x61 && signature[2] === 0x72 && signature[3] === 0x21) {\n    return 'rar'\n  }\n  \n  // 7Zæ ¼å¼ç­¾å\n  if (signature[0] === 0x37 && signature[1] === 0x7A && signature[2] === 0xBC && signature[3] === 0xAF) {\n    return '7z'\n  }\n  \n  // TARæ ¼å¼ (æ£€æŸ¥æ–‡ä»¶å¤´çš„ç‰¹å®šä½ç½®)\n  const tarCheck = new Uint8Array(fileBuffer.slice(257, 262))\n  if (String.fromCharCode(...tarCheck) === 'ustar') {\n    return 'tar'\n  }\n  \n  // GZIPæ ¼å¼ç­¾å\n  if (signature[0] === 0x1F && signature[1] === 0x8B) {\n    return 'gz'\n  }\n  \n  // BZIP2æ ¼å¼ç­¾å\n  if (signature[0] === 0x42 && signature[1] === 0x5A && signature[2] === 0x68) {\n    return 'bz2'\n  }\n  \n  return 'unknown'\n}\n\n/**\n * è§£æå‹ç¼©æ–‡ä»¶ç»“æ„\n */\nexport async function parseArchiveStructure(\n  fileBuffer: ArrayBuffer,\n  fileName: string,\n  password?: string,\n  onProgress?: (progress: ExtractionProgress) => void\n): Promise<Archive> {\n  if (!isLibArchiveInitialized || !libArchiveModule) {\n    throw new Error('LibArchive module not initialized. Call initializeLibArchive() first.')\n  }\n\n  try {\n    onProgress?.({\n      bytesProcessed: 0,\n      totalBytes: fileBuffer.byteLength,\n      percentage: 0,\n      stage: 'parsing',\n      message: 'æ­£åœ¨è§£æå‹ç¼©æ–‡ä»¶ç»“æ„...'\n    })\n\n    // åˆ›å»ºLibArchiveå®ä¾‹\n    const archive = await libArchiveModule.open(fileBuffer, password)\n    \n    // è·å–æ–‡ä»¶åˆ—è¡¨\n    const files = archive.getFilesArray()\n    const format = detectArchiveFormat(fileBuffer)\n    \n    // è½¬æ¢ä¸ºæˆ‘ä»¬çš„Archiveæ ¼å¼\n    const archiveData: Archive = {\n      id: generateId(),\n      name: fileName,\n      format,\n      size: fileBuffer.byteLength,\n      fileCount: files.length,\n      isPasswordProtected: archive.hasPassword(),\n      structure: files.map(convertLibArchiveFile),\n      metadata: {\n        compressionRatio: calculateCompressionRatio(files, fileBuffer.byteLength)\n      }\n    }\n\n    onProgress?.({\n      bytesProcessed: fileBuffer.byteLength,\n      totalBytes: fileBuffer.byteLength,\n      percentage: 100,\n      stage: 'completed',\n      message: 'è§£æå®Œæˆ'\n    })\n\n    return archiveData\n  } catch (error) {\n    onProgress?.({\n      bytesProcessed: 0,\n      totalBytes: fileBuffer.byteLength,\n      percentage: 0,\n      stage: 'error',\n      message: `è§£æå¤±è´¥: ${error}`\n    })\n    \n    throw new Error(`Failed to parse archive: ${error}`)\n  }\n}\n\n/**\n * æå–å•ä¸ªæ–‡ä»¶\n */\nexport async function extractSingleFile(\n  fileBuffer: ArrayBuffer,\n  filePath: string,\n  password?: string,\n  onProgress?: (progress: ExtractionProgress) => void\n): Promise<ArrayBuffer> {\n  if (!isLibArchiveInitialized || !libArchiveModule) {\n    throw new Error('LibArchive module not initialized')\n  }\n\n  try {\n    onProgress?.({\n      bytesProcessed: 0,\n      totalBytes: fileBuffer.byteLength,\n      percentage: 0,\n      stage: 'extracting',\n      message: `æ­£åœ¨æå–æ–‡ä»¶: ${filePath}`,\n      fileName: filePath\n    })\n\n    const archive = await libArchiveModule.open(fileBuffer, password)\n    const extractedData = await archive.extractSingleFile(filePath, password)\n\n    onProgress?.({\n      bytesProcessed: extractedData.byteLength,\n      totalBytes: extractedData.byteLength,\n      percentage: 100,\n      stage: 'completed',\n      message: 'æå–å®Œæˆ',\n      fileName: filePath\n    })\n\n    return extractedData\n  } catch (error) {\n    onProgress?.({\n      bytesProcessed: 0,\n      totalBytes: fileBuffer.byteLength,\n      percentage: 0,\n      stage: 'error',\n      message: `æå–å¤±è´¥: ${error}`,\n      fileName: filePath\n    })\n    \n    throw new Error(`Failed to extract file ${filePath}: ${error}`)\n  }\n}\n\n/**\n * æ‰¹é‡æå–æ–‡ä»¶\n */\nexport async function extractMultipleFiles(\n  fileBuffer: ArrayBuffer,\n  filePaths: string[],\n  password?: string,\n  onProgress?: (progress: ExtractionProgress) => void\n): Promise<Map<string, ArrayBuffer>> {\n  if (!isLibArchiveInitialized || !libArchiveModule) {\n    throw new Error('LibArchive module not initialized')\n  }\n\n  const results = new Map<string, ArrayBuffer>()\n  let processedCount = 0\n\n  try {\n    const archive = await libArchiveModule.open(fileBuffer, password)\n\n    for (const filePath of filePaths) {\n      onProgress?.({\n        bytesProcessed: processedCount,\n        totalBytes: filePaths.length,\n        percentage: (processedCount / filePaths.length) * 100,\n        stage: 'extracting',\n        message: `æ­£åœ¨æå–æ–‡ä»¶ ${processedCount + 1}/${filePaths.length}: ${filePath}`,\n        fileName: filePath\n      })\n\n      const extractedData = await archive.extractSingleFile(filePath, password)\n      results.set(filePath, extractedData)\n      processedCount++\n    }\n\n    onProgress?.({\n      bytesProcessed: filePaths.length,\n      totalBytes: filePaths.length,\n      percentage: 100,\n      stage: 'completed',\n      message: `æˆåŠŸæå– ${filePaths.length} ä¸ªæ–‡ä»¶`\n    })\n\n    return results\n  } catch (error) {\n    onProgress?.({\n      bytesProcessed: processedCount,\n      totalBytes: filePaths.length,\n      percentage: (processedCount / filePaths.length) * 100,\n      stage: 'error',\n      message: `æ‰¹é‡æå–å¤±è´¥: ${error}`\n    })\n    \n    throw new Error(`Failed to extract files: ${error}`)\n  }\n}\n\n/**\n * è½¬æ¢LibArchiveæ–‡ä»¶å¯¹è±¡åˆ°æˆ‘ä»¬çš„æ ¼å¼\n */\nfunction convertLibArchiveFile(file: any): ArchiveFile {\n  return {\n    id: generateId(),\n    name: file.name || '',\n    path: file.path || file.name || '',\n    size: file.size || 0,\n    compressedSize: file.compressedSize,\n    lastModified: file.lastModified ? new Date(file.lastModified) : new Date(),\n    isDirectory: file.type === 'directory',\n    isEncrypted: file.encrypted || false,\n    compressionMethod: file.method,\n    crc32: file.crc32\n  }\n}\n\n/**\n * è®¡ç®—å‹ç¼©æ¯”\n */\nfunction calculateCompressionRatio(files: any[], archiveSize: number): number {\n  const totalUncompressedSize = files.reduce((sum, file) => sum + (file.size || 0), 0)\n  if (totalUncompressedSize === 0) {return 0}\n  return (archiveSize / totalUncompressedSize)\n}\n\n/**\n * ç”Ÿæˆå”¯ä¸€ID\n */\nfunction generateId(): string {\n  return Math.random().toString(36).substr(2, 9) + Date.now().toString(36)\n}\n\n/**\n * æ£€æŸ¥WebAssemblyæ”¯æŒ\n */\nexport function checkWebAssemblySupport(): boolean {\n  try {\n    if (typeof WebAssembly === 'object' && \n        typeof WebAssembly.instantiate === 'function') {\n      // æ£€æŸ¥SharedArrayBufferæ”¯æŒ (æŸäº›å‹ç¼©ç®—æ³•éœ€è¦)\n      const hasSharedArrayBuffer = typeof SharedArrayBuffer !== 'undefined'\n      \n      if (!hasSharedArrayBuffer) {\n        console.warn('SharedArrayBuffer not available. Some features may be limited.')\n      }\n      \n      return true\n    }\n    return false\n  } catch {\n    return false\n  }\n}\n\n/**\n * è·å–æ”¯æŒçš„æ ¼å¼åˆ—è¡¨\n */\nexport function getSupportedFormats(): SupportedFormat[] {\n  return ['zip', 'rar', '7z', 'tar', 'gz', 'bz2']\n}\n\n/**\n * æ¸…ç†èµ„æº\n */\nexport function cleanup(): void {\n  // åœ¨è¿™é‡Œå¯ä»¥æ·»åŠ æ¸…ç†é€»è¾‘ï¼Œå¦‚é‡Šæ”¾WebAssemblyå†…å­˜ç­‰\n  console.log('LibArchive wrapper cleanup completed')\n}","usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/src/services/wasm/worker-manager.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":12,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":12,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[274,277],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[274,277],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":137,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":137,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3238,3241],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3238,3241],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":139,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":139,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3313,3316],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3313,3316],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * WebAssembly Worker Manager\n * \n * ç®¡ç†WebAssembly Workerçš„ç”Ÿå‘½å‘¨æœŸï¼Œæä¾›é˜Ÿåˆ—å¤„ç†å’Œé”™è¯¯æ¢å¤\n */\n\nimport { Archive, ExtractionProgress, SupportedFormat } from '@/types'\nimport type { WorkerMessage, WorkerResponse } from './worker'\n\ninterface PendingTask {\n  id: string\n  resolve: (value: any) => void\n  reject: (error: Error) => void\n  onProgress?: (progress: ExtractionProgress) => void\n}\n\nexport class WorkerManager {\n  private worker: Worker | null = null\n  private isInitialized = false\n  private pendingTasks = new Map<string, PendingTask>()\n  private taskIdCounter = 0\n  private maxRetries = 3\n  private retryCount = 0\n\n  constructor() {\n    this.initializeWorker()\n  }\n\n  /**\n   * åˆå§‹åŒ–Worker\n   */\n  private async initializeWorker(): Promise<void> {\n    try {\n      // åˆ›å»ºWorker\n      this.worker = new Worker(\n        new URL('./worker.ts', import.meta.url),\n        { type: 'module' }\n      )\n\n      // ç›‘å¬Workeræ¶ˆæ¯\n      this.worker.addEventListener('message', this.handleWorkerMessage.bind(this))\n      this.worker.addEventListener('error', this.handleWorkerError.bind(this))\n\n      // åˆå§‹åŒ–WebAssemblyæ¨¡å—\n      await this.sendMessage('init', {})\n      this.isInitialized = true\n      this.retryCount = 0\n\n      console.log('WebAssembly Worker initialized successfully')\n    } catch (error) {\n      console.error('Failed to initialize WebAssembly Worker:', error)\n      throw new Error(`Worker initialization failed: ${error}`)\n    }\n  }\n\n  /**\n   * æ£€æµ‹å‹ç¼©æ–‡ä»¶æ ¼å¼\n   */\n  async detectFormat(fileBuffer: ArrayBuffer): Promise<SupportedFormat> {\n    this.ensureInitialized()\n    \n    const result = await this.sendMessage('detect-format', { fileBuffer })\n    return result.format\n  }\n\n  /**\n   * è§£æå‹ç¼©æ–‡ä»¶ç»“æ„\n   */\n  async parseArchive(\n    fileBuffer: ArrayBuffer,\n    fileName: string,\n    password?: string,\n    onProgress?: (progress: ExtractionProgress) => void\n  ): Promise<Archive> {\n    this.ensureInitialized()\n    \n    const result = await this.sendMessage('parse', {\n      fileBuffer,\n      fileName,\n      password\n    }, onProgress)\n    \n    return result.archive\n  }\n\n  /**\n   * æå–å•ä¸ªæ–‡ä»¶\n   */\n  async extractSingleFile(\n    fileBuffer: ArrayBuffer,\n    filePath: string,\n    password?: string,\n    onProgress?: (progress: ExtractionProgress) => void\n  ): Promise<ArrayBuffer> {\n    this.ensureInitialized()\n    \n    const result = await this.sendMessage('extract-single', {\n      fileBuffer,\n      filePath,\n      password\n    }, onProgress)\n    \n    return result.data\n  }\n\n  /**\n   * æ‰¹é‡æå–æ–‡ä»¶\n   */\n  async extractMultipleFiles(\n    fileBuffer: ArrayBuffer,\n    filePaths: string[],\n    password?: string,\n    onProgress?: (progress: ExtractionProgress) => void\n  ): Promise<Map<string, ArrayBuffer>> {\n    this.ensureInitialized()\n    \n    const result = await this.sendMessage('extract-multiple', {\n      fileBuffer,\n      filePaths,\n      password\n    }, onProgress)\n    \n    // å°†å¯¹è±¡è½¬æ¢å›Map\n    const filesMap = new Map<string, ArrayBuffer>()\n    Object.entries(result.files).forEach(([path, data]) => {\n      filesMap.set(path, data as ArrayBuffer)\n    })\n    \n    return filesMap\n  }\n\n  /**\n   * å‘é€æ¶ˆæ¯åˆ°Worker\n   */\n  private async sendMessage(\n    type: 'init' | 'parse' | 'extract-single' | 'extract-multiple' | 'detect-format', \n    payload: any, \n    onProgress?: (progress: ExtractionProgress) => void\n  ): Promise<any> {\n    if (!this.worker) {\n      throw new Error('Worker not available')\n    }\n\n    const id = this.generateTaskId()\n    \n    return new Promise((resolve, reject) => {\n      // å­˜å‚¨å¾…å¤„ç†ä»»åŠ¡\n      this.pendingTasks.set(id, {\n        id,\n        resolve,\n        reject,\n        onProgress\n      })\n\n      // å‘é€æ¶ˆæ¯\n      const message: WorkerMessage = { id, type, payload }\n      this.worker!.postMessage(message)\n\n      // è®¾ç½®è¶…æ—¶\n      setTimeout(() => {\n        if (this.pendingTasks.has(id)) {\n          this.pendingTasks.delete(id)\n          reject(new Error(`Task ${id} timed out`))\n        }\n      }, 60000) // 60ç§’è¶…æ—¶\n    })\n  }\n\n  /**\n   * å¤„ç†Workeræ¶ˆæ¯\n   */\n  private handleWorkerMessage(event: MessageEvent<WorkerResponse>): void {\n    const { id, type, payload, error } = event.data\n    const task = this.pendingTasks.get(id)\n    \n    if (!task) {\n      console.warn(`Received message for unknown task: ${id}`)\n      return\n    }\n\n    switch (type) {\n      case 'success':\n        this.pendingTasks.delete(id)\n        task.resolve(payload)\n        break\n      \n      case 'error':\n        this.pendingTasks.delete(id)\n        task.reject(new Error(error || 'Unknown worker error'))\n        break\n      \n      case 'progress':\n        if (task.onProgress && payload) {\n          task.onProgress(payload as ExtractionProgress)\n        }\n        break\n      \n      default:\n        console.warn(`Unknown response type: ${type}`)\n    }\n  }\n\n  /**\n   * å¤„ç†Workeré”™è¯¯\n   */\n  private async handleWorkerError(event: ErrorEvent): Promise<void> {\n    console.error('Worker error:', event.error)\n    \n    // æ‹’ç»æ‰€æœ‰å¾…å¤„ç†çš„ä»»åŠ¡\n    this.pendingTasks.forEach(task => {\n      task.reject(new Error('Worker crashed'))\n    })\n    this.pendingTasks.clear()\n    \n    // å°è¯•é‡æ–°åˆå§‹åŒ–Worker\n    if (this.retryCount < this.maxRetries) {\n      this.retryCount++\n      console.log(`Attempting to restart worker (${this.retryCount}/${this.maxRetries})`)\n      \n      try {\n        await this.restartWorker()\n      } catch (error) {\n        console.error('Failed to restart worker:', error)\n      }\n    } else {\n      console.error('Max retry attempts reached. Worker will not be restarted.')\n      this.isInitialized = false\n    }\n  }\n\n  /**\n   * é‡å¯Worker\n   */\n  private async restartWorker(): Promise<void> {\n    // ç»ˆæ­¢ç°æœ‰Worker\n    if (this.worker) {\n      this.worker.terminate()\n      this.worker = null\n    }\n    \n    this.isInitialized = false\n    \n    // é‡æ–°åˆå§‹åŒ–\n    await this.initializeWorker()\n  }\n\n  /**\n   * ç”Ÿæˆä»»åŠ¡ID\n   */\n  private generateTaskId(): string {\n    return `task_${++this.taskIdCounter}_${Date.now()}`\n  }\n\n  /**\n   * ç¡®ä¿Workerå·²åˆå§‹åŒ–\n   */\n  private ensureInitialized(): void {\n    if (!this.isInitialized || !this.worker) {\n      throw new Error('Worker not initialized. Please wait for initialization to complete.')\n    }\n  }\n\n  /**\n   * è·å–WorkerçŠ¶æ€\n   */\n  getStatus(): {\n    isInitialized: boolean\n    pendingTasks: number\n    retryCount: number\n  } {\n    return {\n      isInitialized: this.isInitialized,\n      pendingTasks: this.pendingTasks.size,\n      retryCount: this.retryCount\n    }\n  }\n\n  /**\n   * æ¸…ç†èµ„æº\n   */\n  destroy(): void {\n    // æ‹’ç»æ‰€æœ‰å¾…å¤„ç†çš„ä»»åŠ¡\n    this.pendingTasks.forEach(task => {\n      task.reject(new Error('Worker manager destroyed'))\n    })\n    this.pendingTasks.clear()\n\n    // ç»ˆæ­¢Worker\n    if (this.worker) {\n      this.worker.terminate()\n      this.worker = null\n    }\n\n    this.isInitialized = false\n    console.log('WebAssembly Worker Manager destroyed')\n  }\n}\n\n// å•ä¾‹å®ä¾‹\nlet workerManagerInstance: WorkerManager | null = null\n\n/**\n * è·å–Worker Managerå•ä¾‹\n */\nexport function getWorkerManager(): WorkerManager {\n  if (!workerManagerInstance) {\n    workerManagerInstance = new WorkerManager()\n  }\n  return workerManagerInstance\n}\n\n/**\n * é”€æ¯Worker Managerå•ä¾‹\n */\nexport function destroyWorkerManager(): void {\n  if (workerManagerInstance) {\n    workerManagerInstance.destroy()\n    workerManagerInstance = null\n  }\n}","usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/src/services/wasm/worker.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":20,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":20,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[435,438],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[435,438],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":26,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":26,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[542,545],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[542,545],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":202,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":202,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4134,4137],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4134,4137],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * WebAssembly Worker\n * \n * è¿™ä¸ªWorkeråœ¨åå°çº¿ç¨‹ä¸­å¤„ç†å‹ç¼©æ–‡ä»¶è§£æå’Œæå–ï¼Œé¿å…é˜»å¡ä¸»çº¿ç¨‹\n */\n\nimport { \n  initializeLibArchive, \n  parseArchiveStructure, \n  extractSingleFile, \n  extractMultipleFiles,\n  detectArchiveFormat \n} from './libarchive-wrapper'\nimport { ExtractionProgress } from '@/types'\n\n// Workeræ¶ˆæ¯ç±»å‹å®šä¹‰\nexport interface WorkerMessage {\n  id: string\n  type: 'init' | 'parse' | 'extract-single' | 'extract-multiple' | 'detect-format'\n  payload?: any\n}\n\nexport interface WorkerResponse {\n  id: string\n  type: 'success' | 'error' | 'progress'\n  payload?: any\n  error?: string\n}\n\n// åˆå§‹åŒ–çŠ¶æ€\nlet isInitialized = false\n\n// å¤„ç†æ¥è‡ªä¸»çº¿ç¨‹çš„æ¶ˆæ¯\nself.addEventListener('message', async (event: MessageEvent<WorkerMessage>) => {\n  const { id, type, payload } = event.data\n\n  try {\n    switch (type) {\n      case 'init':\n        await handleInit(id)\n        break\n      \n      case 'parse':\n        await handleParseArchive(id, payload)\n        break\n      \n      case 'extract-single':\n        await handleExtractSingle(id, payload)\n        break\n      \n      case 'extract-multiple':\n        await handleExtractMultiple(id, payload)\n        break\n      \n      case 'detect-format':\n        await handleDetectFormat(id, payload)\n        break\n      \n      default:\n        sendError(id, `Unknown message type: ${type}`)\n    }\n  } catch (error) {\n    sendError(id, `Worker error: ${error}`)\n  }\n})\n\n/**\n * åˆå§‹åŒ–WebAssemblyæ¨¡å—\n */\nasync function handleInit(id: string): Promise<void> {\n  if (isInitialized) {\n    sendSuccess(id, { initialized: true })\n    return\n  }\n\n  try {\n    await initializeLibArchive()\n    isInitialized = true\n    sendSuccess(id, { initialized: true })\n  } catch (error) {\n    sendError(id, `Initialization failed: ${error}`)\n  }\n}\n\n/**\n * è§£æå‹ç¼©æ–‡ä»¶ç»“æ„\n */\nasync function handleParseArchive(id: string, payload: {\n  fileBuffer: ArrayBuffer\n  fileName: string\n  password?: string\n}): Promise<void> {\n  if (!isInitialized) {\n    sendError(id, 'Worker not initialized')\n    return\n  }\n\n  const { fileBuffer, fileName, password } = payload\n\n  try {\n    const archive = await parseArchiveStructure(\n      fileBuffer,\n      fileName,\n      password,\n      (progress) => sendProgress(id, progress)\n    )\n    \n    sendSuccess(id, { archive })\n  } catch (error) {\n    sendError(id, `Parse failed: ${error}`)\n  }\n}\n\n/**\n * æå–å•ä¸ªæ–‡ä»¶\n */\nasync function handleExtractSingle(id: string, payload: {\n  fileBuffer: ArrayBuffer\n  filePath: string\n  password?: string\n}): Promise<void> {\n  if (!isInitialized) {\n    sendError(id, 'Worker not initialized')\n    return\n  }\n\n  const { fileBuffer, filePath, password } = payload\n\n  try {\n    const extractedData = await extractSingleFile(\n      fileBuffer,\n      filePath,\n      password,\n      (progress) => sendProgress(id, progress)\n    )\n    \n    sendSuccess(id, { \n      filePath, \n      data: extractedData,\n      size: extractedData.byteLength \n    })\n  } catch (error) {\n    sendError(id, `Extract single file failed: ${error}`)\n  }\n}\n\n/**\n * æ‰¹é‡æå–æ–‡ä»¶\n */\nasync function handleExtractMultiple(id: string, payload: {\n  fileBuffer: ArrayBuffer\n  filePaths: string[]\n  password?: string\n}): Promise<void> {\n  if (!isInitialized) {\n    sendError(id, 'Worker not initialized')\n    return\n  }\n\n  const { fileBuffer, filePaths, password } = payload\n\n  try {\n    const extractedFiles = await extractMultipleFiles(\n      fileBuffer,\n      filePaths,\n      password,\n      (progress) => sendProgress(id, progress)\n    )\n    \n    // å°†Mapè½¬æ¢ä¸ºæ™®é€šå¯¹è±¡ä»¥ä¾¿åºåˆ—åŒ–\n    const filesObject: Record<string, ArrayBuffer> = {}\n    extractedFiles.forEach((data, path) => {\n      filesObject[path] = data\n    })\n    \n    sendSuccess(id, { \n      files: filesObject,\n      count: filePaths.length \n    })\n  } catch (error) {\n    sendError(id, `Extract multiple files failed: ${error}`)\n  }\n}\n\n/**\n * æ£€æµ‹æ–‡ä»¶æ ¼å¼\n */\nasync function handleDetectFormat(id: string, payload: {\n  fileBuffer: ArrayBuffer\n}): Promise<void> {\n  try {\n    const format = detectArchiveFormat(payload.fileBuffer)\n    sendSuccess(id, { format })\n  } catch (error) {\n    sendError(id, `Format detection failed: ${error}`)\n  }\n}\n\n/**\n * å‘é€æˆåŠŸå“åº”\n */\nfunction sendSuccess(id: string, payload: any): void {\n  const response: WorkerResponse = {\n    id,\n    type: 'success',\n    payload\n  }\n  self.postMessage(response)\n}\n\n/**\n * å‘é€é”™è¯¯å“åº”\n */\nfunction sendError(id: string, error: string): void {\n  const response: WorkerResponse = {\n    id,\n    type: 'error',\n    error\n  }\n  self.postMessage(response)\n}\n\n/**\n * å‘é€è¿›åº¦æ›´æ–°\n */\nfunction sendProgress(id: string, progress: ExtractionProgress): void {\n  const response: WorkerResponse = {\n    id,\n    type: 'progress',\n    payload: progress\n  }\n  self.postMessage(response)\n}\n\n// å¤„ç†æœªæ•è·çš„é”™è¯¯\nself.addEventListener('error', (event) => {\n  console.error('Worker error:', event.error)\n})\n\nself.addEventListener('unhandledrejection', (event) => {\n  console.error('Worker unhandled rejection:', event.reason)\n})\n\n// Types are already exported above","usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/src/types/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/src/types/libarchive.d.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":3,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":3,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[100,103],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[100,103],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"declare module 'libarchive.js/main.js' {\n  export interface LibArchiveReader {\n    getFilesArray(): any[]\n    extractSingleFile(path: string, password?: string): Promise<ArrayBuffer>\n    extractFiles(password?: string): Promise<Map<string, ArrayBuffer>>\n    hasPassword(): boolean\n    close(): void\n  }\n\n  export interface LibArchiveStatic {\n    init(options?: { locateFile?: (path: string) => string }): Promise<LibArchiveStatic>\n    open(data: ArrayBuffer, password?: string): Promise<LibArchiveReader>\n  }\n\n  export const Archive: LibArchiveStatic\n}","usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/src/utils/file-utils.ts","messages":[{"ruleId":"no-control-regex","severity":2,"message":"Unexpected control character(s) in regular expression: \\x00, \\x1f.","line":37,"column":52,"nodeType":"Literal","messageId":"unexpected","endLine":37,"endColumn":75},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\/.","line":547,"column":35,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":547,"endColumn":36,"suggestions":[{"messageId":"removeEscape","fix":{"range":[13512,13513],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[13512,13512],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * æ–‡ä»¶å¤„ç†å·¥å…·\n * æä¾›æ–‡ä»¶æ“ä½œã€éªŒè¯å’Œå¤„ç†çš„é€šç”¨åŠŸèƒ½\n */\n\nexport interface FileInfo {\n  name: string;\n  size: number;\n  type: string;\n  lastModified: number;\n  path?: string;\n}\n\nexport interface FileValidationResult {\n  isValid: boolean;\n  errors: string[];\n  warnings: string[];\n}\n\nexport interface SecurityScanResult {\n  isSafe: boolean;\n  threats: string[];\n  riskLevel: 'low' | 'medium' | 'high';\n}\n\nexport class FileUtils {\n  // å±é™©æ–‡ä»¶æ‰©å±•ååˆ—è¡¨\n  private static readonly DANGEROUS_EXTENSIONS = [\n    'exe', 'bat', 'cmd', 'com', 'pif', 'scr', 'vbs', 'js', 'jar',\n    'msi', 'dll', 'sys', 'app', 'deb', 'pkg', 'dmg', 'sh'\n  ];\n\n  // æœ€å¤§æ–‡ä»¶åé•¿åº¦\n  private static readonly MAX_FILENAME_LENGTH = 255;\n\n  // éæ³•æ–‡ä»¶åå­—ç¬¦\n  private static readonly ILLEGAL_FILENAME_CHARS = /[<>:\"/\\\\|?*\\x00-\\x1f]/;\n\n  /**\n   * è·å–æ–‡ä»¶æ‰©å±•å\n   * @param filename æ–‡ä»¶å\n   * @returns æ‰©å±•åï¼ˆå°å†™ï¼Œä¸å«ç‚¹ï¼‰\n   */\n  static getFileExtension(filename: string): string {\n    const lastDot = filename.lastIndexOf('.');\n    if (lastDot === -1 || lastDot === filename.length - 1) {\n      return '';\n    }\n    return filename.substring(lastDot + 1).toLowerCase();\n  }\n\n  /**\n   * è·å–ä¸å«æ‰©å±•åçš„æ–‡ä»¶å\n   * @param filename æ–‡ä»¶å\n   * @returns åŸºç¡€æ–‡ä»¶å\n   */\n  static getBaseName(filename: string): string {\n    const lastDot = filename.lastIndexOf('.');\n    const lastSlash = Math.max(filename.lastIndexOf('/'), filename.lastIndexOf('\\\\'));\n    \n    const start = lastSlash + 1;\n    const end = lastDot === -1 ? filename.length : lastDot;\n    \n    return filename.substring(start, end);\n  }\n\n  /**\n   * è¯»å–æ–‡ä»¶ä¸ºBase64\n   * @param file æ–‡ä»¶å¯¹è±¡\n   * @returns Promise<string>\n   */\n  static readFileAsBase64(file: File): Promise<string> {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      \n      reader.onload = (event) => {\n        const result = event.target?.result;\n        if (typeof result === 'string') {\n          resolve(result);\n        } else {\n          reject(new Error('Failed to read file as Base64'));\n        }\n      };\n      \n      reader.onerror = () => {\n        reject(new Error('FileReader error'));\n      };\n      \n      reader.readAsDataURL(file);\n    });\n  }\n\n  /**\n   * è¯»å–æ–‡ä»¶å¤´éƒ¨å­—èŠ‚\n   * @param file æ–‡ä»¶å¯¹è±¡\n   * @param length è¯»å–é•¿åº¦ï¼Œé»˜è®¤16å­—èŠ‚\n   * @returns Promise<Uint8Array>\n   */\n  static async readFileHeader(file: File, length: number = 16): Promise<Uint8Array> {\n    const slice = file.slice(0, length);\n    const buffer = await this.readFileAsArrayBuffer(slice as File);\n    return new Uint8Array(buffer);\n  }\n\n  /**\n   * éªŒè¯æ–‡ä»¶å¤§å°\n   * @param file æ–‡ä»¶å¯¹è±¡\n   * @param maxSize æœ€å¤§å¤§å°ï¼ˆå­—èŠ‚ï¼‰\n   * @param minSize æœ€å°å¤§å°ï¼ˆå­—èŠ‚ï¼‰\n   * @returns boolean\n   */\n  static validateFileSize(file: File, maxSize?: number, minSize?: number): boolean {\n    if (minSize !== undefined && file.size < minSize) {\n      return false;\n    }\n    if (maxSize !== undefined && file.size > maxSize) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * éªŒè¯æ–‡ä»¶ç±»å‹\n   * @param file æ–‡ä»¶å¯¹è±¡\n   * @param allowedTypes å…è®¸çš„MIMEç±»å‹æ•°ç»„\n   * @returns boolean\n   */\n  static validateFileType(file: File, allowedTypes: string[]): boolean {\n    return allowedTypes.includes(file.type);\n  }\n\n  /**\n   * éªŒè¯æ–‡ä»¶æ‰©å±•å\n   * @param filename æ–‡ä»¶å\n   * @param allowedExtensions å…è®¸çš„æ‰©å±•åæ•°ç»„\n   * @returns boolean\n   */\n  static validateFileExtension(filename: string, allowedExtensions: string[]): boolean {\n    const ext = this.getFileExtension(filename);\n    return allowedExtensions.includes(ext);\n  }\n\n  /**\n   * åˆ›å»ºå¯¹è±¡URL\n   * @param file æ–‡ä»¶æˆ–Blobå¯¹è±¡\n   * @returns string\n   */\n  static createObjectURL(file: File | Blob): string {\n    return URL.createObjectURL(file);\n  }\n\n  /**\n   * ä»Base64åˆ›å»ºBlob\n   * @param base64 Base64å­—ç¬¦ä¸²\n   * @param mimeType MIMEç±»å‹\n   * @returns Blob\n   */\n  static base64ToBlob(base64: string, mimeType: string = 'application/octet-stream'): Blob {\n    const base64Data = base64.includes(',') ? base64.split(',')[1] : base64;\n    const byteCharacters = atob(base64Data);\n    const byteNumbers = new Array(byteCharacters.length);\n    \n    for (let i = 0; i < byteCharacters.length; i++) {\n      byteNumbers[i] = byteCharacters.charCodeAt(i);\n    }\n    \n    const byteArray = new Uint8Array(byteNumbers);\n    return new Blob([byteArray], { type: mimeType });\n  }\n\n  /**\n   * ä¸‹è½½Blobä¸ºæ–‡ä»¶\n   * @param blob Blobå¯¹è±¡\n   * @param filename æ–‡ä»¶å\n   */\n  static downloadBlob(blob: Blob, filename: string): void {\n    const url = this.createObjectURL(blob);\n    const link = document.createElement('a');\n    link.href = url;\n    link.download = filename;\n    document.body.appendChild(link);\n    link.click();\n    document.body.removeChild(link);\n    URL.revokeObjectURL(url);\n  }\n\n  /**\n   * æ¸…ç†æ–‡ä»¶åï¼Œç§»é™¤éæ³•å­—ç¬¦\n   * @param filename åŸå§‹æ–‡ä»¶å\n   * @returns æ¸…ç†åçš„æ–‡ä»¶å\n   */\n  static sanitizeFileName(filename: string): string {\n    return this.sanitizeFilename(filename);\n  }\n\n  /**\n   * æ¸…ç†æ–‡ä»¶åï¼Œç§»é™¤éæ³•å­—ç¬¦\n   * @param filename åŸå§‹æ–‡ä»¶å\n   * @returns æ¸…ç†åçš„æ–‡ä»¶å\n   */\n  static sanitizeFilename(filename: string): string {\n    // ç§»é™¤éæ³•å­—ç¬¦\n    let clean = filename.replace(this.ILLEGAL_FILENAME_CHARS, '_');\n    \n    // ç§»é™¤é¦–å°¾ç©ºæ ¼å’Œç‚¹\n    clean = clean.trim().replace(/^\\.+|\\.+$/g, '');\n    \n    // é™åˆ¶é•¿åº¦\n    if (clean.length > this.MAX_FILENAME_LENGTH) {\n      const ext = this.getFileExtension(filename);\n      const maxBaseName = this.MAX_FILENAME_LENGTH - ext.length - 1;\n      const baseName = this.getBaseName(clean).substring(0, maxBaseName);\n      clean = ext ? `${baseName}.${ext}` : baseName;\n    }\n    \n    // ç¡®ä¿ä¸ä¸ºç©º\n    if (!clean) {\n      clean = 'unnamed_file';\n    }\n    \n    return clean;\n  }\n\n  /**\n   * éªŒè¯æ–‡ä»¶åæ˜¯å¦åˆæ³•\n   * @param filename æ–‡ä»¶å\n   * @returns éªŒè¯ç»“æœ\n   */\n  static validateFilename(filename: string): FileValidationResult {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n\n    if (!filename || filename.trim().length === 0) {\n      errors.push('æ–‡ä»¶åä¸èƒ½ä¸ºç©º');\n      return { isValid: false, errors, warnings };\n    }\n\n    // æ£€æŸ¥é•¿åº¦\n    if (filename.length > this.MAX_FILENAME_LENGTH) {\n      errors.push(`æ–‡ä»¶åè¿‡é•¿ (æœ€å¤§${this.MAX_FILENAME_LENGTH}å­—ç¬¦)`);\n    }\n\n    // æ£€æŸ¥éæ³•å­—ç¬¦\n    if (this.ILLEGAL_FILENAME_CHARS.test(filename)) {\n      errors.push('æ–‡ä»¶ååŒ…å«éæ³•å­—ç¬¦');\n    }\n\n    // æ£€æŸ¥æ˜¯å¦ä»¥ç‚¹å¼€å¤´æˆ–ç»“å°¾\n    if (filename.startsWith('.') || filename.endsWith('.')) {\n      warnings.push('æ–‡ä»¶åä¸åº”ä»¥ç‚¹å¼€å¤´æˆ–ç»“å°¾');\n    }\n\n    // æ£€æŸ¥å±é™©æ‰©å±•å\n    const ext = this.getFileExtension(filename);\n    if (this.DANGEROUS_EXTENSIONS.includes(ext)) {\n      warnings.push(`æ–‡ä»¶æ‰©å±•å \"${ext}\" å¯èƒ½å­˜åœ¨å®‰å…¨é£é™©`);\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors,\n      warnings\n    };\n  }\n\n  /**\n   * æ£€æŸ¥æ–‡ä»¶æ˜¯å¦ä¸ºå‹ç¼©æ–‡ä»¶\n   * @param filename æ–‡ä»¶åæˆ–fileå¯¹è±¡\n   * @returns æ˜¯å¦ä¸ºå‹ç¼©æ–‡ä»¶\n   */\n  static isArchiveFile(filename: string | File): boolean {\n    const name = typeof filename === 'string' ? filename : filename.name;\n    const ext = this.getFileExtension(name);\n    \n    const archiveExtensions = [\n      'zip', 'rar', '7z', 'tar', 'gz', 'bz2', 'xz', 'lzma',\n      'tgz', 'tbz2', 'txz', 'jar', 'war', 'ear'\n    ];\n    \n    return archiveExtensions.includes(ext);\n  }\n\n  /**\n   * æ ¼å¼åŒ–æ–‡ä»¶å¤§å°\n   * @param bytes å­—èŠ‚æ•°\n   * @param precision ç²¾åº¦ï¼Œé»˜è®¤2ä½å°æ•°\n   * @returns æ ¼å¼åŒ–çš„å¤§å°å­—ç¬¦ä¸²\n   */\n  static formatFileSize(bytes: number, precision: number = 2): string {\n    if (bytes === 0) {return '0 B';}\n    \n    const units = ['B', 'KB', 'MB', 'GB', 'TB'];\n    const k = 1024;\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    \n    return `${(bytes / Math.pow(k, i)).toFixed(precision)} ${units[i]}`;\n  }\n\n  /**\n   * è¯»å–æ–‡ä»¶ä¸ºArrayBuffer\n   * @param file æ–‡ä»¶å¯¹è±¡\n   * @returns Promise<ArrayBuffer>\n   */\n  static readFileAsArrayBuffer(file: File): Promise<ArrayBuffer> {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      \n      reader.onload = (event) => {\n        const result = event.target?.result;\n        if (result instanceof ArrayBuffer) {\n          resolve(result);\n        } else {\n          reject(new Error('Failed to read file as ArrayBuffer'));\n        }\n      };\n      \n      reader.onerror = () => {\n        reject(new Error('FileReader error'));\n      };\n      \n      reader.readAsArrayBuffer(file);\n    });\n  }\n\n  /**\n   * è¯»å–æ–‡ä»¶ä¸ºæ–‡æœ¬\n   * @param file æ–‡ä»¶å¯¹è±¡\n   * @param encoding ç¼–ç æ ¼å¼ï¼Œé»˜è®¤UTF-8\n   * @returns Promise<string>\n   */\n  static readFileAsText(file: File, encoding: string = 'UTF-8'): Promise<string> {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      \n      reader.onload = (event) => {\n        const result = event.target?.result;\n        if (typeof result === 'string') {\n          resolve(result);\n        } else {\n          reject(new Error('Failed to read file as text'));\n        }\n      };\n      \n      reader.onerror = () => {\n        reject(new Error('FileReader error'));\n      };\n      \n      reader.readAsText(file, encoding);\n    });\n  }\n\n  /**\n   * æ£€æŸ¥æ–‡ä»¶MIMEç±»å‹\n   * @param file æ–‡ä»¶å¯¹è±¡\n   * @returns å®é™…MIMEç±»å‹\n   */\n  static async detectMimeType(file: File): Promise<string> {\n    // ç®€å•çš„MIMEç±»å‹æ£€æµ‹åŸºäºæ–‡ä»¶å¤´\n    const buffer = await this.readFileAsArrayBuffer(file.slice(0, 16) as File);\n    const bytes = new Uint8Array(buffer);\n    \n    // ZIPæ–‡ä»¶\n    if (bytes[0] === 0x50 && bytes[1] === 0x4B) {\n      return 'application/zip';\n    }\n    \n    // RARæ–‡ä»¶\n    if (bytes[0] === 0x52 && bytes[1] === 0x61 && bytes[2] === 0x72) {\n      return 'application/x-rar-compressed';\n    }\n    \n    // 7Zæ–‡ä»¶\n    if (bytes[0] === 0x37 && bytes[1] === 0x7A && bytes[2] === 0xBC && bytes[3] === 0xAF) {\n      return 'application/x-7z-compressed';\n    }\n    \n    // GZIPæ–‡ä»¶\n    if (bytes[0] === 0x1F && bytes[1] === 0x8B) {\n      return 'application/gzip';\n    }\n    \n    // å›é€€åˆ°æ–‡ä»¶å£°æ˜çš„ç±»å‹\n    return file.type || 'application/octet-stream';\n  }\n\n  /**\n   * å®‰å…¨æ‰«ææ–‡ä»¶\n   * @param file æ–‡ä»¶å¯¹è±¡\n   * @returns Promise<SecurityScanResult>\n   */\n  static async securityScan(file: File): Promise<SecurityScanResult> {\n    const threats: string[] = [];\n    let riskLevel: 'low' | 'medium' | 'high' = 'low';\n\n    // æ£€æŸ¥æ–‡ä»¶æ‰©å±•å\n    const ext = this.getFileExtension(file.name);\n    if (this.DANGEROUS_EXTENSIONS.includes(ext)) {\n      threats.push(`Dangerous file extension: ${ext}`);\n      riskLevel = 'high';\n    }\n\n    // æ£€æŸ¥æ–‡ä»¶å¤§å°å¼‚å¸¸\n    if (file.size === 0) {\n      threats.push('Empty file');\n      riskLevel = 'medium';\n    } else if (file.size > 5 * 1024 * 1024 * 1024) { // 5GB\n      threats.push('Unusually large file size');\n      riskLevel = 'medium';\n    }\n\n    // æ£€æŸ¥æ–‡ä»¶åå¼‚å¸¸\n    const filenameValidation = this.validateFilename(file.name);\n    if (!filenameValidation.isValid) {\n      threats.push('Invalid filename characters');\n      riskLevel = riskLevel === 'high' ? 'high' : 'medium';\n    }\n\n    // æ£€æŸ¥MIMEç±»å‹ä¸åŒ¹é…\n    try {\n      const detectedMime = await this.detectMimeType(file);\n      if (file.type && file.type !== detectedMime && file.type !== 'application/octet-stream') {\n        threats.push('MIME type mismatch');\n        riskLevel = riskLevel === 'high' ? 'high' : 'medium';\n      }\n    } catch (error) {\n      threats.push('Failed to verify file type');\n      riskLevel = 'medium';\n    }\n\n    // æ£€æŸ¥æ–‡ä»¶åé•¿åº¦æ”»å‡»\n    if (file.name.length > 200) {\n      threats.push('Filename too long (potential overflow attack)');\n      riskLevel = 'medium';\n    }\n\n    // æ£€æŸ¥è·¯å¾„éå†æ”»å‡»æ¨¡å¼\n    if (file.name.includes('../') || file.name.includes('..\\\\')) {\n      threats.push('Path traversal attack pattern detected');\n      riskLevel = 'high';\n    }\n\n    return {\n      isSafe: threats.length === 0,\n      threats,\n      riskLevel\n    };\n  }\n\n  /**\n   * è®¡ç®—æ–‡ä»¶å“ˆå¸Œå€¼ï¼ˆç®€å•ç‰ˆæœ¬ï¼‰\n   * @param file æ–‡ä»¶å¯¹è±¡\n   * @returns Promise<string> å“ˆå¸Œå€¼\n   */\n  static async calculateSimpleHash(file: File): Promise<string> {\n    const buffer = await this.readFileAsArrayBuffer(file);\n    const bytes = new Uint8Array(buffer);\n    \n    let hash = 0;\n    for (let i = 0; i < bytes.length; i++) {\n      hash = ((hash << 5) - hash + bytes[i]) & 0xffffffff;\n    }\n    \n    return Math.abs(hash).toString(16);\n  }\n\n  /**\n   * éªŒè¯æ–‡ä»¶å®Œæ•´æ€§\n   * @param file æ–‡ä»¶å¯¹è±¡\n   * @param expectedSize æœŸæœ›å¤§å°ï¼ˆå¯é€‰ï¼‰\n   * @param expectedHash æœŸæœ›å“ˆå¸Œå€¼ï¼ˆå¯é€‰ï¼‰\n   * @returns Promise<boolean>\n   */\n  static async validateFileIntegrity(\n    file: File, \n    expectedSize?: number, \n    expectedHash?: string\n  ): Promise<boolean> {\n    try {\n      if (expectedSize !== undefined && file.size !== expectedSize) {\n        return false;\n      }\n      \n      if (expectedHash !== undefined) {\n        const actualHash = await this.calculateSimpleHash(file);\n        if (actualHash !== expectedHash) {\n          return false;\n        }\n      }\n      \n      return true;\n    } catch (error) {\n      return false;\n    }\n  }\n\n  /**\n   * åˆ›å»ºæ–‡ä»¶ä¿¡æ¯å¯¹è±¡\n   * @param file æ–‡ä»¶å¯¹è±¡\n   * @returns FileInfo\n   */\n  static createFileInfo(file: File): FileInfo {\n    return {\n      name: file.name,\n      size: file.size,\n      type: file.type,\n      lastModified: file.lastModified\n    };\n  }\n\n  /**\n   * æ¯”è¾ƒä¸¤ä¸ªæ–‡ä»¶æ˜¯å¦ç›¸åŒ\n   * @param file1 æ–‡ä»¶1\n   * @param file2 æ–‡ä»¶2\n   * @returns Promise<boolean>\n   */\n  static async compareFiles(file1: File, file2: File): Promise<boolean> {\n    if (file1.size !== file2.size) {\n      return false;\n    }\n    \n    if (file1.name === file2.name && file1.lastModified === file2.lastModified) {\n      return true;\n    }\n    \n    try {\n      const [hash1, hash2] = await Promise.all([\n        this.calculateSimpleHash(file1),\n        this.calculateSimpleHash(file2)\n      ]);\n      \n      return hash1 === hash2;\n    } catch (error) {\n      return false;\n    }\n  }\n\n  // === è·¯å¾„æ“ä½œå‡½æ•° ===\n\n  /**\n   * æ‹¼æ¥è·¯å¾„\n   * @param paths è·¯å¾„ç‰‡æ®µ\n   * @returns æ‹¼æ¥åçš„è·¯å¾„\n   */\n  static joinPath(...paths: string[]): string {\n    return paths\n      .filter(path => path && path.length > 0)\n      .map(path => path.replace(/[\\/\\\\]+/g, '/'))\n      .join('/')\n      .replace(/\\/+/g, '/')\n      .replace(/\\/$/, '') || '/';\n  }\n\n  /**\n   * è§£æè·¯å¾„\n   * @param path è·¯å¾„å­—ç¬¦ä¸²\n   * @returns è§£æåçš„è·¯å¾„ä¿¡æ¯\n   */\n  static parsePath(path: string): { dir: string; name: string; ext: string; base: string } {\n    const normalizedPath = path.replace(/[\\\\]/g, '/');\n    const lastSlash = normalizedPath.lastIndexOf('/');\n    \n    const dir = lastSlash > 0 ? normalizedPath.substring(0, lastSlash) : '';\n    const fullName = lastSlash >= 0 ? normalizedPath.substring(lastSlash + 1) : normalizedPath;\n    \n    const lastDot = fullName.lastIndexOf('.');\n    const name = lastDot > 0 ? fullName.substring(0, lastDot) : fullName;\n    const ext = lastDot > 0 ? fullName.substring(lastDot + 1) : '';\n    \n    return {\n      dir,\n      name,\n      ext,\n      base: fullName\n    };\n  }\n\n  // === æ–‡ä»¶ç±»å‹æ£€æµ‹å‡½æ•° ===\n\n  /**\n   * æ£€æµ‹æ˜¯å¦ä¸ºæ–‡æœ¬æ–‡ä»¶\n   * @param filename æ–‡ä»¶å\n   * @returns boolean\n   */\n  static isTextFile(filename: string): boolean {\n    const textExtensions = [\n      'txt', 'md', 'json', 'xml', 'html', 'css', 'js', 'ts', 'jsx', 'tsx',\n      'py', 'java', 'cpp', 'c', 'h', 'cs', 'php', 'rb', 'go', 'rs', 'sh',\n      'yml', 'yaml', 'toml', 'ini', 'cfg', 'conf', 'log', 'sql', 'csv'\n    ];\n    const ext = this.getFileExtension(filename);\n    return textExtensions.includes(ext);\n  }\n\n  /**\n   * æ£€æµ‹æ˜¯å¦ä¸ºå›¾ç‰‡æ–‡ä»¶\n   * @param filename æ–‡ä»¶å\n   * @returns boolean\n   */\n  static isImageFile(filename: string): boolean {\n    const imageExtensions = [\n      'jpg', 'jpeg', 'png', 'gif', 'bmp', 'webp', 'svg', 'ico',\n      'tiff', 'tif', 'psd', 'raw', 'heic', 'heif'\n    ];\n    const ext = this.getFileExtension(filename);\n    return imageExtensions.includes(ext);\n  }\n\n  /**\n   * æ£€æµ‹æ˜¯å¦ä¸ºè§†é¢‘æ–‡ä»¶\n   * @param filename æ–‡ä»¶å\n   * @returns boolean\n   */\n  static isVideoFile(filename: string): boolean {\n    const videoExtensions = [\n      'mp4', 'avi', 'mkv', 'mov', 'wmv', 'flv', 'webm', 'm4v',\n      '3gp', 'ogv', 'ts', 'm2ts', 'mts', 'vob', 'rm', 'rmvb'\n    ];\n    const ext = this.getFileExtension(filename);\n    return videoExtensions.includes(ext);\n  }\n\n  /**\n   * æ£€æµ‹æ˜¯å¦ä¸ºéŸ³é¢‘æ–‡ä»¶\n   * @param filename æ–‡ä»¶å\n   * @returns boolean\n   */\n  static isAudioFile(filename: string): boolean {\n    const audioExtensions = [\n      'mp3', 'wav', 'flac', 'aac', 'ogg', 'wma', 'm4a', 'opus',\n      'ape', 'ac3', 'dts', 'amr', 'au', 'ra', 'aiff'\n    ];\n    const ext = this.getFileExtension(filename);\n    return audioExtensions.includes(ext);\n  }\n}","usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/src/utils/format-detector.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/src/utils/memory-manager.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":111,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":111,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2431,2434],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2431,2434],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":112,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":112,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2507,2510],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2507,2510],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":140,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":140,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2952,2955],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2952,2955],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":141,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":141,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2996,2999],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2996,2999],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":367,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":367,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7644,7647],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7644,7647],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":370,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":370,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7730,7733],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7730,7733],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":372,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":372,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7815,7818],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7815,7818],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":374,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":374,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7894,7897],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7894,7897],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * å†…å­˜ç®¡ç†å·¥å…·\n * ç›‘æ§å’Œç®¡ç†åº”ç”¨ç¨‹åºçš„å†…å­˜ä½¿ç”¨æƒ…å†µ\n */\n\nexport interface MemoryInfo {\n  used: number;\n  total: number;\n  limit: number;\n  available: number;\n}\n\nexport interface MemoryAllocation {\n  id: string;\n  size: number;\n  timestamp: number;\n  description?: string;\n  priority?: string;\n}\n\nexport class MemoryManager {\n  private allocations = new Map<string, MemoryAllocation>();\n  private memoryLimit: number;\n  private gcThreshold: number;\n  private checkInterval: number = 5000; // 5ç§’æ£€æŸ¥ä¸€æ¬¡\n  private intervalId?: NodeJS.Timeout;\n  private onMemoryWarning?: (info: MemoryInfo) => void;\n  private onMemoryError?: (error: Error) => void;\n\n  constructor(\n    memoryLimit: number = 2 * 1024 * 1024 * 1024, // 2GBé»˜è®¤é™åˆ¶\n    gcThreshold: number = 0.8 // 80%æ—¶è§¦å‘GC\n  ) {\n    this.memoryLimit = memoryLimit;\n    this.gcThreshold = gcThreshold;\n    this.startMonitoring();\n  }\n\n  /**\n   * åˆ†é…å†…å­˜å—\n   * @param size å†…å­˜å¤§å°ï¼ˆå­—èŠ‚ï¼‰\n   * @param priority ä¼˜å…ˆçº§\n   * @param description å†…å­˜ç”¨é€”æè¿°\n   * @returns åˆ†é…ID\n   */\n  async allocate(size: number, priority?: string, description?: string): Promise<string> {\n    const id = this.generateId();\n    \n    // æ£€æŸ¥å†…å­˜é™åˆ¶\n    const currentUsage = this.getCurrentUsage();\n    if (currentUsage + size > this.memoryLimit) {\n      // å°è¯•å¼ºåˆ¶åƒåœ¾å›æ”¶\n      await this.forceGC();\n      \n      const newUsage = this.getCurrentUsage();\n      if (newUsage + size > this.memoryLimit) {\n        throw new Error(`Memory allocation failed: would exceed limit (${this.formatBytes(size)} requested, ${this.formatBytes(this.memoryLimit - newUsage)} available)`);\n      }\n    }\n\n    const allocation: MemoryAllocation = {\n      id,\n      size,\n      timestamp: Date.now(),\n      description,\n      priority\n    };\n\n    this.allocations.set(id, allocation);\n    return id;\n  }\n\n  /**\n   * é‡Šæ”¾å†…å­˜å—\n   * @param id åˆ†é…ID\n   */\n  free(id: string): void {\n    this.allocations.delete(id);\n  }\n\n  /**\n   * é‡Šæ”¾æ‰€æœ‰å†…å­˜å—\n   */\n  freeAll(): void {\n    this.allocations.clear();\n  }\n\n  /**\n   * è·å–å½“å‰å†…å­˜ä½¿ç”¨æƒ…å†µ\n   * @returns å†…å­˜ä½¿ç”¨å­—èŠ‚æ•°\n   */\n  getCurrentUsage(): number {\n    let total = 0;\n    for (const allocation of this.allocations.values()) {\n      total += allocation.size;\n    }\n    return total;\n  }\n\n  /**\n   * è·å–è¯¦ç»†å†…å­˜ä¿¡æ¯\n   * @returns å†…å­˜ä¿¡æ¯å¯¹è±¡\n   */\n  getMemoryInfo(): MemoryInfo {\n    const used = this.getCurrentUsage();\n    const limit = this.memoryLimit;\n    const available = limit - used;\n    \n    // å°è¯•è·å–å®é™…ç³»ç»Ÿå†…å­˜ä¿¡æ¯\n    let total = limit;\n    if (typeof (performance as any)?.memory?.totalJSHeapSize === 'number') {\n      total = (performance as any).memory.totalJSHeapSize;\n    }\n\n    return {\n      used,\n      total,\n      limit,\n      available\n    };\n  }\n\n  /**\n   * è·å–å†…å­˜ä½¿ç”¨ç™¾åˆ†æ¯”\n   * @returns ä½¿ç”¨ç™¾åˆ†æ¯” (0-1)\n   */\n  getUsagePercentage(): number {\n    const used = this.getCurrentUsage();\n    return used / this.memoryLimit;\n  }\n\n  /**\n   * å¼ºåˆ¶åƒåœ¾å›æ”¶\n   */\n  async forceGC(): Promise<void> {\n    // æ¸…ç†è¿‡æœŸçš„åˆ†é…è®°å½•\n    this.cleanupExpiredAllocations();\n\n    // å¦‚æœç¯å¢ƒæ”¯æŒï¼Œè§¦å‘åƒåœ¾å›æ”¶\n    if (typeof (global as any)?.gc === 'function') {\n      (global as any).gc();\n    }\n\n    // ç­‰å¾…ä¸€å°æ®µæ—¶é—´è®©GCå®Œæˆ\n    await new Promise(resolve => setTimeout(resolve, 100));\n  }\n\n  /**\n   * æ¸…ç†è¿‡æœŸçš„å†…å­˜åˆ†é…è®°å½•\n   * @param maxAge æœ€å¤§å­˜æ´»æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰ï¼Œé»˜è®¤1å°æ—¶\n   */\n  cleanupExpiredAllocations(maxAge: number = 3600000): void {\n    const now = Date.now();\n    const expired: string[] = [];\n\n    for (const [id, allocation] of this.allocations.entries()) {\n      if (now - allocation.timestamp > maxAge) {\n        expired.push(id);\n      }\n    }\n\n    expired.forEach(id => this.free(id));\n  }\n\n  /**\n   * è·å–æ‰€æœ‰å†…å­˜åˆ†é…è®°å½•\n   * @returns åˆ†é…è®°å½•æ•°ç»„\n   */\n  getAllocations(): MemoryAllocation[] {\n    return Array.from(this.allocations.values());\n  }\n\n  /**\n   * è·å–æŒ‰å¤§å°æ’åºçš„åˆ†é…è®°å½•\n   * @param descending æ˜¯å¦é™åºæ’åˆ—\n   * @returns æ’åºåçš„åˆ†é…è®°å½•\n   */\n  getAllocationsBySize(descending: boolean = true): MemoryAllocation[] {\n    const allocations = this.getAllocations();\n    return allocations.sort((a, b) => \n      descending ? b.size - a.size : a.size - b.size\n    );\n  }\n\n  /**\n   * è®¾ç½®å†…å­˜è­¦å‘Šå›è°ƒ\n   * @param callback è­¦å‘Šå›è°ƒå‡½æ•°\n   */\n  onWarning(callback: (info: MemoryInfo) => void): void {\n    this.onMemoryWarning = callback;\n  }\n\n  /**\n   * è®¾ç½®å†…å­˜é”™è¯¯å›è°ƒ\n   * @param callback é”™è¯¯å›è°ƒå‡½æ•°\n   */\n  onError(callback: (error: Error) => void): void {\n    this.onMemoryError = callback;\n  }\n\n  /**\n   * å¼€å§‹å†…å­˜ç›‘æ§\n   */\n  private startMonitoring(): void {\n    if (this.intervalId) {return;}\n\n    this.intervalId = setInterval(() => {\n      this.checkMemoryUsage();\n    }, this.checkInterval);\n  }\n\n  /**\n   * åœæ­¢å†…å­˜ç›‘æ§\n   */\n  stopMonitoring(): void {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n      this.intervalId = undefined;\n    }\n  }\n\n  /**\n   * æ£€æŸ¥å†…å­˜ä½¿ç”¨æƒ…å†µ\n   */\n  private checkMemoryUsage(): void {\n    try {\n      const usage = this.getUsagePercentage();\n      const info = this.getMemoryInfo();\n\n      // è¶…è¿‡é˜ˆå€¼æ—¶å‘å‡ºè­¦å‘Š\n      if (usage > this.gcThreshold && this.onMemoryWarning) {\n        this.onMemoryWarning(info);\n      }\n\n      // æ¥è¿‘é™åˆ¶æ—¶è‡ªåŠ¨æ¸…ç†\n      if (usage > 0.9) {\n        this.cleanupExpiredAllocations();\n      }\n    } catch (error) {\n      if (this.onMemoryError) {\n        this.onMemoryError(error instanceof Error ? error : new Error(String(error)));\n      }\n    }\n  }\n\n  /**\n   * ç”Ÿæˆå”¯ä¸€ID\n   * @returns å”¯ä¸€æ ‡è¯†ç¬¦\n   */\n  private generateId(): string {\n    return `mem_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  /**\n   * æ ¼å¼åŒ–å­—èŠ‚æ•°ä¸ºå¯è¯»å­—ç¬¦ä¸²\n   * @param bytes å­—èŠ‚æ•°\n   * @returns æ ¼å¼åŒ–å­—ç¬¦ä¸²\n   */\n  private formatBytes(bytes: number): string {\n    const units = ['B', 'KB', 'MB', 'GB'];\n    let size = bytes;\n    let unitIndex = 0;\n\n    while (size >= 1024 && unitIndex < units.length - 1) {\n      size /= 1024;\n      unitIndex++;\n    }\n\n    return `${size.toFixed(2)} ${units[unitIndex]}`;\n  }\n\n  /**\n   * é”€æ¯å†…å­˜ç®¡ç†å™¨\n   */\n  destroy(): void {\n    this.stopMonitoring();\n    this.freeAll();\n    this.onMemoryWarning = undefined;\n    this.onMemoryError = undefined;\n  }\n\n  /**\n   * è·å–å†…å­˜ç»Ÿè®¡ä¿¡æ¯\n   * @returns ç»Ÿè®¡ä¿¡æ¯å¯¹è±¡\n   */\n  getStats(): {\n    totalAllocations: number;\n    currentUsage: string;\n    memoryLimit: string;\n    usagePercentage: string;\n    largestAllocation: string;\n    oldestAllocation: number | null;\n  } {\n    const allocations = this.getAllocations();\n    const usage = this.getCurrentUsage();\n    const largest = allocations.length > 0 \n      ? Math.max(...allocations.map(a => a.size))\n      : 0;\n    const oldest = allocations.length > 0\n      ? Math.min(...allocations.map(a => a.timestamp))\n      : null;\n\n    return {\n      totalAllocations: allocations.length,\n      currentUsage: this.formatBytes(usage),\n      memoryLimit: this.formatBytes(this.memoryLimit),\n      usagePercentage: `${(this.getUsagePercentage() * 100).toFixed(2)}%`,\n      largestAllocation: this.formatBytes(largest),\n      oldestAllocation: oldest\n    };\n  }\n\n  /**\n   * è·å–æœ€å¤§å†…å­˜é™åˆ¶\n   * @returns æœ€å¤§å†…å­˜é™åˆ¶\n   */\n  getMaxMemory(): number {\n    return this.memoryLimit;\n  }\n\n  /**\n   * è·å–å†…å­˜ä½¿ç”¨ç»Ÿè®¡\n   * @returns ç»Ÿè®¡ä¿¡æ¯\n   */\n  getUsageStats(): {\n    used: number;\n    total: number;\n    free: number;\n    usage: number;\n  } {\n    const used = this.getCurrentUsage();\n    const total = this.memoryLimit;\n    return {\n      used,\n      total,\n      free: total - used,\n      usage: used / total\n    };\n  }\n\n  /**\n   * æ›´æ–°è®¿é—®æ—¶é—´ï¼ˆç”¨äºLRUï¼‰\n   * @param id åˆ†é…ID\n   */\n  updateAccess(id: string): void {\n    const allocation = this.allocations.get(id);\n    if (allocation) {\n      allocation.timestamp = Date.now();\n    }\n  }\n\n  /**\n   * æ‰¹é‡é‡Šæ”¾å†…å­˜\n   * @param ids åˆ†é…IDæ•°ç»„\n   */\n  freeMultiple(ids: string[]): void {\n    for (const id of ids) {\n      this.free(id);\n    }\n  }\n\n  /**\n   * äº‹ä»¶ç›‘å¬å™¨ï¼ˆç®€åŒ–ç‰ˆEventEmitterï¼‰\n   * @param event äº‹ä»¶å\n   * @param callback å›è°ƒå‡½æ•°\n   */\n  on(event: string, callback: (...args: any[]) => void): void {\n    // ç®€åŒ–çš„äº‹ä»¶ç³»ç»Ÿ\n    if (event === 'allocate') {\n      (this as any)._allocateCallback = callback;\n    } else if (event === 'free') {\n      (this as any)._freeCallback = callback;\n    } else if (event === 'gc') {\n      (this as any)._gcCallback = callback;\n    }\n  }\n}","usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/tests/e2e/complete-user-journey.spec.ts","messages":[{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":253,"column":30,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":253,"endColumn":43}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { test, expect, Page, BrowserContext } from '@playwright/test';\nimport path from 'path';\n\ntest.describe('ZhugeExtract - å®Œæ•´ç”¨æˆ·æ—…ç¨‹', () => {\n  let page: Page;\n  let context: BrowserContext;\n\n  test.beforeEach(async ({ browser }) => {\n    context = await browser.newContext({\n      // å¯ç”¨æƒé™\n      permissions: ['clipboard-read', 'clipboard-write'],\n      // è®¾ç½®è§†å£\n      viewport: { width: 1280, height: 720 }\n    });\n    page = await context.newPage();\n    \n    // å¯¼èˆªåˆ°åº”ç”¨\n    await page.goto('/');\n    await expect(page).toHaveTitle(/ZhugeExtract/);\n  });\n\n  test.afterEach(async () => {\n    await context.close();\n  });\n\n  test('ç”¨æˆ·å®Œæ•´è§£å‹å’Œé¢„è§ˆæµç¨‹', async () => {\n    // æ­¥éª¤1: éªŒè¯åˆå§‹é¡µé¢çŠ¶æ€\n    await expect(page.getByTestId('file-upload-zone')).toBeVisible();\n    await expect(page.getByText('æ‹–æ‹½æ–‡ä»¶åˆ°æ­¤å¤„')).toBeVisible();\n    await expect(page.getByText('æ”¯æŒæ ¼å¼')).toBeVisible();\n\n    // æ­¥éª¤2: ä¸Šä¼ ZIPæ–‡ä»¶\n    const zipFilePath = path.join(__dirname, '../fixtures/archives/sample.zip');\n    \n    await page.setInputFiles('input[type=\"file\"]', zipFilePath);\n    \n    // éªŒè¯ä¸Šä¼ æˆåŠŸæç¤º\n    await expect(page.getByText('æ–‡ä»¶ä¸Šä¼ æˆåŠŸ')).toBeVisible({ timeout: 5000 });\n\n    // æ­¥éª¤3: ç­‰å¾…è§£å‹å®Œæˆ\n    await expect(page.getByTestId('file-tree')).toBeVisible({ timeout: 10000 });\n    await expect(page.getByTestId('loading-spinner')).not.toBeVisible();\n\n    // éªŒè¯è§£å‹ç»“æœ\n    await expect(page.getByText('è§£å‹å®Œæˆ')).toBeVisible();\n    await expect(page.getByTestId('file-count')).toContainText('5 ä¸ªæ–‡ä»¶');\n\n    // æ­¥éª¤4: éªŒè¯æ–‡ä»¶æ ‘ç»“æ„\n    const fileTree = page.getByTestId('file-tree');\n    await expect(fileTree.getByText('readme.txt')).toBeVisible();\n    await expect(fileTree.getByText('images')).toBeVisible();\n    await expect(fileTree.getByText('documents')).toBeVisible();\n\n    // å±•å¼€æ–‡ä»¶å¤¹\n    await fileTree.getByText('images').click();\n    await expect(fileTree.getByText('photo1.jpg')).toBeVisible();\n    await expect(fileTree.getByText('photo2.png')).toBeVisible();\n\n    // æ­¥éª¤5: é¢„è§ˆæ–‡æœ¬æ–‡ä»¶\n    await fileTree.getByText('readme.txt').click();\n    \n    await expect(page.getByTestId('preview-panel')).toBeVisible();\n    await expect(page.getByTestId('preview-content')).toBeVisible();\n    await expect(page.getByText('è¿™æ˜¯ä¸€ä¸ªæµ‹è¯•æ–‡ä»¶')).toBeVisible();\n    \n    // éªŒè¯é¢„è§ˆå…ƒæ•°æ®\n    const metadataPanel = page.getByTestId('file-metadata');\n    await expect(metadataPanel.getByText('æ–‡ä»¶å¤§å°: 48 B')).toBeVisible();\n    await expect(metadataPanel.getByText('ç±»å‹: æ–‡æœ¬æ–‡ä»¶')).toBeVisible();\n\n    // æ­¥éª¤6: é¢„è§ˆå›¾ç‰‡æ–‡ä»¶\n    await fileTree.getByText('photo1.jpg').click();\n    \n    await expect(page.getByTestId('image-preview')).toBeVisible();\n    const image = page.getByTestId('preview-image');\n    await expect(image).toBeVisible();\n    await expect(image).toHaveAttribute('src', /^data:image/);\n\n    // éªŒè¯å›¾ç‰‡æ§åˆ¶æŒ‰é’®\n    await expect(page.getByTestId('zoom-in-button')).toBeVisible();\n    await expect(page.getByTestId('zoom-out-button')).toBeVisible();\n    await expect(page.getByTestId('rotate-button')).toBeVisible();\n\n    // æ­¥éª¤7: æµ‹è¯•å›¾ç‰‡ç¼©æ”¾åŠŸèƒ½\n    await page.getByTestId('zoom-in-button').click();\n    await expect(image).toHaveClass(/zoomed-in/);\n    \n    await page.getByTestId('zoom-out-button').click();\n    await expect(image).not.toHaveClass(/zoomed-in/);\n\n    // æ­¥éª¤8: ä¸‹è½½å•ä¸ªæ–‡ä»¶\n    const downloadPromise = page.waitForEvent('download');\n    await page.getByTestId('download-file-button').click();\n    \n    const download = await downloadPromise;\n    expect(download.suggestedFilename()).toBe('photo1.jpg');\n\n    // æ­¥éª¤9: æ‰¹é‡é€‰æ‹©å’Œä¸‹è½½\n    await fileTree.getByTestId('select-checkbox-readme.txt').check();\n    await fileTree.getByTestId('select-checkbox-photo1.jpg').check();\n    \n    await expect(page.getByTestId('selected-count')).toContainText('å·²é€‰æ‹© 2 ä¸ªæ–‡ä»¶');\n    \n    const batchDownloadPromise = page.waitForEvent('download');\n    await page.getByTestId('download-selected-button').click();\n    \n    const batchDownload = await batchDownloadPromise;\n    expect(batchDownload.suggestedFilename()).toMatch(/selected_files.*\\.zip/);\n\n    // æ­¥éª¤10: æœç´¢æ–‡ä»¶\n    const searchInput = page.getByTestId('file-search-input');\n    await searchInput.fill('photo');\n    \n    await expect(fileTree.getByText('photo1.jpg')).toBeVisible();\n    await expect(fileTree.getByText('photo2.png')).toBeVisible();\n    await expect(fileTree.getByText('readme.txt')).not.toBeVisible();\n\n    // æ¸…é™¤æœç´¢\n    await searchInput.clear();\n    await expect(fileTree.getByText('readme.txt')).toBeVisible();\n\n    // æ­¥éª¤11: åˆ‡æ¢æ˜¾ç¤ºæ¨¡å¼\n    await page.getByTestId('view-mode-list').click();\n    await expect(fileTree).toHaveClass(/list-view/);\n    \n    await page.getByTestId('view-mode-grid').click();\n    await expect(fileTree).toHaveClass(/grid-view/);\n\n    // æ­¥éª¤12: éªŒè¯åº”ç”¨çŠ¶æ€æŒä¹…åŒ–\n    await page.reload();\n    \n    // éªŒè¯æ–‡ä»¶ä»ç„¶åŠ è½½\n    await expect(page.getByTestId('file-tree')).toBeVisible({ timeout: 5000 });\n    await expect(page.getByText('readme.txt')).toBeVisible();\n  });\n\n  test('RARæ–‡ä»¶å¤„ç†æµç¨‹', async () => {\n    const rarFilePath = path.join(__dirname, '../fixtures/archives/sample.rar');\n    \n    await page.setInputFiles('input[type=\"file\"]', rarFilePath);\n    \n    // ç­‰å¾…RARè§£å‹å®Œæˆï¼ˆå¯èƒ½éœ€è¦æ›´å¤šæ—¶é—´ï¼‰\n    await expect(page.getByTestId('file-tree')).toBeVisible({ timeout: 15000 });\n    \n    // éªŒè¯RARç‰¹æœ‰çš„æ–‡ä»¶ç»“æ„\n    const fileTree = page.getByTestId('file-tree');\n    await expect(fileTree.getByText('compressed_data.bin')).toBeVisible();\n    \n    // éªŒè¯å‹ç¼©ä¿¡æ¯æ˜¾ç¤º\n    const compressionInfo = page.getByTestId('compression-info');\n    await expect(compressionInfo.getByText('æ ¼å¼: RAR')).toBeVisible();\n    await expect(compressionInfo.getByText(/å‹ç¼©æ¯”:/)).toBeVisible();\n  });\n\n  test('å¯†ç ä¿æŠ¤æ–‡ä»¶å¤„ç†', async () => {\n    const protectedZipPath = path.join(__dirname, '../fixtures/archives/protected.zip');\n    \n    await page.setInputFiles('input[type=\"file\"]', protectedZipPath);\n    \n    // åº”è¯¥å‡ºç°å¯†ç è¾“å…¥å¯¹è¯æ¡†\n    await expect(page.getByTestId('password-dialog')).toBeVisible({ timeout: 5000 });\n    await expect(page.getByText('æ­¤æ–‡ä»¶éœ€è¦å¯†ç ')).toBeVisible();\n    \n    // è¾“å…¥é”™è¯¯å¯†ç \n    await page.getByTestId('password-input').fill('wrongpassword');\n    await page.getByTestId('password-submit').click();\n    \n    // éªŒè¯é”™è¯¯æç¤º\n    await expect(page.getByText('å¯†ç é”™è¯¯')).toBeVisible();\n    \n    // è¾“å…¥æ­£ç¡®å¯†ç \n    await page.getByTestId('password-input').clear();\n    await page.getByTestId('password-input').fill('test123');\n    await page.getByTestId('password-submit').click();\n    \n    // éªŒè¯è§£å‹æˆåŠŸ\n    await expect(page.getByTestId('file-tree')).toBeVisible({ timeout: 10000 });\n    await expect(page.getByText('protected_file.txt')).toBeVisible();\n  });\n\n  test('é”™è¯¯å¤„ç†å’Œæ¢å¤', async () => {\n    // æµ‹è¯•æ— æ•ˆæ–‡ä»¶ä¸Šä¼ \n    const invalidFilePath = path.join(__dirname, '../fixtures/files/invalid.txt');\n    \n    await page.setInputFiles('input[type=\"file\"]', invalidFilePath);\n    \n    // éªŒè¯é”™è¯¯ä¿¡æ¯\n    await expect(page.getByTestId('error-message')).toBeVisible();\n    await expect(page.getByText('ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼')).toBeVisible();\n    \n    // ç‚¹å‡»æ¸…é™¤é”™è¯¯\n    await page.getByTestId('clear-error-button').click();\n    await expect(page.getByTestId('error-message')).not.toBeVisible();\n    \n    // æµ‹è¯•æŸåçš„å‹ç¼©æ–‡ä»¶\n    const corruptedZipPath = path.join(__dirname, '../fixtures/archives/corrupted.zip');\n    \n    await page.setInputFiles('input[type=\"file\"]', corruptedZipPath);\n    \n    // éªŒè¯é”™è¯¯å¤„ç†\n    await expect(page.getByTestId('error-message')).toBeVisible({ timeout: 10000 });\n    await expect(page.getByText(/æ–‡ä»¶æŸå/)).toBeVisible();\n    \n    // éªŒè¯é‡è¯•æŒ‰é’®\n    await expect(page.getByTestId('retry-button')).toBeVisible();\n  });\n\n  test('å¤§æ–‡ä»¶å¤„ç†å’Œæ€§èƒ½', async () => {\n    const largeZipPath = path.join(__dirname, '../fixtures/archives/large_50mb.zip');\n    \n    await page.setInputFiles('input[type=\"file\"]', largeZipPath);\n    \n    // éªŒè¯è¿›åº¦æŒ‡ç¤ºå™¨\n    await expect(page.getByTestId('progress-bar')).toBeVisible();\n    await expect(page.getByTestId('progress-text')).toBeVisible();\n    \n    // ç›‘æ§è¿›åº¦æ›´æ–°\n    const progressValues: string[] = [];\n    page.on('console', msg => {\n      if (msg.text().includes('Progress:')) {\n        progressValues.push(msg.text());\n      }\n    });\n    \n    // ç­‰å¾…è§£å‹å®Œæˆ\n    await expect(page.getByTestId('file-tree')).toBeVisible({ timeout: 30000 });\n    \n    // éªŒè¯å¤§é‡æ–‡ä»¶çš„è™šæ‹Ÿæ»šåŠ¨\n    const fileTree = page.getByTestId('file-tree');\n    await expect(fileTree).toHaveClass(/virtual-scroll/);\n    \n    // éªŒè¯æ–‡ä»¶æ•°é‡\n    const fileCount = page.getByTestId('file-count');\n    await expect(fileCount).toContainText(/\\d+ ä¸ªæ–‡ä»¶/);\n    \n    // æµ‹è¯•è™šæ‹Ÿæ»šåŠ¨æ€§èƒ½\n    const scrollContainer = page.getByTestId('virtual-scroll-container');\n    await scrollContainer.evaluate(element => {\n      element.scrollTop = element.scrollHeight / 2;\n    });\n    \n    // éªŒè¯æ»šåŠ¨åçš„æ¸²æŸ“æ€§èƒ½\n    await expect(page.getByTestId('file-item').first()).toBeVisible();\n  });\n\n  test('æ‹–æ‹½ä¸Šä¼ åŠŸèƒ½', async () => {\n    const zipFilePath = path.join(__dirname, '../fixtures/archives/drag_test.zip');\n    \n    // æ¨¡æ‹Ÿæ–‡ä»¶æ‹–æ‹½\n    const dropZone = page.getByTestId('file-upload-zone');\n    \n    // åˆ›å»ºæ–‡ä»¶å¯¹è±¡å¹¶æ‹–æ‹½\n    const fileBuffer = await require('fs').promises.readFile(zipFilePath);\n    const dataTransfer = await page.evaluateHandle((data) => {\n      const dt = new DataTransfer();\n      const file = new File([new Uint8Array(data)], 'drag_test.zip', {\n        type: 'application/zip'\n      });\n      dt.items.add(file);\n      return dt;\n    }, Array.from(fileBuffer));\n    \n    await dropZone.dispatchEvent('drop', { dataTransfer });\n    \n    // éªŒè¯æ‹–æ‹½ä¸Šä¼ æˆåŠŸ\n    await expect(page.getByTestId('file-tree')).toBeVisible({ timeout: 10000 });\n    await expect(page.getByText('dragged_file.txt')).toBeVisible();\n  });\n\n  test('é”®ç›˜å¯¼èˆªå’Œæ— éšœç¢åŠŸèƒ½', async () => {\n    const zipFilePath = path.join(__dirname, '../fixtures/archives/sample.zip');\n    await page.setInputFiles('input[type=\"file\"]', zipFilePath);\n    await expect(page.getByTestId('file-tree')).toBeVisible({ timeout: 10000 });\n    \n    // æµ‹è¯•Tabé”®å¯¼èˆª\n    await page.keyboard.press('Tab');\n    await expect(page.getByTestId('file-tree')).toBeFocused();\n    \n    // ä½¿ç”¨æ–¹å‘é”®å¯¼èˆªæ–‡ä»¶\n    await page.keyboard.press('ArrowDown');\n    await page.keyboard.press('ArrowDown');\n    await page.keyboard.press('Enter'); // é€‰æ‹©æ–‡ä»¶\n    \n    // éªŒè¯æ–‡ä»¶è¢«é€‰ä¸­å’Œé¢„è§ˆ\n    await expect(page.getByTestId('preview-panel')).toBeVisible();\n    \n    // æµ‹è¯•å¿«æ·é”®\n    await page.keyboard.press('Control+A'); // å…¨é€‰\n    await expect(page.getByTestId('selected-count')).toContainText('å·²é€‰æ‹©');\n    \n    await page.keyboard.press('Escape'); // å–æ¶ˆé€‰æ‹©\n    await expect(page.getByTestId('selected-count')).not.toBeVisible();\n    \n    // éªŒè¯ARIAæ ‡ç­¾\n    const fileTree = page.getByTestId('file-tree');\n    await expect(fileTree).toHaveAttribute('role', 'tree');\n    \n    const fileItems = page.getByTestId('file-item');\n    await expect(fileItems.first()).toHaveAttribute('role', 'treeitem');\n  });\n\n  test('å“åº”å¼è®¾è®¡ - ç§»åŠ¨ç«¯ä½“éªŒ', async () => {\n    // åˆ‡æ¢åˆ°ç§»åŠ¨ç«¯è§†å£\n    await page.setViewportSize({ width: 375, height: 667 });\n    \n    const zipFilePath = path.join(__dirname, '../fixtures/archives/sample.zip');\n    await page.setInputFiles('input[type=\"file\"]', zipFilePath);\n    await expect(page.getByTestId('file-tree')).toBeVisible({ timeout: 10000 });\n    \n    // éªŒè¯ç§»åŠ¨ç«¯å¸ƒå±€\n    const container = page.getByTestId('main-container');\n    await expect(container).toHaveClass(/mobile-layout/);\n    \n    // éªŒè¯Tabåˆ‡æ¢\n    const tabButtons = page.getByTestId('tab-button');\n    await expect(tabButtons).toHaveCount(2); // æ–‡ä»¶åˆ—è¡¨å’Œé¢„è§ˆä¸¤ä¸ªTab\n    \n    // åˆ‡æ¢åˆ°é¢„è§ˆTab\n    await tabButtons.last().click();\n    await expect(page.getByTestId('preview-panel')).toBeVisible();\n    \n    // éªŒè¯è§¦æ‘¸æ‰‹åŠ¿ï¼ˆå¦‚æœæ”¯æŒï¼‰\n    const fileTree = page.getByTestId('file-tree');\n    await fileTree.locator('text=readme.txt').tap();\n    await expect(page.getByTestId('preview-content')).toBeVisible();\n    \n    // éªŒè¯ç§»åŠ¨ç«¯èœå•\n    const mobileMenu = page.getByTestId('mobile-menu-button');\n    await expect(mobileMenu).toBeVisible();\n    \n    await mobileMenu.click();\n    await expect(page.getByTestId('mobile-menu')).toBeVisible();\n  });\n\n  test('å¤šè¯­è¨€æ”¯æŒ', async () => {\n    // åˆ‡æ¢åˆ°è‹±æ–‡\n    await page.getByTestId('language-selector').click();\n    await page.getByText('English').click();\n    \n    // éªŒè¯ç•Œé¢è¯­è¨€åˆ‡æ¢\n    await expect(page.getByText('Drag files here')).toBeVisible();\n    await expect(page.getByText('Supported formats')).toBeVisible();\n    \n    // ä¸Šä¼ æ–‡ä»¶å¹¶éªŒè¯è‹±æ–‡æç¤º\n    const zipFilePath = path.join(__dirname, '../fixtures/archives/sample.zip');\n    await page.setInputFiles('input[type=\"file\"]', zipFilePath);\n    \n    await expect(page.getByText('File uploaded successfully')).toBeVisible();\n    await expect(page.getByText('Extraction complete')).toBeVisible({ timeout: 10000 });\n    \n    // åˆ‡æ¢å›ä¸­æ–‡\n    await page.getByTestId('language-selector').click();\n    await page.getByText('ä¸­æ–‡').click();\n    \n    await expect(page.getByText('æ‹–æ‹½æ–‡ä»¶åˆ°æ­¤å¤„')).toBeVisible();\n  });\n\n  test('ä¸»é¢˜åˆ‡æ¢åŠŸèƒ½', async () => {\n    // éªŒè¯é»˜è®¤ä¸»é¢˜\n    const body = page.locator('body');\n    await expect(body).toHaveClass(/light-theme/);\n    \n    // åˆ‡æ¢åˆ°æš—è‰²ä¸»é¢˜\n    await page.getByTestId('theme-toggle').click();\n    await expect(body).toHaveClass(/dark-theme/);\n    \n    // éªŒè¯ä¸»é¢˜æŒä¹…åŒ–\n    await page.reload();\n    await expect(body).toHaveClass(/dark-theme/);\n    \n    // åˆ‡æ¢å›äº®è‰²ä¸»é¢˜\n    await page.getByTestId('theme-toggle').click();\n    await expect(body).toHaveClass(/light-theme/);\n  });\n\n  test('ç¦»çº¿åŠŸèƒ½æµ‹è¯•', async () => {\n    // é¦–å…ˆåœ¨çº¿åŠ è½½åº”ç”¨\n    const zipFilePath = path.join(__dirname, '../fixtures/archives/sample.zip');\n    await page.setInputFiles('input[type=\"file\"]', zipFilePath);\n    await expect(page.getByTestId('file-tree')).toBeVisible({ timeout: 10000 });\n    \n    // æ¨¡æ‹Ÿç¦»çº¿çŠ¶æ€\n    await context.setOffline(true);\n    \n    // åˆ·æ–°é¡µé¢ï¼ŒéªŒè¯ç¦»çº¿ç¼“å­˜\n    await page.reload();\n    await expect(page.getByTestId('file-upload-zone')).toBeVisible({ timeout: 5000 });\n    \n    // éªŒè¯ç¦»çº¿æç¤º\n    await expect(page.getByTestId('offline-indicator')).toBeVisible();\n    await expect(page.getByText('ç¦»çº¿æ¨¡å¼')).toBeVisible();\n    \n    // éªŒè¯åŸºç¡€åŠŸèƒ½ä»ç„¶å¯ç”¨\n    const offlineZipPath = path.join(__dirname, '../fixtures/archives/offline_test.zip');\n    await page.setInputFiles('input[type=\"file\"]', offlineZipPath);\n    await expect(page.getByTestId('file-tree')).toBeVisible({ timeout: 10000 });\n    \n    // æ¢å¤åœ¨çº¿çŠ¶æ€\n    await context.setOffline(false);\n    await expect(page.getByTestId('offline-indicator')).not.toBeVisible();\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/tests/e2e/cross-browser-compatibility.spec.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Expression expected.","line":137,"column":26,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { test, expect, devices } from '@playwright/test';\nimport path from 'path';\n\n// å®šä¹‰æµ‹è¯•è®¾å¤‡é…ç½®\nconst testDevices = [\n  { name: 'Desktop Chrome', ...devices['Desktop Chrome'] },\n  { name: 'Desktop Firefox', ...devices['Desktop Firefox'] },\n  { name: 'Desktop Safari', ...devices['Desktop Safari'] },\n  { name: 'Mobile Chrome', ...devices['Pixel 5'] },\n  { name: 'Mobile Safari', ...devices['iPhone 12'] },\n  { name: 'Tablet', ...devices['iPad Pro'] }\n];\n\nfor (const device of testDevices) {\n  test.describe(`${device.name} - è·¨æµè§ˆå™¨å…¼å®¹æ€§æµ‹è¯•`, () => {\n    test.use(device);\n\n    test('åŸºç¡€åŠŸèƒ½å…¼å®¹æ€§', async ({ page, browserName }) => {\n      await page.goto('/');\n      \n      // éªŒè¯é¡µé¢åŠ è½½\n      await expect(page).toHaveTitle(/ZhugeExtract/);\n      await expect(page.getByTestId('file-upload-zone')).toBeVisible();\n      \n      // æ£€æŸ¥WebAssemblyæ”¯æŒ\n      const wasmSupported = await page.evaluate(() => {\n        return typeof WebAssembly === 'object' && typeof WebAssembly.instantiate === 'function';\n      });\n      \n      if (!wasmSupported) {\n        console.warn(`WebAssembly not supported in ${browserName}`);\n        return; // è·³è¿‡åç»­æµ‹è¯•\n      }\n      \n      // ä¸Šä¼ æµ‹è¯•æ–‡ä»¶\n      const zipFilePath = path.join(__dirname, '../fixtures/archives/compatibility_test.zip');\n      await page.setInputFiles('input[type=\"file\"]', zipFilePath);\n      \n      // éªŒè¯è§£å‹åŠŸèƒ½\n      await expect(page.getByTestId('file-tree')).toBeVisible({ timeout: 15000 });\n      await expect(page.getByText('test_file.txt')).toBeVisible();\n      \n      // éªŒè¯é¢„è§ˆåŠŸèƒ½\n      await page.getByText('test_file.txt').click();\n      await expect(page.getByTestId('preview-content')).toBeVisible();\n    });\n\n    test('æ–‡ä»¶APIå…¼å®¹æ€§', async ({ page, browserName }) => {\n      await page.goto('/');\n      \n      // æ£€æŸ¥File APIæ”¯æŒ\n      const fileApiSupport = await page.evaluate(() => {\n        return {\n          fileReader: typeof FileReader !== 'undefined',\n          fileApi: typeof File !== 'undefined',\n          dragDrop: 'ondrop' in document.createElement('div'),\n          fileSystemAccess: 'showOpenFilePicker' in window\n        };\n      });\n      \n      console.log(`${browserName} API Support:`, fileApiSupport);\n      \n      // éªŒè¯åŸºç¡€æ–‡ä»¶æ“ä½œ\n      if (fileApiSupport.fileReader && fileApiSupport.fileApi) {\n        const zipFilePath = path.join(__dirname, '../fixtures/archives/api_test.zip');\n        await page.setInputFiles('input[type=\"file\"]', zipFilePath);\n        await expect(page.getByTestId('file-tree')).toBeVisible({ timeout: 10000 });\n      }\n      \n      // æµ‹è¯•æ‹–æ‹½åŠŸèƒ½ï¼ˆå¦‚æœæ”¯æŒï¼‰\n      if (fileApiSupport.dragDrop) {\n        const dropZone = page.getByTestId('file-upload-zone');\n        await expect(dropZone).toHaveAttribute('ondrop');\n      }\n      \n      // æµ‹è¯•FileSystem Access APIï¼ˆChromeä¸“ç”¨ï¼‰\n      if (fileApiSupport.fileSystemAccess) {\n        await expect(page.getByTestId('advanced-file-operations')).toBeVisible();\n      } else {\n        // éªŒè¯é™çº§æ–¹æ¡ˆ\n        await expect(page.getByTestId('fallback-file-operations')).toBeVisible();\n      }\n    });\n\n    test('CSSå’Œå¸ƒå±€å…¼å®¹æ€§', async ({ page, browserName, viewport }) => {\n      await page.goto('/');\n      \n      // æ£€æŸ¥CSS Gridå’ŒFlexboxæ”¯æŒ\n      const cssSupport = await page.evaluate(() => {\n        const testElement = document.createElement('div');\n        return {\n          grid: CSS.supports('display', 'grid'),\n          flexbox: CSS.supports('display', 'flex'),\n          customProperties: CSS.supports('color', 'var(--test)'),\n          aspectRatio: CSS.supports('aspect-ratio', '1/1')\n        };\n      });\n      \n      console.log(`${browserName} CSS Support:`, cssSupport);\n      \n      // éªŒè¯å“åº”å¼å¸ƒå±€\n      const container = page.getByTestId('main-container');\n      \n      if (viewport && viewport.width < 768) {\n        // ç§»åŠ¨ç«¯å¸ƒå±€\n        await expect(container).toHaveClass(/mobile-layout/);\n        await expect(page.getByTestId('mobile-menu-button')).toBeVisible();\n      } else {\n        // æ¡Œé¢ç«¯å¸ƒå±€\n        await expect(container).toHaveClass(/desktop-layout/);\n        await expect(page.getByTestId('sidebar')).toBeVisible();\n      }\n      \n      // éªŒè¯å…³é”®å…ƒç´ çš„å¯è§æ€§å’Œä½ç½®\n      await expect(page.getByTestId('file-upload-zone')).toBeVisible();\n      \n      const uploadZone = page.getByTestId('file-upload-zone');\n      const boundingBox = await uploadZone.boundingBox();\n      \n      expect(boundingBox).not.toBeNull();\n      expect(boundingBox!.width).toBeGreaterThan(200);\n      expect(boundingBox!.height).toBeGreaterThan(100);\n    });\n\n    test('JavaScriptå…¼å®¹æ€§', async ({ page, browserName }) => {\n      await page.goto('/');\n      \n      // æ£€æŸ¥ç°ä»£JavaScriptç‰¹æ€§æ”¯æŒ\n      const jsSupport = await page.evaluate(() => {\n        const testArray = [1, 2, 3];\n        return {\n          arrowFunctions: (() => true)(),\n          asyncAwait: typeof (async () => {})().then === 'function',\n          destructuring: (() => { const [a] = testArray; return a === 1; })(),\n          spread: [...testArray].length === 3,\n          promises: typeof Promise !== 'undefined',\n          modules: typeof import !== 'undefined',\n          classes: (() => { class Test {} return typeof Test === 'function'; })(),\n          mapSet: typeof Map !== 'undefined' && typeof Set !== 'undefined',\n          symbolIterator: typeof Symbol !== 'undefined' && typeof Symbol.iterator !== 'undefined'\n        };\n      });\n      \n      console.log(`${browserName} JS Features:`, jsSupport);\n      \n      // å¦‚æœä¸æ”¯æŒæŸäº›ç‰¹æ€§ï¼ŒéªŒè¯polyfillæ˜¯å¦æ­£å¸¸å·¥ä½œ\n      if (!jsSupport.promises) {\n        // éªŒè¯Promise polyfill\n        const promiseWorks = await page.evaluate(() => {\n          return new Promise(resolve => resolve(true));\n        });\n        expect(promiseWorks).toBe(true);\n      }\n      \n      // éªŒè¯é”™è¯¯å¤„ç†\n      const errorHandlerWorks = await page.evaluate(() => {\n        try {\n          throw new Error('Test error');\n        } catch (e) {\n          return e.message === 'Test error';\n        }\n      });\n      expect(errorHandlerWorks).toBe(true);\n    });\n\n    test('æ€§èƒ½åŸºå‡†æµ‹è¯•', async ({ page, browserName }) => {\n      await page.goto('/');\n      \n      // æµ‹è¯•é¡µé¢åŠ è½½æ€§èƒ½\n      const navigationTiming = await page.evaluate(() => {\n        const timing = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming;\n        return {\n          domContentLoaded: timing.domContentLoadedEventEnd - timing.domContentLoadedEventStart,\n          loadComplete: timing.loadEventEnd - timing.loadEventStart,\n          firstPaint: performance.getEntriesByName('first-paint')[0]?.startTime || 0,\n          firstContentfulPaint: performance.getEntriesByName('first-contentful-paint')[0]?.startTime || 0\n        };\n      });\n      \n      console.log(`${browserName} Performance:`, navigationTiming);\n      \n      // éªŒè¯æ€§èƒ½æŒ‡æ ‡åœ¨åˆç†èŒƒå›´å†…\n      expect(navigationTiming.domContentLoaded).toBeLessThan(3000); // 3ç§’å†…\n      expect(navigationTiming.loadComplete).toBeLessThan(5000); // 5ç§’å†…\n      \n      // æµ‹è¯•æ–‡ä»¶å¤„ç†æ€§èƒ½\n      const smallZipPath = path.join(__dirname, '../fixtures/archives/small_1mb.zip');\n      await page.setInputFiles('input[type=\"file\"]', smallZipPath);\n      \n      const startTime = Date.now();\n      await expect(page.getByTestId('file-tree')).toBeVisible({ timeout: 10000 });\n      const processingTime = Date.now() - startTime;\n      \n      console.log(`${browserName} File Processing Time: ${processingTime}ms`);\n      expect(processingTime).toBeLessThan(5000); // 5ç§’å†…å¤„ç†1MBæ–‡ä»¶\n    });\n\n    test('å†…å­˜ä½¿ç”¨ç›‘æ§', async ({ page, browserName }) => {\n      await page.goto('/');\n      \n      // æ£€æŸ¥å†…å­˜APIæ”¯æŒ\n      const memoryApiSupported = await page.evaluate(() => {\n        return 'memory' in performance;\n      });\n      \n      if (memoryApiSupported) {\n        const initialMemory = await page.evaluate(() => {\n          const memory = (performance as any).memory;\n          return {\n            used: memory.usedJSHeapSize,\n            total: memory.totalJSHeapSize,\n            limit: memory.jsHeapSizeLimit\n          };\n        });\n        \n        console.log(`${browserName} Initial Memory:`, initialMemory);\n        \n        // å¤„ç†æ–‡ä»¶å¹¶ç›‘æ§å†…å­˜å˜åŒ–\n        const mediumZipPath = path.join(__dirname, '../fixtures/archives/medium_10mb.zip');\n        await page.setInputFiles('input[type=\"file\"]', mediumZipPath);\n        await expect(page.getByTestId('file-tree')).toBeVisible({ timeout: 15000 });\n        \n        const afterProcessingMemory = await page.evaluate(() => {\n          const memory = (performance as any).memory;\n          return {\n            used: memory.usedJSHeapSize,\n            total: memory.totalJSHeapSize,\n            limit: memory.jsHeapSizeLimit\n          };\n        });\n        \n        console.log(`${browserName} After Processing Memory:`, afterProcessingMemory);\n        \n        // éªŒè¯å†…å­˜å¢é•¿åœ¨åˆç†èŒƒå›´å†…\n        const memoryIncrease = afterProcessingMemory.used - initialMemory.used;\n        expect(memoryIncrease).toBeLessThan(50 * 1024 * 1024); // 50MBå†…å­˜å¢é•¿é™åˆ¶\n      }\n    });\n\n    test('å®‰å…¨åŠŸèƒ½æµ‹è¯•', async ({ page, browserName }) => {\n      await page.goto('/');\n      \n      // æµ‹è¯•å†…å®¹å®‰å…¨ç­–ç•¥ (CSP)\n      const cspViolations: string[] = [];\n      page.on('console', msg => {\n        if (msg.type() === 'error' && msg.text().includes('Content Security Policy')) {\n          cspViolations.push(msg.text());\n        }\n      });\n      \n      // ä¸Šä¼ æ–‡ä»¶è§¦å‘å„ç§æ“ä½œ\n      const zipFilePath = path.join(__dirname, '../fixtures/archives/security_test.zip');\n      await page.setInputFiles('input[type=\"file\"]', zipFilePath);\n      await expect(page.getByTestId('file-tree')).toBeVisible({ timeout: 10000 });\n      \n      // éªŒè¯æ²¡æœ‰CSPè¿è§„\n      expect(cspViolations).toHaveLength(0);\n      \n      // æµ‹è¯•XSSé˜²æŠ¤\n      const fileTree = page.getByTestId('file-tree');\n      await expect(fileTree.getByText('<script>alert(\"xss\")</script>')).not.toBeVisible();\n      \n      // éªŒè¯å®‰å…¨çš„æ–‡ä»¶åå¤„ç†\n      const suspiciousFile = '..\\\\..\\\\malicious.exe';\n      await expect(fileTree.getByText(suspiciousFile)).not.toBeVisible();\n    });\n\n    test('è¾…åŠ©åŠŸèƒ½ (A11y) æµ‹è¯•', async ({ page, browserName }) => {\n      await page.goto('/');\n      \n      // æ³¨å…¥axe-coreè¿›è¡Œè¾…åŠ©åŠŸèƒ½æµ‹è¯•\n      await page.addScriptTag({\n        url: 'https://unpkg.com/axe-core@4.6.3/axe.min.js'\n      });\n      \n      // è¿è¡Œè¾…åŠ©åŠŸèƒ½æ£€æŸ¥\n      const accessibilityResults = await page.evaluate(() => {\n        return (window as any).axe.run();\n      });\n      \n      // éªŒè¯æ²¡æœ‰ä¸¥é‡çš„è¾…åŠ©åŠŸèƒ½é—®é¢˜\n      const violations = accessibilityResults.violations.filter(\n        (violation: any) => violation.impact === 'critical' || violation.impact === 'serious'\n      );\n      \n      if (violations.length > 0) {\n        console.warn(`${browserName} A11y Violations:`, violations);\n      }\n      \n      expect(violations.length).toBe(0);\n      \n      // æ‰‹åŠ¨æµ‹è¯•ä¸€äº›å…³é”®çš„è¾…åŠ©åŠŸèƒ½\n      const uploadZone = page.getByTestId('file-upload-zone');\n      await expect(uploadZone).toHaveAttribute('role');\n      await expect(uploadZone).toHaveAttribute('aria-label');\n      await expect(uploadZone).toHaveAttribute('tabindex');\n      \n      // æµ‹è¯•é”®ç›˜å¯¼èˆª\n      await page.keyboard.press('Tab');\n      await expect(uploadZone).toBeFocused();\n      \n      // æµ‹è¯•å±å¹•é˜…è¯»å™¨æ”¯æŒ\n      const srOnly = page.locator('.sr-only').first();\n      if (await srOnly.isVisible()) {\n        await expect(srOnly).toHaveText(/å¯è®¿é—®æ€§ä¿¡æ¯/);\n      }\n    });\n\n    test('ç½‘ç»œæ¡ä»¶æµ‹è¯•', async ({ page, browserName, context }) => {\n      // æ¨¡æ‹Ÿæ…¢é€Ÿç½‘ç»œ\n      await context.route('**/*', route => {\n        setTimeout(() => route.continue(), 100); // 100mså»¶è¿Ÿ\n      });\n      \n      await page.goto('/');\n      await expect(page.getByTestId('file-upload-zone')).toBeVisible({ timeout: 10000 });\n      \n      // åœ¨æ…¢é€Ÿç½‘ç»œä¸‹æµ‹è¯•æ–‡ä»¶ä¸Šä¼ \n      const zipFilePath = path.join(__dirname, '../fixtures/archives/network_test.zip');\n      await page.setInputFiles('input[type=\"file\"]', zipFilePath);\n      \n      // éªŒè¯åŠ è½½æŒ‡ç¤ºå™¨\n      await expect(page.getByTestId('loading-spinner')).toBeVisible();\n      await expect(page.getByTestId('progress-bar')).toBeVisible();\n      \n      // ç­‰å¾…å¤„ç†å®Œæˆ\n      await expect(page.getByTestId('file-tree')).toBeVisible({ timeout: 15000 });\n      \n      // æ¨¡æ‹Ÿç½‘ç»œä¸­æ–­\n      await context.setOffline(true);\n      \n      // éªŒè¯ç¦»çº¿å¤„ç†èƒ½åŠ›\n      const offlineFilePath = path.join(__dirname, '../fixtures/archives/offline.zip');\n      await page.setInputFiles('input[type=\"file\"]', offlineFilePath);\n      \n      // å³ä½¿ç¦»çº¿ä¹Ÿåº”è¯¥èƒ½å¤„ç†æœ¬åœ°æ–‡ä»¶\n      await expect(page.getByTestId('file-tree')).toBeVisible({ timeout: 10000 });\n      \n      // æ¢å¤ç½‘ç»œ\n      await context.setOffline(false);\n    });\n\n    test('å­˜å‚¨é…é¢æµ‹è¯•', async ({ page, browserName }) => {\n      await page.goto('/');\n      \n      // æ£€æŸ¥å­˜å‚¨APIæ”¯æŒ\n      const storageSupport = await page.evaluate(async () => {\n        const hasStorageManager = 'storage' in navigator && 'estimate' in navigator.storage;\n        let quota = { usage: 0, quota: 0 };\n        \n        if (hasStorageManager) {\n          quota = await navigator.storage.estimate();\n        }\n        \n        return {\n          hasStorageManager,\n          indexedDB: 'indexedDB' in window,\n          localStorage: 'localStorage' in window,\n          quota: quota\n        };\n      });\n      \n      console.log(`${browserName} Storage Support:`, storageSupport);\n      \n      if (storageSupport.hasStorageManager) {\n        // æµ‹è¯•å¤§æ–‡ä»¶å­˜å‚¨èƒ½åŠ›\n        const largeFilePath = path.join(__dirname, '../fixtures/archives/large_25mb.zip');\n        await page.setInputFiles('input[type=\"file\"]', largeFilePath);\n        await expect(page.getByTestId('file-tree')).toBeVisible({ timeout: 20000 });\n        \n        // æ£€æŸ¥å­˜å‚¨ä½¿ç”¨æƒ…å†µ\n        const storageAfter = await page.evaluate(async () => {\n          return await navigator.storage.estimate();\n        });\n        \n        console.log(`${browserName} Storage After Large File:`, storageAfter);\n        \n        // éªŒè¯å­˜å‚¨ç®¡ç†\n        const storageUsage = storageAfter.usage! / (1024 * 1024); // MB\n        expect(storageUsage).toBeLessThan(100); // ä¸åº”è¶…è¿‡100MB\n      }\n    });\n  });\n}\n\n// ç‰¹æ®Šçš„æµè§ˆå™¨ç‰¹å®šæµ‹è¯•\ntest.describe('Chromeç‰¹å®šåŠŸèƒ½æµ‹è¯•', () => {\n  test.use({ ...devices['Desktop Chrome'] });\n\n  test('FileSystem Access API', async ({ page }) => {\n    await page.goto('/');\n    \n    const hasFileSystemAccess = await page.evaluate(() => {\n      return 'showOpenFilePicker' in window;\n    });\n    \n    if (hasFileSystemAccess) {\n      // éªŒè¯é«˜çº§æ–‡ä»¶æ“ä½œæŒ‰é’®å­˜åœ¨\n      await expect(page.getByTestId('advanced-file-picker')).toBeVisible();\n      \n      // æµ‹è¯•ç›®å½•é€‰æ‹©åŠŸèƒ½\n      await expect(page.getByTestId('directory-picker')).toBeVisible();\n    }\n  });\n\n  test('Origin Private File System (OPFS)', async ({ page }) => {\n    await page.goto('/');\n    \n    const hasOPFS = await page.evaluate(async () => {\n      try {\n        const opfsRoot = await navigator.storage.getDirectory();\n        return opfsRoot !== null;\n      } catch {\n        return false;\n      }\n    });\n    \n    if (hasOPFS) {\n      console.log('OPFS supported in Chrome');\n      \n      // æµ‹è¯•å¤§æ–‡ä»¶çš„OPFSå­˜å‚¨\n      const largeFilePath = path.join(__dirname, '../fixtures/archives/large_50mb.zip');\n      await page.setInputFiles('input[type=\"file\"]', largeFilePath);\n      \n      // éªŒè¯ä½¿ç”¨OPFSå­˜å‚¨\n      await expect(page.getByTestId('opfs-storage-indicator')).toBeVisible();\n    }\n  });\n});\n\ntest.describe('Safariç‰¹å®šé™åˆ¶æµ‹è¯•', () => {\n  test.use({ ...devices['Desktop Safari'] });\n\n  test('Safarié™åˆ¶å¤„ç†', async ({ page }) => {\n    await page.goto('/');\n    \n    // Safariå¯¹æŸäº›APIæœ‰é™åˆ¶ï¼ŒéªŒè¯é™çº§æ–¹æ¡ˆ\n    const safariLimitations = await page.evaluate(() => {\n      return {\n        noFileSystemAccess: !('showOpenFilePicker' in window),\n        limitedWorkers: typeof SharedWorker === 'undefined',\n        restrictedStorage: false // æ ¹æ®å®é™…æƒ…å†µè°ƒæ•´\n      };\n    });\n    \n    console.log('Safari Limitations:', safariLimitations);\n    \n    if (safariLimitations.noFileSystemAccess) {\n      // éªŒè¯ä¼ ç»Ÿæ–‡ä»¶é€‰æ‹©é™çº§æ–¹æ¡ˆ\n      await expect(page.getByTestId('traditional-file-picker')).toBeVisible();\n      await expect(page.getByTestId('advanced-file-picker')).not.toBeVisible();\n    }\n    \n    // æµ‹è¯•åŸºç¡€åŠŸèƒ½ä»ç„¶æ­£å¸¸\n    const zipFilePath = path.join(__dirname, '../fixtures/archives/safari_test.zip');\n    await page.setInputFiles('input[type=\"file\"]', zipFilePath);\n    await expect(page.getByTestId('file-tree')).toBeVisible({ timeout: 15000 });\n  });\n});\n\ntest.describe('ç§»åŠ¨è®¾å¤‡ç‰¹å®šæµ‹è¯•', () => {\n  test('iOS Safariè§¦æ‘¸äº¤äº’', async ({ page }) => {\n    test.use({ ...devices['iPhone 12'] });\n    \n    await page.goto('/');\n    \n    const zipFilePath = path.join(__dirname, '../fixtures/archives/mobile_test.zip');\n    await page.setInputFiles('input[type=\"file\"]', zipFilePath);\n    await expect(page.getByTestId('file-tree')).toBeVisible({ timeout: 15000 });\n    \n    // æµ‹è¯•è§¦æ‘¸æ‰‹åŠ¿\n    const fileItem = page.getByText('mobile_file.txt').first();\n    \n    // ç‚¹å‡»é€‰æ‹©\n    await fileItem.tap();\n    await expect(page.getByTestId('preview-panel')).toBeVisible();\n    \n    // æµ‹è¯•é•¿æŒ‰èœå•ï¼ˆå¦‚æœæ”¯æŒï¼‰\n    await fileItem.tap({ delay: 500 });\n    // éªŒè¯ä¸Šä¸‹æ–‡èœå•æˆ–ç›¸å…³åŠŸèƒ½\n  });\n\n  test('Android Chromeæ€§èƒ½', async ({ page }) => {\n    test.use({ ...devices['Pixel 5'] });\n    \n    await page.goto('/');\n    \n    // åœ¨ç§»åŠ¨è®¾å¤‡ä¸Šæµ‹è¯•æ€§èƒ½\n    const mediumFilePath = path.join(__dirname, '../fixtures/archives/mobile_medium.zip');\n    \n    const startTime = Date.now();\n    await page.setInputFiles('input[type=\"file\"]', mediumFilePath);\n    await expect(page.getByTestId('file-tree')).toBeVisible({ timeout: 20000 });\n    const processingTime = Date.now() - startTime;\n    \n    console.log(`Mobile Processing Time: ${processingTime}ms`);\n    \n    // ç§»åŠ¨è®¾å¤‡æ€§èƒ½è¦æ±‚ç›¸å¯¹å®½æ¾\n    expect(processingTime).toBeLessThan(15000); // 15ç§’å†…\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/tests/e2e/zip-rar-user-scenarios.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/tests/fixtures/file-generator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/tests/fixtures/zip-rar-test-data.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'TestFileGenerator' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":27},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":428,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":428,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12409,12412],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12409,12412],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { TestFileGenerator } from './file-generator';\n\n/**\n * ZIPå’ŒRARæ ¼å¼ä¸“ç”¨æµ‹è¯•æ•°æ®ç”Ÿæˆå™¨\n * æä¾›æ›´çœŸå®å’Œå¤æ‚çš„æµ‹è¯•åœºæ™¯\n */\nexport class ZipRarTestData {\n  \n  // ç”Ÿæˆæ ‡å‡†ZIPæ–‡ä»¶æ•°æ®\n  static generateStandardZip(): ArrayBuffer {\n    const zipData = new ArrayBuffer(1024);\n    const view = new Uint8Array(zipData);\n    \n    // ZIPæ–‡ä»¶å¤´\n    const header = [\n      // Local file header signature\n      0x50, 0x4b, 0x03, 0x04,\n      // Version needed to extract\n      0x14, 0x00,\n      // General purpose bit flag\n      0x00, 0x00,\n      // Compression method (deflate)\n      0x08, 0x00,\n      // File last modification time\n      0x00, 0x00,\n      // File last modification date\n      0x00, 0x21,\n      // CRC-32\n      0x12, 0x34, 0x56, 0x78,\n      // Compressed size\n      0x16, 0x00, 0x00, 0x00,\n      // Uncompressed size\n      0x16, 0x00, 0x00, 0x00,\n      // File name length\n      0x08, 0x00,\n      // Extra field length\n      0x00, 0x00\n    ];\n    \n    header.forEach((byte, index) => {\n      view[index] = byte;\n    });\n    \n    // æ–‡ä»¶å \"test.txt\"\n    const fileName = new TextEncoder().encode('test.txt');\n    fileName.forEach((byte, index) => {\n      view[header.length + index] = byte;\n    });\n    \n    // å‹ç¼©æ•°æ® (ç®€åŒ–)\n    const compressedData = [\n      0x2b, 0x49, 0x2d, 0x2e, 0x51, 0x48, 0x49, 0x2c,\n      0x49, 0x04, 0x00, 0x2d, 0x49, 0x2d, 0x2e, 0x51,\n      0x48, 0x49, 0x2c, 0x49, 0x04, 0x00\n    ];\n    \n    compressedData.forEach((byte, index) => {\n      view[header.length + fileName.length + index] = byte;\n    });\n    \n    return zipData;\n  }\n\n  // ç”Ÿæˆå¯†ç ä¿æŠ¤çš„ZIPæ–‡ä»¶æ•°æ®\n  static generatePasswordProtectedZip(): ArrayBuffer {\n    const zipData = new ArrayBuffer(2048);\n    const view = new Uint8Array(zipData);\n    \n    // å¸¦åŠ å¯†æ ‡å¿—çš„ZIPå¤´\n    const encryptedHeader = [\n      0x50, 0x4b, 0x03, 0x04, // ç­¾å\n      0x14, 0x00,             // ç‰ˆæœ¬\n      0x01, 0x00,             // åŠ å¯†æ ‡å¿— (bit 0 set)\n      0x08, 0x00,             // å‹ç¼©æ–¹æ³•\n      0x00, 0x00, 0x00, 0x21, // æ—¶é—´æˆ³\n      0x00, 0x00, 0x00, 0x00, // CRC32 (0 for encrypted)\n      0x20, 0x00, 0x00, 0x00, // å‹ç¼©å¤§å°\n      0x16, 0x00, 0x00, 0x00, // åŸå§‹å¤§å°\n      0x0c, 0x00,             // æ–‡ä»¶åé•¿åº¦\n      0x00, 0x00              // é¢å¤–å­—æ®µé•¿åº¦\n    ];\n    \n    encryptedHeader.forEach((byte, index) => {\n      view[index] = byte;\n    });\n    \n    // æ–‡ä»¶å (åŠ å¯†æ–‡ä»¶)\n    const fileName = new TextEncoder().encode('secret.txt');\n    fileName.forEach((byte, index) => {\n      view[encryptedHeader.length + index] = byte;\n    });\n    \n    // åŠ å¯†çš„æ•°æ® (æ¨¡æ‹Ÿ)\n    const encryptedData = new Uint8Array(32);\n    for (let i = 0; i < encryptedData.length; i++) {\n      encryptedData[i] = Math.floor(Math.random() * 256);\n    }\n    \n    encryptedData.forEach((byte, index) => {\n      view[encryptedHeader.length + fileName.length + index] = byte;\n    });\n    \n    return zipData.slice(0, encryptedHeader.length + fileName.length + encryptedData.length);\n  }\n\n  // ç”Ÿæˆå¤šæ–‡ä»¶ZIPæµ‹è¯•æ•°æ®\n  static generateMultiFileZip(): ArrayBuffer {\n    const files = [\n      { name: 'readme.txt', content: 'Welcome to ZhugeExtract!' },\n      { name: 'image.jpg', content: 'JPEG_MOCK_DATA' },\n      { name: 'document.pdf', content: 'PDF_MOCK_DATA' },\n      { name: 'folder/', content: '', isDirectory: true }\n    ];\n    \n    const zipData = new ArrayBuffer(8192);\n    const view = new Uint8Array(zipData);\n    let offset = 0;\n    \n    files.forEach(file => {\n      // Local file header\n      const header = [\n        0x50, 0x4b, 0x03, 0x04, // ç­¾å\n        0x14, 0x00,             // ç‰ˆæœ¬\n        0x00, 0x00,             // æ ‡å¿—\n        file.isDirectory ? 0x00 : 0x08, 0x00, // å‹ç¼©æ–¹æ³•\n        0x00, 0x00, 0x00, 0x21, // æ—¶é—´æˆ³\n        0x12, 0x34, 0x56, 0x78, // CRC32\n        file.content.length, 0x00, 0x00, 0x00, // å‹ç¼©å¤§å°\n        file.content.length, 0x00, 0x00, 0x00, // åŸå§‹å¤§å°\n        file.name.length, 0x00, // æ–‡ä»¶åé•¿åº¦\n        0x00, 0x00              // é¢å¤–å­—æ®µé•¿åº¦\n      ];\n      \n      // å†™å…¥å¤´éƒ¨\n      header.forEach((byte, i) => {\n        view[offset + i] = byte;\n      });\n      offset += header.length;\n      \n      // å†™å…¥æ–‡ä»¶å\n      const nameBytes = new TextEncoder().encode(file.name);\n      nameBytes.forEach((byte, i) => {\n        view[offset + i] = byte;\n      });\n      offset += nameBytes.length;\n      \n      // å†™å…¥æ–‡ä»¶å†…å®¹\n      if (!file.isDirectory) {\n        const contentBytes = new TextEncoder().encode(file.content);\n        contentBytes.forEach((byte, i) => {\n          view[offset + i] = byte;\n        });\n        offset += contentBytes.length;\n      }\n    });\n    \n    return zipData.slice(0, offset);\n  }\n\n  // ç”Ÿæˆæ ‡å‡†RARæ–‡ä»¶æ•°æ®\n  static generateStandardRar(): ArrayBuffer {\n    const rarData = new ArrayBuffer(2048);\n    const view = new Uint8Array(rarData);\n    \n    // RAR 5.x ç­¾åå’Œå¤´éƒ¨\n    const rar5Header = [\n      // RAR signature\n      0x52, 0x61, 0x72, 0x21, 0x1a, 0x07, 0x01, 0x00,\n      // Archive header\n      0x01, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      // File header starts here\n      0x02, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x08, 0x00, 0x00, 0x00, 0x74, 0x65, 0x73, 0x74,\n      0x2e, 0x74, 0x78, 0x74\n    ];\n    \n    rar5Header.forEach((byte, index) => {\n      view[index] = byte;\n    });\n    \n    // æ–‡ä»¶æ•°æ®\n    const fileData = new TextEncoder().encode('RAR test content');\n    fileData.forEach((byte, index) => {\n      view[rar5Header.length + index] = byte;\n    });\n    \n    return rarData.slice(0, rar5Header.length + fileData.length);\n  }\n\n  // ç”Ÿæˆå¯†ç ä¿æŠ¤çš„RARæ–‡ä»¶æ•°æ®\n  static generatePasswordProtectedRar(): ArrayBuffer {\n    const rarData = new ArrayBuffer(3072);\n    const view = new Uint8Array(rarData);\n    \n    // RAR 5.x åŠ å¯†å¤´\n    const encryptedRarHeader = [\n      // RAR signature\n      0x52, 0x61, 0x72, 0x21, 0x1a, 0x07, 0x01, 0x00,\n      // Archive header with encryption\n      0x01, 0x00, 0x09, 0x00, 0x80, 0x00, 0x00, 0x00, // 0x80 = encrypted\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      // Encryption info\n      0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n      // Encrypted file header\n      0x02, 0x00, 0x15, 0x00, 0x80, 0x00, 0x00, 0x00\n    ];\n    \n    encryptedRarHeader.forEach((byte, index) => {\n      view[index] = byte;\n    });\n    \n    // åŠ å¯†çš„æ–‡ä»¶æ•°æ®\n    const encryptedData = new Uint8Array(256);\n    for (let i = 0; i < encryptedData.length; i++) {\n      encryptedData[i] = Math.floor(Math.random() * 256);\n    }\n    \n    encryptedData.forEach((byte, index) => {\n      view[encryptedRarHeader.length + index] = byte;\n    });\n    \n    return rarData.slice(0, encryptedRarHeader.length + encryptedData.length);\n  }\n\n  // ç”ŸæˆRARåˆ†å·æ–‡ä»¶æ•°æ®\n  static generateRarVolumes(): ArrayBuffer[] {\n    const volumes = [];\n    \n    // ç¬¬ä¸€å· (part1.rar)\n    const volume1 = new ArrayBuffer(1024);\n    const view1 = new Uint8Array(volume1);\n    \n    const vol1Header = [\n      0x52, 0x61, 0x72, 0x21, 0x1a, 0x07, 0x01, 0x00, // RAR signature\n      0x01, 0x00, 0x09, 0x00, 0x01, 0x00, 0x00, 0x00, // Archive header (volume flag)\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n    ];\n    \n    vol1Header.forEach((byte, index) => {\n      view1[index] = byte;\n    });\n    volumes.push(volume1);\n    \n    // ç¬¬äºŒå· (part2.rar)\n    const volume2 = new ArrayBuffer(1024);\n    const view2 = new Uint8Array(volume2);\n    \n    const vol2Header = [\n      0x52, 0x61, 0x72, 0x21, 0x1a, 0x07, 0x01, 0x00, // RAR signature\n      0x01, 0x00, 0x09, 0x00, 0x02, 0x00, 0x00, 0x00, // Archive header (volume 2)\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n    ];\n    \n    vol2Header.forEach((byte, index) => {\n      view2[index] = byte;\n    });\n    volumes.push(volume2);\n    \n    // æœ€åä¸€å· (part3.rar)\n    const volume3 = new ArrayBuffer(1024);\n    const view3 = new Uint8Array(volume3);\n    \n    const vol3Header = [\n      0x52, 0x61, 0x72, 0x21, 0x1a, 0x07, 0x01, 0x00, // RAR signature\n      0x01, 0x00, 0x09, 0x00, 0x04, 0x00, 0x00, 0x00, // Archive header (last volume flag)\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n    ];\n    \n    vol3Header.forEach((byte, index) => {\n      view3[index] = byte;\n    });\n    volumes.push(volume3);\n    \n    return volumes;\n  }\n\n  // ç”ŸæˆæŸåçš„ZIPæ–‡ä»¶\n  static generateCorruptedZip(): ArrayBuffer {\n    const corruptedZip = new ArrayBuffer(512);\n    const view = new Uint8Array(corruptedZip);\n    \n    // éƒ¨åˆ†ZIPç­¾å\n    view[0] = 0x50;\n    view[1] = 0x4b;\n    view[2] = 0x03;\n    view[3] = 0x04;\n    \n    // æŸåçš„å¤´éƒ¨æ•°æ®\n    for (let i = 4; i < 50; i++) {\n      view[i] = 0xFF; // æ— æ•ˆæ•°æ®\n    }\n    \n    // éšæœºæ•°æ®å¡«å……\n    for (let i = 50; i < 512; i++) {\n      view[i] = Math.floor(Math.random() * 256);\n    }\n    \n    return corruptedZip;\n  }\n\n  // ç”ŸæˆæŸåçš„RARæ–‡ä»¶\n  static generateCorruptedRar(): ArrayBuffer {\n    const corruptedRar = new ArrayBuffer(1024);\n    const view = new Uint8Array(corruptedRar);\n    \n    // RARç­¾å (æ­£ç¡®)\n    const signature = [0x52, 0x61, 0x72, 0x21, 0x1a, 0x07, 0x01, 0x00];\n    signature.forEach((byte, index) => {\n      view[index] = byte;\n    });\n    \n    // æŸåçš„å¤´éƒ¨\n    for (let i = 8; i < 64; i++) {\n      view[i] = 0x00; // æ— æ•ˆçš„å¤´éƒ¨æ•°æ®\n    }\n    \n    // éšæœºæŸåæ•°æ®\n    for (let i = 64; i < 1024; i++) {\n      view[i] = Math.floor(Math.random() * 256);\n    }\n    \n    return corruptedRar;\n  }\n\n  // ç”Ÿæˆå¸¦æ¢å¤è®°å½•çš„RARæ–‡ä»¶\n  static generateRarWithRecovery(): ArrayBuffer {\n    const rarData = new ArrayBuffer(4096);\n    const view = new Uint8Array(rarData);\n    \n    // æ ‡å‡†RARå¤´\n    const rarHeader = [\n      0x52, 0x61, 0x72, 0x21, 0x1a, 0x07, 0x01, 0x00,\n      0x01, 0x00, 0x0d, 0x00, 0x20, 0x00, 0x00, 0x00, // 0x20 = recovery record flag\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n    ];\n    \n    rarHeader.forEach((byte, index) => {\n      view[index] = byte;\n    });\n    \n    // æ¢å¤è®°å½•å¤´\n    const recoveryHeader = [\n      0x78, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, // Recovery record header\n      0x01, 0x00, 0x00, 0x00 // Recovery sectors\n    ];\n    \n    recoveryHeader.forEach((byte, index) => {\n      view[rarHeader.length + index] = byte;\n    });\n    \n    // æ¢å¤æ•°æ® (1KB)\n    const recoveryData = new Uint8Array(1024);\n    for (let i = 0; i < recoveryData.length; i++) {\n      recoveryData[i] = i % 256; // æ¨¡å¼æ•°æ®\n    }\n    \n    recoveryData.forEach((byte, index) => {\n      view[rarHeader.length + recoveryHeader.length + index] = byte;\n    });\n    \n    return rarData.slice(0, rarHeader.length + recoveryHeader.length + recoveryData.length);\n  }\n\n  // ç”Ÿæˆå›ºå®å‹ç¼©RARæ–‡ä»¶\n  static generateSolidRar(): ArrayBuffer {\n    const solidRar = new ArrayBuffer(3072);\n    const view = new Uint8Array(solidRar);\n    \n    // RARç­¾å\n    const signature = [0x52, 0x61, 0x72, 0x21, 0x1a, 0x07, 0x01, 0x00];\n    signature.forEach((byte, index) => {\n      view[index] = byte;\n    });\n    \n    // æ¡£æ¡ˆå¤´ (å›ºå®æ ‡å¿—)\n    const archiveHeader = [\n      0x01, 0x00, 0x09, 0x00, 0x08, 0x00, 0x00, 0x00, // 0x08 = solid flag\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n    ];\n    \n    archiveHeader.forEach((byte, index) => {\n      view[signature.length + index] = byte;\n    });\n    \n    // æ–‡ä»¶å¤´1 (å›ºå®æ–‡ä»¶)\n    const file1Header = [\n      0x02, 0x00, 0x15, 0x00, 0x88, 0x00, 0x00, 0x00, // 0x88 = solid + compressed\n      0x0a, 0x00, 0x00, 0x00, // æ–‡ä»¶å¤§å°\n      0x66, 0x69, 0x6c, 0x65, 0x31, 0x2e, 0x74, 0x78, 0x74, 0x00 // \"file1.txt\"\n    ];\n    \n    file1Header.forEach((byte, index) => {\n      view[signature.length + archiveHeader.length + index] = byte;\n    });\n    \n    return solidRar.slice(0, signature.length + archiveHeader.length + file1Header.length);\n  }\n\n  // ç”Ÿæˆæµ‹è¯•æ–‡ä»¶é›†åˆ\n  static generateTestFileSet(): {\n    zipFiles: { name: string; data: ArrayBuffer }[];\n    rarFiles: { name: string; data: ArrayBuffer }[];\n  } {\n    return {\n      zipFiles: [\n        { name: 'standard.zip', data: this.generateStandardZip() },\n        { name: 'password-protected.zip', data: this.generatePasswordProtectedZip() },\n        { name: 'multi-file.zip', data: this.generateMultiFileZip() },\n        { name: 'corrupted.zip', data: this.generateCorruptedZip() }\n      ],\n      rarFiles: [\n        { name: 'standard.rar', data: this.generateStandardRar() },\n        { name: 'password-protected.rar', data: this.generatePasswordProtectedRar() },\n        { name: 'with-recovery.rar', data: this.generateRarWithRecovery() },\n        { name: 'solid.rar', data: this.generateSolidRar() },\n        { name: 'corrupted.rar', data: this.generateCorruptedRar() }\n      ]\n    };\n  }\n\n  // åˆ›å»ºå‹ç¼©æµ‹è¯•åœºæ™¯\n  static createCompressionScenarios(): Array<{\n    name: string;\n    format: 'zip' | 'rar';\n    data: ArrayBuffer;\n    expectedBehavior: string;\n    testParams: Record<string, any>;\n  }> {\n    return [\n      {\n        name: 'ZIPæœ€ä½³å‹ç¼©æ¯”æµ‹è¯•',\n        format: 'zip',\n        data: this.generateStandardZip(),\n        expectedBehavior: 'high_compression_ratio',\n        testParams: { expectedRatio: 0.7, maxTime: 1000 }\n      },\n      {\n        name: 'RARå›ºå®å‹ç¼©æ€§èƒ½æµ‹è¯•',\n        format: 'rar',\n        data: this.generateSolidRar(),\n        expectedBehavior: 'solid_compression_efficiency',\n        testParams: { sequential: true, maxMemory: 50 * 1024 * 1024 }\n      },\n      {\n        name: 'ZIPå¯†ç ç ´è§£é˜²æŠ¤æµ‹è¯•',\n        format: 'zip',\n        data: this.generatePasswordProtectedZip(),\n        expectedBehavior: 'password_protection',\n        testParams: { attempts: 3, lockoutTime: 1000 }\n      },\n      {\n        name: 'RARæ¢å¤è®°å½•åŠŸèƒ½æµ‹è¯•',\n        format: 'rar',\n        data: this.generateRarWithRecovery(),\n        expectedBehavior: 'error_recovery',\n        testParams: { recoverySuccess: true, maxRecoveryTime: 5000 }\n      }\n    ];\n  }\n}\n\n// å¯¼å‡ºä¾¿æ·çš„æµ‹è¯•æ•°æ®è®¿é—®å™¨\nexport const zipTestData = {\n  standard: () => ZipRarTestData.generateStandardZip(),\n  passwordProtected: () => ZipRarTestData.generatePasswordProtectedZip(),\n  multiFile: () => ZipRarTestData.generateMultiFileZip(),\n  corrupted: () => ZipRarTestData.generateCorruptedZip()\n};\n\nexport const rarTestData = {\n  standard: () => ZipRarTestData.generateStandardRar(),\n  passwordProtected: () => ZipRarTestData.generatePasswordProtectedRar(),\n  volumes: () => ZipRarTestData.generateRarVolumes(),\n  withRecovery: () => ZipRarTestData.generateRarWithRecovery(),\n  solid: () => ZipRarTestData.generateSolidRar(),\n  corrupted: () => ZipRarTestData.generateCorruptedRar()\n};","usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/tests/integration/apis/libarchive-integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/tests/integration/workflows/archive-extraction-workflow.test.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: '>' expected.","line":79,"column":28,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport React from 'react';\nimport { ArchiveViewer } from '@/components/ArchiveViewer';\nimport { ArchiveService } from '@/services/archive-service';\nimport { PreviewService } from '@/services/preview-service';\nimport { StorageService } from '@/services/storage-service';\nimport { createTestArchive, createMockFile } from '../../utils/test-helpers';\n\n// Mock services\nvi.mock('@/services/archive-service');\nvi.mock('@/services/preview-service');\nvi.mock('@/services/storage-service');\n\ndescribe('Archive Extraction Workflow Integration', () => {\n  let mockArchiveService: any;\n  let mockPreviewService: any;\n  let mockStorageService: any;\n\n  beforeEach(() => {\n    mockArchiveService = vi.mocked(ArchiveService);\n    mockPreviewService = vi.mocked(PreviewService);\n    mockStorageService = vi.mocked(StorageService);\n\n    // Reset mocks\n    vi.clearAllMocks();\n  });\n\n  afterEach(() => {\n    vi.restoreAllMocks();\n  });\n\n  describe('å®Œæ•´è§£å‹æµç¨‹', () => {\n    it('åº”è¯¥å®Œæˆä»ä¸Šä¼ åˆ°é¢„è§ˆçš„å®Œæ•´æµç¨‹', async () => {\n      // å‡†å¤‡æµ‹è¯•æ•°æ®\n      const mockArchiveData = {\n        id: 'archive-1',\n        name: 'test.zip',\n        format: 'zip',\n        size: 1024,\n        structure: [\n          {\n            name: 'readme.txt',\n            type: 'file',\n            size: 100,\n            path: 'readme.txt',\n            mimeType: 'text/plain'\n          },\n          {\n            name: 'images',\n            type: 'directory',\n            size: 0,\n            path: 'images/',\n            children: [\n              {\n                name: 'photo.jpg',\n                type: 'file',\n                size: 50000,\n                path: 'images/photo.jpg',\n                mimeType: 'image/jpeg'\n              }\n            ]\n          }\n        ]\n      };\n\n      // MockæœåŠ¡è¿”å›\n      mockArchiveService.prototype.loadArchive.mockResolvedValue(mockArchiveData);\n      mockArchiveService.prototype.extractFile.mockResolvedValue(\n        new TextEncoder().encode('Hello World')\n      );\n      mockPreviewService.prototype.preview.mockResolvedValue({\n        type: 'text',\n        content: 'Hello World'\n      });\n      mockStorageService.prototype.store.mockResolvedValue('storage-id');\n\n      // æ¸²æŸ“ç»„ä»¶\n      render(<ArchiveViewer />);\n\n      // 1. ä¸Šä¼ æ–‡ä»¶\n      const fileInput = screen.getByTestId('file-input');\n      const zipFile = createMockFile('test.zip', 'application/zip', 1024);\n      \n      fireEvent.change(fileInput, { target: { files: [zipFile] } });\n\n      // 2. ç­‰å¾…è§£å‹å®Œæˆ\n      await waitFor(() => {\n        expect(screen.getByTestId('file-tree')).toBeInTheDocument();\n      }, { timeout: 5000 });\n\n      // 3. éªŒè¯æ–‡ä»¶æ ‘æ˜¾ç¤º\n      expect(screen.getByText('readme.txt')).toBeInTheDocument();\n      expect(screen.getByText('images')).toBeInTheDocument();\n      expect(screen.getByText('photo.jpg')).toBeInTheDocument();\n\n      // 4. ç‚¹å‡»æ–‡ä»¶è¿›è¡Œé¢„è§ˆ\n      const readmeFile = screen.getByText('readme.txt');\n      fireEvent.click(readmeFile);\n\n      // 5. ç­‰å¾…é¢„è§ˆåŠ è½½\n      await waitFor(() => {\n        expect(screen.getByTestId('preview-content')).toBeInTheDocument();\n      });\n\n      // 6. éªŒè¯é¢„è§ˆå†…å®¹\n      expect(screen.getByText('Hello World')).toBeInTheDocument();\n\n      // 7. éªŒè¯æœåŠ¡è°ƒç”¨\n      expect(mockArchiveService.prototype.loadArchive).toHaveBeenCalledWith(zipFile);\n      expect(mockArchiveService.prototype.extractFile).toHaveBeenCalledWith('readme.txt');\n      expect(mockPreviewService.prototype.preview).toHaveBeenCalled();\n      expect(mockStorageService.prototype.store).toHaveBeenCalled();\n    });\n\n    it('åº”è¯¥å¤„ç†RARæ–‡ä»¶çš„å®Œæ•´æµç¨‹', async () => {\n      const mockRarData = {\n        id: 'archive-2',\n        name: 'test.rar',\n        format: 'rar',\n        size: 2048,\n        structure: [\n          {\n            name: 'document.pdf',\n            type: 'file',\n            size: 100000,\n            path: 'document.pdf',\n            mimeType: 'application/pdf'\n          }\n        ]\n      };\n\n      mockArchiveService.prototype.loadArchive.mockResolvedValue(mockRarData);\n      mockArchiveService.prototype.extractFile.mockResolvedValue(\n        new Uint8Array(1000) // Mock PDF data\n      );\n      mockPreviewService.prototype.preview.mockResolvedValue({\n        type: 'pdf',\n        content: 'data:application/pdf;base64,mock-pdf-data'\n      });\n\n      render(<ArchiveViewer />);\n\n      const fileInput = screen.getByTestId('file-input');\n      const rarFile = createMockFile('test.rar', 'application/x-rar-compressed', 2048);\n      \n      fireEvent.change(fileInput, { target: { files: [rarFile] } });\n\n      await waitFor(() => {\n        expect(screen.getByTestId('file-tree')).toBeInTheDocument();\n      });\n\n      expect(screen.getByText('document.pdf')).toBeInTheDocument();\n\n      const pdfFile = screen.getByText('document.pdf');\n      fireEvent.click(pdfFile);\n\n      await waitFor(() => {\n        expect(screen.getByTestId('pdf-preview')).toBeInTheDocument();\n      });\n\n      expect(mockArchiveService.prototype.loadArchive).toHaveBeenCalledWith(rarFile);\n    });\n\n    it('åº”è¯¥å¤„ç†å¤§æ–‡ä»¶çš„åˆ†æ­¥åŠ è½½', async () => {\n      const largeMockData = {\n        id: 'large-archive',\n        name: 'large.zip',\n        format: 'zip',\n        size: 100 * 1024 * 1024, // 100MB\n        structure: Array.from({ length: 1000 }, (_, i) => ({\n          name: `file${i}.txt`,\n          type: 'file',\n          size: 1000,\n          path: `file${i}.txt`,\n          mimeType: 'text/plain'\n        }))\n      };\n\n      let loadProgress = 0;\n      mockArchiveService.prototype.loadArchive.mockImplementation(async (file) => {\n        // æ¨¡æ‹Ÿåˆ†æ­¥åŠ è½½\n        return new Promise((resolve) => {\n          const interval = setInterval(() => {\n            loadProgress += 20;\n            // æ¨¡æ‹Ÿè¿›åº¦äº‹ä»¶\n            if (loadProgress >= 100) {\n              clearInterval(interval);\n              resolve(largeMockData);\n            }\n          }, 100);\n        });\n      });\n\n      render(<ArchiveViewer />);\n\n      const fileInput = screen.getByTestId('file-input');\n      const largeFile = createMockFile('large.zip', 'application/zip', 100 * 1024 * 1024);\n      \n      fireEvent.change(fileInput, { target: { files: [largeFile] } });\n\n      // éªŒè¯åŠ è½½çŠ¶æ€\n      expect(screen.getByTestId('loading-spinner')).toBeInTheDocument();\n\n      // ç­‰å¾…åŠ è½½å®Œæˆ\n      await waitFor(() => {\n        expect(screen.getByTestId('file-tree')).toBeInTheDocument();\n      }, { timeout: 10000 });\n\n      // éªŒè¯æ–‡ä»¶æ•°é‡\n      const fileItems = screen.getAllByTestId('file-item');\n      expect(fileItems).toHaveLength(1000);\n    });\n  });\n\n  describe('é”™è¯¯å¤„ç†é›†æˆ', () => {\n    it('åº”è¯¥å¤„ç†æ–‡ä»¶è§£å‹å¤±è´¥', async () => {\n      mockArchiveService.prototype.loadArchive.mockRejectedValue(\n        new Error('Archive is corrupted')\n      );\n\n      render(<ArchiveViewer />);\n\n      const fileInput = screen.getByTestId('file-input');\n      const corruptedFile = createMockFile('corrupted.zip', 'application/zip', 1024);\n      \n      fireEvent.change(fileInput, { target: { files: [corruptedFile] } });\n\n      await waitFor(() => {\n        expect(screen.getByTestId('error-message')).toBeInTheDocument();\n      });\n\n      expect(screen.getByText(/Archive is corrupted/)).toBeInTheDocument();\n      expect(screen.getByTestId('retry-button')).toBeInTheDocument();\n    });\n\n    it('åº”è¯¥å¤„ç†é¢„è§ˆå¤±è´¥å¹¶æä¾›é™çº§æ–¹æ¡ˆ', async () => {\n      const mockArchiveData = {\n        id: 'archive-3',\n        name: 'test.zip',\n        format: 'zip',\n        structure: [\n          {\n            name: 'binary.exe',\n            type: 'file',\n            size: 1000,\n            path: 'binary.exe',\n            mimeType: 'application/octet-stream'\n          }\n        ]\n      };\n\n      mockArchiveService.prototype.loadArchive.mockResolvedValue(mockArchiveData);\n      mockArchiveService.prototype.extractFile.mockResolvedValue(\n        new Uint8Array([0x4D, 0x5A]) // PE header\n      );\n      mockPreviewService.prototype.preview.mockRejectedValue(\n        new Error('Cannot preview binary file')\n      );\n\n      render(<ArchiveViewer />);\n\n      const fileInput = screen.getByTestId('file-input');\n      const zipFile = createMockFile('test.zip', 'application/zip', 1024);\n      \n      fireEvent.change(fileInput, { target: { files: [zipFile] } });\n\n      await waitFor(() => {\n        expect(screen.getByText('binary.exe')).toBeInTheDocument();\n      });\n\n      const binaryFile = screen.getByText('binary.exe');\n      fireEvent.click(binaryFile);\n\n      await waitFor(() => {\n        expect(screen.getByTestId('binary-preview')).toBeInTheDocument();\n      });\n\n      // åº”è¯¥æ˜¾ç¤ºåå…­è¿›åˆ¶é¢„è§ˆ\n      expect(screen.getByText(/4D 5A/)).toBeInTheDocument();\n      expect(screen.getByTestId('download-button')).toBeInTheDocument();\n    });\n\n    it('åº”è¯¥å¤„ç†ç½‘ç»œä¸­æ–­åçš„é‡è¯•', async () => {\n      let attemptCount = 0;\n      mockArchiveService.prototype.loadArchive.mockImplementation(async () => {\n        attemptCount++;\n        if (attemptCount < 3) {\n          throw new Error('Network error');\n        }\n        return {\n          id: 'archive-retry',\n          name: 'test.zip',\n          format: 'zip',\n          structure: [{ name: 'file.txt', type: 'file', size: 100, path: 'file.txt' }]\n        };\n      });\n\n      render(<ArchiveViewer />);\n\n      const fileInput = screen.getByTestId('file-input');\n      const zipFile = createMockFile('test.zip', 'application/zip', 1024);\n      \n      fireEvent.change(fileInput, { target: { files: [zipFile] } });\n\n      // ç¬¬ä¸€æ¬¡å¤±è´¥\n      await waitFor(() => {\n        expect(screen.getByText(/Network error/)).toBeInTheDocument();\n      });\n\n      // ç‚¹å‡»é‡è¯•\n      const retryButton = screen.getByTestId('retry-button');\n      fireEvent.click(retryButton);\n\n      // ç¬¬äºŒæ¬¡å¤±è´¥\n      await waitFor(() => {\n        expect(screen.getByText(/Network error/)).toBeInTheDocument();\n      });\n\n      // å†æ¬¡é‡è¯•\n      fireEvent.click(retryButton);\n\n      // ç¬¬ä¸‰æ¬¡æˆåŠŸ\n      await waitFor(() => {\n        expect(screen.getByTestId('file-tree')).toBeInTheDocument();\n      });\n\n      expect(screen.getByText('file.txt')).toBeInTheDocument();\n      expect(attemptCount).toBe(3);\n    });\n  });\n\n  describe('æ€§èƒ½ä¼˜åŒ–é›†æˆ', () => {\n    it('åº”è¯¥å®ç°è™šæ‹Ÿæ»šåŠ¨å¤„ç†å¤§é‡æ–‡ä»¶', async () => {\n      const manyFilesMockData = {\n        id: 'many-files',\n        name: 'many-files.zip',\n        format: 'zip',\n        structure: Array.from({ length: 10000 }, (_, i) => ({\n          name: `file${i.toString().padStart(5, '0')}.txt`,\n          type: 'file',\n          size: 100,\n          path: `file${i.toString().padStart(5, '0')}.txt`,\n          mimeType: 'text/plain'\n        }))\n      };\n\n      mockArchiveService.prototype.loadArchive.mockResolvedValue(manyFilesMockData);\n\n      render(<ArchiveViewer />);\n\n      const fileInput = screen.getByTestId('file-input');\n      const zipFile = createMockFile('many-files.zip', 'application/zip', 1024);\n      \n      const startTime = performance.now();\n      \n      fireEvent.change(fileInput, { target: { files: [zipFile] } });\n\n      await waitFor(() => {\n        expect(screen.getByTestId('virtual-file-tree')).toBeInTheDocument();\n      });\n\n      const endTime = performance.now();\n      const renderTime = endTime - startTime;\n\n      // è™šæ‹Ÿæ»šåŠ¨åº”è¯¥åœ¨åˆç†æ—¶é—´å†…æ¸²æŸ“\n      expect(renderTime).toBeLessThan(2000);\n\n      // åº”è¯¥åªæ¸²æŸ“å¯è§†åŒºåŸŸçš„æ–‡ä»¶\n      const visibleItems = screen.getAllByTestId('file-item');\n      expect(visibleItems.length).toBeLessThan(100); // è¿œå°‘äº10000ä¸ª\n    });\n\n    it('åº”è¯¥å®ç°é¢„è§ˆå†…å®¹çš„ç¼“å­˜', async () => {\n      const mockArchiveData = {\n        id: 'cache-test',\n        name: 'test.zip',\n        format: 'zip',\n        structure: [\n          {\n            name: 'cached.txt',\n            type: 'file',\n            size: 1000,\n            path: 'cached.txt',\n            mimeType: 'text/plain'\n          }\n        ]\n      };\n\n      mockArchiveService.prototype.loadArchive.mockResolvedValue(mockArchiveData);\n      mockArchiveService.prototype.extractFile.mockResolvedValue(\n        new TextEncoder().encode('Cached content')\n      );\n      mockPreviewService.prototype.preview.mockResolvedValue({\n        type: 'text',\n        content: 'Cached content'\n      });\n\n      render(<ArchiveViewer />);\n\n      const fileInput = screen.getByTestId('file-input');\n      const zipFile = createMockFile('test.zip', 'application/zip', 1024);\n      \n      fireEvent.change(fileInput, { target: { files: [zipFile] } });\n\n      await waitFor(() => {\n        expect(screen.getByText('cached.txt')).toBeInTheDocument();\n      });\n\n      // ç¬¬ä¸€æ¬¡ç‚¹å‡»\n      const cachedFile = screen.getByText('cached.txt');\n      fireEvent.click(cachedFile);\n\n      await waitFor(() => {\n        expect(screen.getByText('Cached content')).toBeInTheDocument();\n      });\n\n      // ç‚¹å‡»å…¶ä»–åœ°æ–¹ç„¶åå†å›æ¥\n      fireEvent.click(screen.getByTestId('file-tree'));\n      fireEvent.click(cachedFile);\n\n      // ç¬¬äºŒæ¬¡åº”è¯¥æ›´å¿«ï¼ˆä½¿ç”¨ç¼“å­˜ï¼‰\n      await waitFor(() => {\n        expect(screen.getByText('Cached content')).toBeInTheDocument();\n      });\n\n      // é¢„è§ˆæœåŠ¡åº”è¯¥åªè¢«è°ƒç”¨ä¸€æ¬¡ï¼ˆç¬¬äºŒæ¬¡ä½¿ç”¨ç¼“å­˜ï¼‰\n      expect(mockPreviewService.prototype.preview).toHaveBeenCalledTimes(1);\n    });\n  });\n\n  describe('çŠ¶æ€ç®¡ç†é›†æˆ', () => {\n    it('åº”è¯¥æ­£ç¡®ç®¡ç†å¤šä¸ªå‹ç¼©åŒ…çš„çŠ¶æ€', async () => {\n      const archive1Data = {\n        id: 'archive-1',\n        name: 'first.zip',\n        format: 'zip',\n        structure: [{ name: 'file1.txt', type: 'file', size: 100, path: 'file1.txt' }]\n      };\n\n      const archive2Data = {\n        id: 'archive-2',\n        name: 'second.zip',\n        format: 'zip',\n        structure: [{ name: 'file2.txt', type: 'file', size: 200, path: 'file2.txt' }]\n      };\n\n      mockArchiveService.prototype.loadArchive\n        .mockResolvedValueOnce(archive1Data)\n        .mockResolvedValueOnce(archive2Data);\n\n      render(<ArchiveViewer />);\n\n      const fileInput = screen.getByTestId('file-input');\n\n      // ä¸Šä¼ ç¬¬ä¸€ä¸ªæ–‡ä»¶\n      const firstZip = createMockFile('first.zip', 'application/zip', 1024);\n      fireEvent.change(fileInput, { target: { files: [firstZip] } });\n\n      await waitFor(() => {\n        expect(screen.getByText('file1.txt')).toBeInTheDocument();\n      });\n\n      // ä¸Šä¼ ç¬¬äºŒä¸ªæ–‡ä»¶\n      const secondZip = createMockFile('second.zip', 'application/zip', 2048);\n      fireEvent.change(fileInput, { target: { files: [secondZip] } });\n\n      await waitFor(() => {\n        expect(screen.getByText('file2.txt')).toBeInTheDocument();\n      });\n\n      // éªŒè¯å¯ä»¥åœ¨ä¸¤ä¸ªå‹ç¼©åŒ…ä¹‹é—´åˆ‡æ¢\n      const archiveTabs = screen.getAllByTestId('archive-tab');\n      expect(archiveTabs).toHaveLength(2);\n\n      fireEvent.click(archiveTabs[0]);\n      expect(screen.getByText('file1.txt')).toBeInTheDocument();\n\n      fireEvent.click(archiveTabs[1]);\n      expect(screen.getByText('file2.txt')).toBeInTheDocument();\n    });\n\n    it('åº”è¯¥æŒä¹…åŒ–ç”¨æˆ·åå¥½è®¾ç½®', async () => {\n      mockStorageService.prototype.getPreferences.mockResolvedValue({\n        theme: 'dark',\n        defaultPreviewMode: 'hex',\n        autoExtract: false\n      });\n\n      render(<ArchiveViewer />);\n\n      // éªŒè¯åå¥½è®¾ç½®è¢«åº”ç”¨\n      const container = screen.getByTestId('archive-viewer');\n      expect(container).toHaveClass('dark-theme');\n\n      // ä¿®æ”¹è®¾ç½®\n      const settingsButton = screen.getByTestId('settings-button');\n      fireEvent.click(settingsButton);\n\n      const themeToggle = screen.getByTestId('theme-toggle');\n      fireEvent.click(themeToggle);\n\n      // éªŒè¯è®¾ç½®è¢«ä¿å­˜\n      await waitFor(() => {\n        expect(mockStorageService.prototype.savePreferences).toHaveBeenCalledWith({\n          theme: 'light',\n          defaultPreviewMode: 'hex',\n          autoExtract: false\n        });\n      });\n    });\n  });\n\n  describe('å†…å­˜ç®¡ç†é›†æˆ', () => {\n    it('åº”è¯¥åœ¨ç»„ä»¶å¸è½½æ—¶æ¸…ç†èµ„æº', async () => {\n      const mockArchiveData = {\n        id: 'cleanup-test',\n        name: 'test.zip',\n        format: 'zip',\n        structure: [{ name: 'file.txt', type: 'file', size: 100, path: 'file.txt' }]\n      };\n\n      mockArchiveService.prototype.loadArchive.mockResolvedValue(mockArchiveData);\n      mockArchiveService.prototype.destroy = vi.fn();\n\n      const { unmount } = render(<ArchiveViewer />);\n\n      const fileInput = screen.getByTestId('file-input');\n      const zipFile = createMockFile('test.zip', 'application/zip', 1024);\n      \n      fireEvent.change(fileInput, { target: { files: [zipFile] } });\n\n      await waitFor(() => {\n        expect(screen.getByText('file.txt')).toBeInTheDocument();\n      });\n\n      // å¸è½½ç»„ä»¶\n      unmount();\n\n      // éªŒè¯èµ„æºè¢«æ¸…ç†\n      expect(mockArchiveService.prototype.destroy).toHaveBeenCalled();\n    });\n\n    it('åº”è¯¥åœ¨å†…å­˜å‹åŠ›ä¸‹è‡ªåŠ¨æ¸…ç†ç¼“å­˜', async () => {\n      const mockArchiveData = {\n        id: 'memory-test',\n        name: 'test.zip',\n        format: 'zip',\n        structure: [{ name: 'large.txt', type: 'file', size: 50 * 1024 * 1024, path: 'large.txt' }]\n      };\n\n      mockArchiveService.prototype.loadArchive.mockResolvedValue(mockArchiveData);\n      \n      // æ¨¡æ‹Ÿå†…å­˜ä¸è¶³\n      const originalMemory = (performance as any).memory;\n      Object.defineProperty(performance, 'memory', {\n        value: {\n          usedJSHeapSize: 500 * 1024 * 1024, // 500MB used\n          totalJSHeapSize: 512 * 1024 * 1024, // 512MB total\n          jsHeapSizeLimit: 512 * 1024 * 1024\n        },\n        configurable: true\n      });\n\n      render(<ArchiveViewer />);\n\n      const fileInput = screen.getByTestId('file-input');\n      const zipFile = createMockFile('test.zip', 'application/zip', 1024);\n      \n      fireEvent.change(fileInput, { target: { files: [zipFile] } });\n\n      await waitFor(() => {\n        expect(screen.getByTestId('memory-warning')).toBeInTheDocument();\n      });\n\n      // æ¢å¤åŸå§‹memoryå¯¹è±¡\n      Object.defineProperty(performance, 'memory', { value: originalMemory });\n    });\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/tests/integration/zip-rar-integration.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'TestDataGenerator' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":40},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'file' is defined but never used. Allowed unused args must match /^_/u.","line":228,"column":63,"nodeType":null,"messageId":"unusedVar","endLine":228,"endColumn":67},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'file' is defined but never used. Allowed unused args must match /^_/u.","line":258,"column":63,"nodeType":null,"messageId":"unusedVar","endLine":258,"endColumn":67},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'file' is defined but never used. Allowed unused args must match /^_/u.","line":289,"column":63,"nodeType":null,"messageId":"unusedVar","endLine":289,"endColumn":67},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'options' is defined but never used. Allowed unused args must match /^_/u.","line":289,"column":69,"nodeType":null,"messageId":"unusedVar","endLine":289,"endColumn":76},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'lastError' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":315,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":315,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'file' is defined but never used. Allowed unused args must match /^_/u.","line":377,"column":65,"nodeType":null,"messageId":"unusedVar","endLine":377,"endColumn":69},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'i' is defined but never used. Allowed unused args must match /^_/u.","line":438,"column":56,"nodeType":null,"messageId":"unusedVar","endLine":438,"endColumn":57}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';\nimport { TestHelpers, TestDataGenerator } from '@tests/utils/test-helpers';\nimport { PerformanceHelpers } from '@tests/utils/performance-helpers';\n\n/**\n * ZIPå’ŒRARæ ¼å¼é›†æˆæµ‹è¯•\n * æµ‹è¯•çœŸå®åœºæ™¯ä¸‹çš„æ ¼å¼å¤„ç†å’Œç”¨æˆ·å·¥ä½œæµ\n */\ndescribe('ZIP/RAR é›†æˆæµ‹è¯•', () => {\n  let archiveService: any;\n  let fileUploadService: any;\n  let previewService: any;\n\n  beforeEach(() => {\n    // æ¨¡æ‹Ÿé›†æˆæœåŠ¡\n    archiveService = {\n      processArchive: vi.fn(),\n      extractAll: vi.fn(),\n      extractSelected: vi.fn(),\n      validateFormat: vi.fn()\n    };\n\n    fileUploadService = {\n      uploadFile: vi.fn(),\n      validateFile: vi.fn(),\n      getUploadProgress: vi.fn()\n    };\n\n    previewService = {\n      generatePreview: vi.fn(),\n      previewFile: vi.fn(),\n      getThumbnail: vi.fn()\n    };\n  });\n\n  afterEach(() => {\n    vi.clearAllMocks();\n  });\n\n  describe('ç”¨æˆ·å®Œæ•´å·¥ä½œæµæµ‹è¯•', () => {\n    it('åº”è¯¥å®ŒæˆZIPæ–‡ä»¶çš„å®Œæ•´å¤„ç†æµç¨‹', async () => {\n      // å‡†å¤‡æµ‹è¯•æ•°æ®\n      const zipFile = TestHelpers.createMockArchiveFile('zip', 2 * 1024 * 1024); // 2MB\n      const mockFileStructure = [\n        { name: 'document.pdf', size: 500 * 1024, type: 'application/pdf' },\n        { name: 'image.jpg', size: 200 * 1024, type: 'image/jpeg' },\n        { name: 'text.txt', size: 10 * 1024, type: 'text/plain' },\n        { name: 'folder/', size: 0, isDirectory: true }\n      ];\n\n      // 1. æ–‡ä»¶ä¸Šä¼ \n      fileUploadService.uploadFile.mockResolvedValue({\n        fileId: 'zip-123',\n        status: 'uploaded',\n        format: 'zip'\n      });\n\n      // 2. æ ¼å¼éªŒè¯\n      archiveService.validateFormat.mockResolvedValue({\n        isValid: true,\n        format: 'zip',\n        version: '2.0',\n        fileCount: 4\n      });\n\n      // 3. æ–‡ä»¶ç»“æ„è§£æ\n      archiveService.processArchive.mockResolvedValue({\n        structure: mockFileStructure,\n        totalSize: 710 * 1024,\n        compressionRatio: 0.65\n      });\n\n      // 4. é¢„è§ˆç”Ÿæˆ\n      previewService.generatePreview.mockResolvedValue({\n        previews: [\n          { name: 'document.pdf', thumbnail: 'data:image/png;base64,...' },\n          { name: 'image.jpg', thumbnail: 'data:image/jpeg;base64,...' },\n          { name: 'text.txt', preview: 'Text file content preview...' }\n        ]\n      });\n\n      // æ‰§è¡Œå®Œæ•´æµç¨‹\n      const uploadResult = await fileUploadService.uploadFile(zipFile);\n      expect(uploadResult.format).toBe('zip');\n\n      const validationResult = await archiveService.validateFormat(zipFile);\n      expect(validationResult.isValid).toBe(true);\n\n      const processResult = await archiveService.processArchive(zipFile);\n      expect(processResult.structure).toHaveLength(4);\n\n      const previewResult = await previewService.generatePreview(processResult.structure);\n      expect(previewResult.previews).toHaveLength(3); // ä¸åŒ…æ‹¬ç›®å½•\n    });\n\n    it('åº”è¯¥å®ŒæˆRARæ–‡ä»¶çš„å®Œæ•´å¤„ç†æµç¨‹', async () => {\n      // å‡†å¤‡RARæµ‹è¯•æ•°æ®\n      const rarFile = TestHelpers.createMockArchiveFile('rar', 5 * 1024 * 1024); // 5MB\n      const mockRarStructure = [\n        { name: 'video.mp4', size: 4 * 1024 * 1024, type: 'video/mp4', isSolid: true },\n        { name: 'subtitle.srt', size: 50 * 1024, type: 'text/plain', isSolid: true },\n        { name: 'readme.txt', size: 5 * 1024, type: 'text/plain', isSolid: true }\n      ];\n\n      // RARç‰¹å®šçš„å¤„ç†æµç¨‹\n      fileUploadService.uploadFile.mockResolvedValue({\n        fileId: 'rar-456',\n        status: 'uploaded',\n        format: 'rar'\n      });\n\n      archiveService.validateFormat.mockResolvedValue({\n        isValid: true,\n        format: 'rar',\n        version: '5.0',\n        isSolid: true,\n        hasRecoveryRecord: true\n      });\n\n      archiveService.processArchive.mockResolvedValue({\n        structure: mockRarStructure,\n        totalSize: 4 * 1024 * 1024 + 55 * 1024,\n        compressionRatio: 0.85,\n        solidCompression: true\n      });\n\n      // æ‰§è¡ŒRARæµç¨‹\n      const uploadResult = await fileUploadService.uploadFile(rarFile);\n      expect(uploadResult.format).toBe('rar');\n\n      const validationResult = await archiveService.validateFormat(rarFile);\n      expect(validationResult.isSolid).toBe(true);\n      expect(validationResult.hasRecoveryRecord).toBe(true);\n\n      const processResult = await archiveService.processArchive(rarFile);\n      expect(processResult.solidCompression).toBe(true);\n      expect(processResult.structure.every(file => file.isSolid)).toBe(true);\n    });\n  });\n\n  describe('å¯†ç ä¿æŠ¤æ–‡ä»¶å¤„ç†', () => {\n    it('åº”è¯¥æ­£ç¡®å¤„ç†å¯†ç ä¿æŠ¤çš„ZIPæ–‡ä»¶', async () => {\n      const passwordZip = TestHelpers.createMockArchiveFile('zip', 1024 * 1024);\n      const correctPassword = 'test123!';\n\n      // æ¨¡æ‹Ÿå¯†ç æ£€æµ‹\n      archiveService.validateFormat.mockResolvedValue({\n        isValid: true,\n        format: 'zip',\n        isPasswordProtected: true,\n        encryptedFileNames: false\n      });\n\n      // æ¨¡æ‹Ÿå¯†ç éªŒè¯æµç¨‹\n      archiveService.processArchive.mockImplementation(async (file, options) => {\n        if (options?.password === correctPassword) {\n          return {\n            structure: [\n              { name: 'secret.txt', size: 1024, isEncrypted: true }\n            ],\n            passwordVerified: true\n          };\n        }\n        throw new Error('Wrong password');\n      });\n\n      // é”™è¯¯å¯†ç æµ‹è¯•\n      await expect(\n        archiveService.processArchive(passwordZip, { password: 'wrong' })\n      ).rejects.toThrow('Wrong password');\n\n      // æ­£ç¡®å¯†ç æµ‹è¯•\n      const result = await archiveService.processArchive(passwordZip, { \n        password: correctPassword \n      });\n      expect(result.passwordVerified).toBe(true);\n      expect(result.structure[0].isEncrypted).toBe(true);\n    });\n\n    it('åº”è¯¥æ­£ç¡®å¤„ç†RARæ–‡ä»¶ååŠ å¯†', async () => {\n      const encryptedRar = TestHelpers.createMockArchiveFile('rar', 2 * 1024 * 1024);\n      const password = 'secure456';\n\n      archiveService.validateFormat.mockResolvedValue({\n        isValid: true,\n        format: 'rar',\n        isPasswordProtected: true,\n        encryptedFileNames: true // RARç‰¹æœ‰åŠŸèƒ½\n      });\n\n      archiveService.processArchive.mockImplementation(async (file, options) => {\n        if (options?.password === password) {\n          return {\n            structure: [\n              { name: 'confidential.doc', size: 500 * 1024, isEncrypted: true },\n              { name: 'private/', size: 0, isDirectory: true, isEncrypted: true }\n            ],\n            fileNamesDecrypted: true\n          };\n        }\n        // æ–‡ä»¶ååŠ å¯†æ—¶æ— æ³•è·å–æ–‡ä»¶åˆ—è¡¨\n        return {\n          structure: [],\n          fileNamesEncrypted: true,\n          needsPassword: true\n        };\n      });\n\n      // æ²¡æœ‰å¯†ç æ—¶æ— æ³•è·å–æ–‡ä»¶åˆ—è¡¨\n      const noPasswordResult = await archiveService.processArchive(encryptedRar);\n      expect(noPasswordResult.fileNamesEncrypted).toBe(true);\n      expect(noPasswordResult.structure).toHaveLength(0);\n\n      // æœ‰å¯†ç æ—¶å¯ä»¥è·å–å®Œæ•´ç»“æ„\n      const withPasswordResult = await archiveService.processArchive(encryptedRar, { \n        password \n      });\n      expect(withPasswordResult.fileNamesDecrypted).toBe(true);\n      expect(withPasswordResult.structure).toHaveLength(2);\n    });\n  });\n\n  describe('å¤§æ–‡ä»¶å¤„ç†æ€§èƒ½æµ‹è¯•', () => {\n    it('åº”è¯¥é«˜æ•ˆå¤„ç†å¤§å‹ZIPæ–‡ä»¶', async () => {\n      const largeZip = TestHelpers.createMockArchiveFile('zip', 100 * 1024 * 1024); // 100MB\n      \n      // æ¨¡æ‹Ÿå¤§æ–‡ä»¶å¤„ç†\n      archiveService.processArchive.mockImplementation(async (file) => {\n        // æ¨¡æ‹Ÿå¤„ç†æ—¶é—´\n        await TestHelpers.waitForAsync(500);\n        \n        return {\n          structure: Array.from({ length: 1000 }, (_, i) => ({\n            name: `file-${i}.txt`,\n            size: 100 * 1024, // 100KB each\n            path: `folder-${Math.floor(i / 100)}/file-${i}.txt`\n          })),\n          totalSize: 100 * 1024 * 1024,\n          processingTime: 500\n        };\n      });\n\n      const performanceTest = PerformanceHelpers.expectPerformance(\n        () => archiveService.processArchive(largeZip),\n        {\n          maxDuration: 2000, // 2ç§’å†…å®Œæˆ\n          maxMemory: 50 * 1024 * 1024 // æœ€å¤šä½¿ç”¨50MBå†…å­˜\n        }\n      );\n\n      const result = await performanceTest();\n      expect(result.duration).toBeLessThan(2000);\n    });\n\n    it('åº”è¯¥é«˜æ•ˆå¤„ç†RARå›ºå®å‹ç¼©', async () => {\n      const solidRar = TestHelpers.createMockArchiveFile('rar', 200 * 1024 * 1024); // 200MB\n      \n      archiveService.processArchive.mockImplementation(async (file) => {\n        // å›ºå®å‹ç¼©éœ€è¦æŒ‰é¡ºåºå¤„ç†ï¼Œæ¨¡æ‹Ÿè¾ƒé•¿å¤„ç†æ—¶é—´\n        await TestHelpers.waitForAsync(1000);\n        \n        return {\n          structure: Array.from({ length: 500 }, (_, i) => ({\n            name: `solid-file-${i}.bin`,\n            size: 400 * 1024, // 400KB each\n            isSolid: true,\n            solidGroup: 1\n          })),\n          isSolidArchive: true,\n          processingTime: 1000\n        };\n      });\n\n      const startTime = performance.now();\n      const result = await archiveService.processArchive(solidRar);\n      const duration = performance.now() - startTime;\n\n      expect(result.isSolidArchive).toBe(true);\n      expect(result.structure.every(file => file.isSolid)).toBe(true);\n      expect(duration).toBeLessThan(3000); // å›ºå®å‹ç¼©å…è®¸è¾ƒé•¿æ—¶é—´\n    });\n  });\n\n  describe('é”™è¯¯æ¢å¤å’Œé‡è¯•æœºåˆ¶', () => {\n    it('åº”è¯¥æ”¯æŒZIPæ–‡ä»¶çš„é”™è¯¯æ¢å¤', async () => {\n      const corruptedZip = TestHelpers.createMockArchiveFile('zip', 1024 * 1024);\n      let attemptCount = 0;\n\n      archiveService.processArchive.mockImplementation(async (file, options) => {\n        attemptCount++;\n        \n        if (attemptCount <= 2) {\n          throw new Error('CRC error in central directory');\n        }\n        \n        // ç¬¬ä¸‰æ¬¡å°è¯•æˆåŠŸ\n        return {\n          structure: [\n            { name: 'recovered.txt', size: 1024, isPartiallyRecovered: true }\n          ],\n          recoveryAttempts: attemptCount,\n          partialRecovery: true\n        };\n      });\n\n      // å®ç°é‡è¯•é€»è¾‘\n      let lastError;\n      let result;\n      \n      for (let i = 0; i < 3; i++) {\n        try {\n          result = await archiveService.processArchive(corruptedZip);\n          break;\n        } catch (error) {\n          lastError = error;\n          await TestHelpers.waitForAsync(100); // é‡è¯•å»¶è¿Ÿ\n        }\n      }\n\n      expect(result).toBeDefined();\n      expect(result.partialRecovery).toBe(true);\n      expect(result.recoveryAttempts).toBe(3);\n    });\n\n    it('åº”è¯¥æ”¯æŒRARæ¢å¤è®°å½•åŠŸèƒ½', async () => {\n      const damagedRar = TestHelpers.createMockArchiveFile('rar', 2 * 1024 * 1024);\n\n      archiveService.validateFormat.mockResolvedValue({\n        isValid: false,\n        format: 'rar',\n        hasRecoveryRecord: true,\n        isDamaged: true\n      });\n\n      archiveService.processArchive.mockImplementation(async (file, options) => {\n        if (options?.useRecoveryRecord) {\n          return {\n            structure: [\n              { name: 'recovered-file.txt', size: 1024, isRecovered: true }\n            ],\n            usedRecoveryRecord: true,\n            recoverySuccess: true\n          };\n        }\n        throw new Error('Archive is damaged');\n      });\n\n      // æ™®é€šå¤„ç†å¤±è´¥\n      await expect(\n        archiveService.processArchive(damagedRar)\n      ).rejects.toThrow('Archive is damaged');\n\n      // ä½¿ç”¨æ¢å¤è®°å½•æˆåŠŸ\n      const result = await archiveService.processArchive(damagedRar, { \n        useRecoveryRecord: true \n      });\n      \n      expect(result.usedRecoveryRecord).toBe(true);\n      expect(result.recoverySuccess).toBe(true);\n      expect(result.structure[0].isRecovered).toBe(true);\n    });\n  });\n\n  describe('å¤šæ ¼å¼åŒæ—¶å¤„ç†', () => {\n    it('åº”è¯¥èƒ½åŒæ—¶å¤„ç†å¤šä¸ªä¸åŒæ ¼å¼çš„æ–‡ä»¶', async () => {\n      const files = [\n        TestHelpers.createMockArchiveFile('zip', 1024 * 1024),\n        TestHelpers.createMockArchiveFile('rar', 2 * 1024 * 1024),\n        TestHelpers.createMockArchiveFile('zip', 512 * 1024)\n      ];\n\n      const processResults = [];\n\n      for (const [index, file] of files.entries()) {\n        const format = file.name.includes('zip') ? 'zip' : 'rar';\n        \n        archiveService.processArchive.mockImplementation(async (file) => {\n          await TestHelpers.waitForAsync(100 + index * 50); // æ¨¡æ‹Ÿä¸åŒå¤„ç†æ—¶é—´\n          \n          return {\n            fileId: `file-${index}`,\n            format,\n            structure: [\n              { name: `${format}-file-${index}.txt`, size: 1024 }\n            ],\n            processingOrder: index\n          };\n        });\n\n        const result = await archiveService.processArchive(file);\n        processResults.push(result);\n      }\n\n      expect(processResults).toHaveLength(3);\n      expect(processResults[0].format).toBe('zip');\n      expect(processResults[1].format).toBe('rar');\n      expect(processResults[2].format).toBe('zip');\n    });\n\n    it('åº”è¯¥æ”¯æŒæ‰¹é‡æ–‡ä»¶çš„å¹¶è¡Œå¤„ç†', async () => {\n      const batchFiles = Array.from({ length: 5 }, (_, i) => \n        TestHelpers.createMockArchiveFile(i % 2 === 0 ? 'zip' : 'rar', 1024 * 1024)\n      );\n\n      archiveService.processArchive.mockImplementation(async (file, options) => {\n        const format = file.name.includes('zip') ? 'zip' : 'rar';\n        await TestHelpers.waitForAsync(200); // æ¯ä¸ªæ–‡ä»¶200mså¤„ç†æ—¶é—´\n        \n        return {\n          format,\n          processedAt: Date.now(),\n          batchId: options?.batchId\n        };\n      });\n\n      // å¹¶è¡Œå¤„ç†\n      const startTime = Date.now();\n      const promises = batchFiles.map((file, index) => \n        archiveService.processArchive(file, { batchId: `batch-${index}` })\n      );\n      \n      const results = await Promise.all(promises);\n      const totalTime = Date.now() - startTime;\n\n      expect(results).toHaveLength(5);\n      expect(totalTime).toBeLessThan(500); // å¹¶è¡Œå¤„ç†åº”è¯¥è¿œå¿«äºé¡ºåºå¤„ç† (5 * 200ms)\n      \n      // éªŒè¯ä¸åŒæ ¼å¼éƒ½è¢«æ­£ç¡®å¤„ç†\n      const zipCount = results.filter(r => r.format === 'zip').length;\n      const rarCount = results.filter(r => r.format === 'rar').length;\n      expect(zipCount).toBe(3); // ç´¢å¼• 0, 2, 4\n      expect(rarCount).toBe(2); // ç´¢å¼• 1, 3\n    });\n  });\n\n  describe('å†…å­˜ç®¡ç†å’Œæ¸…ç†', () => {\n    it('åº”è¯¥åœ¨å¤„ç†å®Œæˆåæ­£ç¡®æ¸…ç†å†…å­˜', async () => {\n      const largeFiles = Array.from({ length: 3 }, (_, i) => \n        TestHelpers.createMockArchiveFile('zip', 50 * 1024 * 1024) // 50MB each\n      );\n\n      const initialMemory = performance.memory?.usedJSHeapSize || 0;\n      \n      for (const file of largeFiles) {\n        archiveService.processArchive.mockImplementation(async () => {\n          // æ¨¡æ‹Ÿå†…å­˜ä½¿ç”¨\n          const tempBuffer = new ArrayBuffer(20 * 1024 * 1024); // ä¸´æ—¶ä½¿ç”¨20MB\n          \n          return {\n            structure: [{ name: 'test.txt', size: 1024 }],\n            tempBuffer // è¿™ä¼šè¢«æ¸…ç†\n          };\n        });\n\n        const result = await archiveService.processArchive(file);\n        \n        // æ¨¡æ‹Ÿæ¸…ç†é€»è¾‘\n        delete result.tempBuffer;\n        \n        // å¼ºåˆ¶åƒåœ¾å›æ”¶ (æµ‹è¯•ç¯å¢ƒ)\n        if (global.gc) {\n          global.gc();\n        }\n      }\n\n      await TestHelpers.waitForAsync(100); // ç­‰å¾…å¼‚æ­¥æ¸…ç†å®Œæˆ\n      \n      const finalMemory = performance.memory?.usedJSHeapSize || 0;\n      const memoryIncrease = finalMemory - initialMemory;\n      \n      // å†…å­˜å¢é•¿åº”è¯¥å¾ˆå°ï¼Œè¯´æ˜æ¸…ç†æœ‰æ•ˆ\n      expect(memoryIncrease).toBeLessThan(10 * 1024 * 1024); // å°äº10MB\n    });\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/tests/setup.ts","messages":[{"ruleId":"@typescript-eslint/no-namespace","severity":2,"message":"ES2015 module syntax is preferred over namespaces.","line":10,"column":3,"nodeType":"TSModuleDeclaration","messageId":"moduleSyntaxIsPreferred","endLine":15,"endColumn":4},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":31,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":31,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[630,633],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[630,633],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":37,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":37,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[774,777],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[774,777],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":37,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":37,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[804,807],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[804,807],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":69,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":69,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1698,1701],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1698,1701],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":73,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":73,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1795,1798],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1795,1798],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":73,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":73,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1816,1819],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1816,1819],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":103,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":103,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2640,2643],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2640,2643],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":105,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":105,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2721,2724],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2721,2724],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":106,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":106,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2746,2749],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2746,2749],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":108,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":108,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2788,2791],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2788,2791],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":109,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":109,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2841,2844],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2841,2844],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":110,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":110,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2898,2901],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2898,2901],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":111,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":111,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2953,2956],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2953,2956],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":112,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":112,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3009,3012],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3009,3012],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":113,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":113,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3062,3065],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3062,3065],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'file' is defined but never used. Allowed unused args must match /^_/u.","line":115,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":115,"endColumn":22},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":115,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":115,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3121,3124],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3121,3124],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'file' is defined but never used. Allowed unused args must match /^_/u.","line":123,"column":25,"nodeType":null,"messageId":"unusedVar","endLine":123,"endColumn":29},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":123,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":123,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3334,3337],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3334,3337],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'file' is defined but never used. Allowed unused args must match /^_/u.","line":131,"column":21,"nodeType":null,"messageId":"unusedVar","endLine":131,"endColumn":25},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":131,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":131,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3542,3545],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3542,3545],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":148,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":148,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3965,3968],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3965,3968],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":156,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":156,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4155,4158],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4155,4158],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":157,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":157,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4210,4213],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4210,4213],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":158,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":158,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4263,4266],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4263,4266],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'scriptURL' is defined but never used. Allowed unused args must match /^_/u.","line":160,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":160,"endColumn":28},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'data' is defined but never used. Allowed unused args must match /^_/u.","line":166,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":166,"endColumn":23},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":166,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":166,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4476,4479],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4476,4479],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":180,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":180,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4811,4814],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4811,4814],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":185,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":185,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4934,4937],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4934,4937],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":186,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":186,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4979,4982],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4979,4982],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":198,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":198,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5310,5313],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5310,5313],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":212,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":212,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5689,5692],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5689,5692],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'callback' is defined but never used. Allowed unused args must match /^_/u.","line":213,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":213,"endColumn":27},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":213,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":213,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5762,5765],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5762,5765],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":222,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":222,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5948,5951],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5948,5951],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'callback' is defined but never used. Allowed unused args must match /^_/u.","line":223,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":223,"endColumn":27},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":223,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":223,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6033,6036],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6033,6036],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'options' is defined but never used. Allowed unused args must match /^_/u.","line":223,"column":34,"nodeType":null,"messageId":"unusedVar","endLine":223,"endColumn":41},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":223,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":223,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6048,6051],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6048,6051],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":232,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":232,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6226,6229],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6226,6229],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'callback' is defined but never used. Allowed unused args must match /^_/u.","line":233,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":233,"endColumn":27},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":233,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":233,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6303,6306],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6303,6306],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":242,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":242,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6485,6488],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6485,6488],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":257,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":257,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6889,6892],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6889,6892],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":291,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":291,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7904,7907],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7904,7907],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":296,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":296,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8039,8042],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8039,8042],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":301,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":301,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8169,8172],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8169,8172],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":329,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":329,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8752,8755],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8752,8755],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":366,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":366,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9529,9532],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9529,9532],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":367,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":367,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9560,9563],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9560,9563],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":368,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":368,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9591,9594],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9591,9594],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":369,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":369,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9628,9631],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9628,9631],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":383,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":383,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9932,9935],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9932,9935],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":417,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":417,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10800,10803],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10800,10803],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":435,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":435,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11352,11355],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11352,11355],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":10,"fatalErrorCount":0,"warningCount":47,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import '@testing-library/jest-dom';\nimport { vi, beforeAll, afterAll, beforeEach, afterEach } from 'vitest';\n\n// æ‰©å±•å…¨å±€å¯¹è±¡\ndeclare global {\n  interface Window {\n    __TEST__: boolean;\n  }\n  \n  namespace NodeJS {\n    interface Global {\n      TextEncoder: typeof TextEncoder;\n      TextDecoder: typeof TextDecoder;\n    }\n  }\n}\n\n// è®¾ç½®æµ‹è¯•ç¯å¢ƒæ ‡è¯†\nwindow.__TEST__ = true;\n\n// æ¨¡æ‹Ÿæµè§ˆå™¨API\nbeforeAll(() => {\n  // æ¨¡æ‹Ÿ TextEncoder/TextDecoder\n  if (typeof global.TextEncoder === 'undefined') {\n    global.TextEncoder = TextEncoder;\n    global.TextDecoder = TextDecoder;\n  }\n\n  // æ¨¡æ‹Ÿ File API\n  if (typeof window.File === 'undefined') {\n    (global as any).File = class File {\n      name: string;\n      size: number;\n      type: string;\n      lastModified: number;\n      \n      constructor(bits: any[], name: string, options: any = {}) {\n        this.name = name;\n        this.type = options.type || '';\n        this.lastModified = options.lastModified || Date.now();\n        this.size = bits.reduce((size, bit) => {\n          if (typeof bit === 'string') {return size + bit.length;}\n          if (bit instanceof ArrayBuffer) {return size + bit.byteLength;}\n          if (ArrayBuffer.isView(bit)) {return size + bit.byteLength;}\n          return size;\n        }, 0);\n      }\n      \n      slice(start?: number, end?: number, contentType?: string) {\n        return new Blob([], { type: contentType });\n      }\n      \n      stream() {\n        return new ReadableStream();\n      }\n      \n      text() {\n        return Promise.resolve('');\n      }\n      \n      arrayBuffer() {\n        return Promise.resolve(new ArrayBuffer(0));\n      }\n    };\n  }\n\n  // æ¨¡æ‹Ÿ Blob API\n  if (typeof window.Blob === 'undefined') {\n    (global as any).Blob = class Blob {\n      size: number;\n      type: string;\n      \n      constructor(parts: any[] = [], options: any = {}) {\n        this.type = options.type || '';\n        this.size = parts.reduce((size, part) => {\n          if (typeof part === 'string') {return size + part.length;}\n          if (part instanceof ArrayBuffer) {return size + part.byteLength;}\n          if (ArrayBuffer.isView(part)) {return size + part.byteLength;}\n          return size;\n        }, 0);\n      }\n      \n      slice(start?: number, end?: number, contentType?: string) {\n        return new Blob([], { type: contentType });\n      }\n      \n      stream() {\n        return new ReadableStream();\n      }\n      \n      text() {\n        return Promise.resolve('');\n      }\n      \n      arrayBuffer() {\n        return Promise.resolve(new ArrayBuffer(0));\n      }\n    };\n  }\n\n  // æ¨¡æ‹Ÿ FileReader API\n  if (typeof window.FileReader === 'undefined') {\n    (global as any).FileReader = class FileReader {\n      readyState: number = 0;\n      result: any = null;\n      error: any = null;\n      \n      onload: ((event: any) => void) | null = null;\n      onerror: ((event: any) => void) | null = null;\n      onloadstart: ((event: any) => void) | null = null;\n      onloadend: ((event: any) => void) | null = null;\n      onprogress: ((event: any) => void) | null = null;\n      onabort: ((event: any) => void) | null = null;\n      \n      readAsText(file: any) {\n        setTimeout(() => {\n          this.result = 'mock file content';\n          this.readyState = 2;\n          this.onload?.({ target: this });\n        }, 0);\n      }\n      \n      readAsArrayBuffer(file: any) {\n        setTimeout(() => {\n          this.result = new ArrayBuffer(0);\n          this.readyState = 2;\n          this.onload?.({ target: this });\n        }, 0);\n      }\n      \n      readAsDataURL(file: any) {\n        setTimeout(() => {\n          this.result = 'data:text/plain;base64,';\n          this.readyState = 2;\n          this.onload?.({ target: this });\n        }, 0);\n      }\n      \n      abort() {\n        this.readyState = 2;\n        this.onabort?.({ target: this });\n      }\n    };\n  }\n\n  // æ¨¡æ‹Ÿ URL API\n  if (typeof window.URL === 'undefined' || typeof window.URL.createObjectURL === 'undefined') {\n    (global as any).URL = {\n      createObjectURL: vi.fn(() => 'blob:mock-url'),\n      revokeObjectURL: vi.fn()\n    };\n  }\n\n  // æ¨¡æ‹Ÿ Web Workers\n  if (typeof window.Worker === 'undefined') {\n    (global as any).Worker = class Worker {\n      onmessage: ((event: any) => void) | null = null;\n      onerror: ((event: any) => void) | null = null;\n      \n      constructor(scriptURL: string) {\n        setTimeout(() => {\n          this.onmessage?.({ data: { type: 'ready' } });\n        }, 0);\n      }\n      \n      postMessage(data: any) {\n        setTimeout(() => {\n          this.onmessage?.({ data: { type: 'response', result: 'mock result' } });\n        }, 10);\n      }\n      \n      terminate() {\n        // Mock implementation\n      }\n    };\n  }\n\n  // æ¨¡æ‹Ÿ SharedArrayBuffer (ç”¨äºWebAssemblyæµ‹è¯•)\n  if (typeof window.SharedArrayBuffer === 'undefined') {\n    (global as any).SharedArrayBuffer = ArrayBuffer;\n  }\n\n  // æ¨¡æ‹Ÿ crypto API\n  if (typeof window.crypto === 'undefined') {\n    (global as any).crypto = {\n      getRandomValues: (arr: any) => {\n        for (let i = 0; i < arr.length; i++) {\n          arr[i] = Math.floor(Math.random() * 256);\n        }\n        return arr;\n      },\n      randomUUID: () => `mock-uuid-${  Math.random().toString(36).substr(2, 9)}`\n    };\n  }\n\n  // æ¨¡æ‹Ÿ performance API\n  if (typeof window.performance === 'undefined') {\n    (global as any).performance = {\n      now: () => Date.now(),\n      memory: {\n        usedJSHeapSize: 10 * 1024 * 1024,\n        totalJSHeapSize: 50 * 1024 * 1024,\n        jsHeapSizeLimit: 2 * 1024 * 1024 * 1024\n      },\n      getEntriesByType: () => [],\n      getEntriesByName: () => []\n    };\n  }\n\n  // æ¨¡æ‹Ÿ ResizeObserver\n  if (typeof window.ResizeObserver === 'undefined') {\n    (global as any).ResizeObserver = class ResizeObserver {\n      constructor(callback: any) {}\n      observe() {}\n      unobserve() {}\n      disconnect() {}\n    };\n  }\n\n  // æ¨¡æ‹Ÿ IntersectionObserver\n  if (typeof window.IntersectionObserver === 'undefined') {\n    (global as any).IntersectionObserver = class IntersectionObserver {\n      constructor(callback: any, options?: any) {}\n      observe() {}\n      unobserve() {}\n      disconnect() {}\n    };\n  }\n\n  // æ¨¡æ‹Ÿ MutationObserver\n  if (typeof window.MutationObserver === 'undefined') {\n    (global as any).MutationObserver = class MutationObserver {\n      constructor(callback: any) {}\n      observe() {}\n      disconnect() {}\n      takeRecords() { return []; }\n    };\n  }\n\n  // æ¨¡æ‹Ÿ navigator API\n  if (typeof window.navigator === 'undefined') {\n    (global as any).navigator = {\n      userAgent: 'Mozilla/5.0 (Test Environment)',\n      language: 'zh-CN',\n      languages: ['zh-CN', 'en'],\n      onLine: true,\n      hardwareConcurrency: 4,\n      deviceMemory: 8,\n      storage: {\n        estimate: () => Promise.resolve({ quota: 1024 * 1024 * 1024, usage: 0 })\n      }\n    };\n  }\n\n  // æ¨¡æ‹Ÿ matchMedia\n  if (typeof window.matchMedia === 'undefined') {\n    (global as any).matchMedia = vi.fn((query: string) => ({\n      matches: false,\n      media: query,\n      onchange: null,\n      addListener: vi.fn(),\n      removeListener: vi.fn(),\n      addEventListener: vi.fn(),\n      removeEventListener: vi.fn(),\n      dispatchEvent: vi.fn()\n    }));\n  }\n\n  // æ¨¡æ‹Ÿ localStorage\n  if (typeof window.localStorage === 'undefined') {\n    const localStorageMock = {\n      store: {} as Record<string, string>,\n      getItem: vi.fn((key: string) => localStorageMock.store[key] || null),\n      setItem: vi.fn((key: string, value: string) => {\n        localStorageMock.store[key] = value;\n      }),\n      removeItem: vi.fn((key: string) => {\n        delete localStorageMock.store[key];\n      }),\n      clear: vi.fn(() => {\n        localStorageMock.store = {};\n      }),\n      get length() {\n        return Object.keys(localStorageMock.store).length;\n      },\n      key: vi.fn((index: number) => {\n        return Object.keys(localStorageMock.store)[index] || null;\n      })\n    };\n    \n    (global as any).localStorage = localStorageMock;\n  }\n\n  // æ¨¡æ‹Ÿ sessionStorage\n  if (typeof window.sessionStorage === 'undefined') {\n    (global as any).sessionStorage = global.localStorage;\n  }\n\n  // æ¨¡æ‹Ÿ IndexedDB\n  if (typeof window.indexedDB === 'undefined') {\n    (global as any).indexedDB = {\n      open: vi.fn(() => ({\n        onsuccess: null,\n        onerror: null,\n        result: {\n          createObjectStore: vi.fn(),\n          transaction: vi.fn(() => ({\n            objectStore: vi.fn(() => ({\n              add: vi.fn(),\n              get: vi.fn(),\n              put: vi.fn(),\n              delete: vi.fn(),\n              clear: vi.fn()\n            }))\n          }))\n        }\n      }))\n    };\n  }\n});\n\n// æ¯ä¸ªæµ‹è¯•å‰çš„è®¾ç½®\nbeforeEach(() => {\n  // æ¸…ç†æ‰€æœ‰æ¨¡æ‹Ÿ\n  vi.clearAllMocks();\n  \n  // é‡ç½®localStorage\n  if (global.localStorage) {\n    (global.localStorage as any).store = {};\n  }\n  \n  // é‡ç½®performance.memory\n  if (global.performance && global.performance.memory) {\n    global.performance.memory.usedJSHeapSize = 10 * 1024 * 1024;\n  }\n  \n  // æ¸…ç†æ§åˆ¶å°è¾“å‡º (åœ¨æµ‹è¯•ä¸­)\n  if (process.env.NODE_ENV === 'test') {\n    vi.spyOn(console, 'log').mockImplementation(() => {});\n    vi.spyOn(console, 'warn').mockImplementation(() => {});\n    vi.spyOn(console, 'error').mockImplementation(() => {});\n  }\n});\n\n// æ¯ä¸ªæµ‹è¯•åçš„æ¸…ç†\nafterEach(() => {\n  // æ¢å¤æ‰€æœ‰æ¨¡æ‹Ÿ\n  vi.restoreAllMocks();\n  \n  // æ¸…ç†DOM\n  document.body.innerHTML = '';\n  \n  // æ¸…ç†å…¨å±€çŠ¶æ€\n  if (window.__TEST__) {\n    // æ¸…ç†å¯èƒ½çš„äº‹ä»¶ç›‘å¬å™¨\n    window.removeEventListener = window.removeEventListener || (() => {});\n  }\n});\n\n// å…¨å±€æ¸…ç†\nafterAll(() => {\n  // æ¸…ç†å…¨å±€æ¨¡æ‹Ÿ\n  vi.clearAllMocks();\n  \n  // é‡ç½®å…¨å±€å¯¹è±¡\n  delete (global as any).File;\n  delete (global as any).Blob;\n  delete (global as any).FileReader;\n  delete (global as any).Worker;\n});\n\n// é”™è¯¯å¤„ç†\nprocess.on('unhandledRejection', (reason) => {\n  console.error('Unhandled Rejection:', reason);\n});\n\nprocess.on('uncaughtException', (error) => {\n  console.error('Uncaught Exception:', error);\n});\n\n// WebAssembly æ¨¡æ‹Ÿ (ç”¨äºæµ‹è¯•)\nif (typeof WebAssembly === 'undefined') {\n  (global as any).WebAssembly = {\n    compile: vi.fn(() => Promise.resolve({})),\n    instantiate: vi.fn(() => Promise.resolve({ \n      instance: { exports: {} },\n      module: {}\n    })),\n    validate: vi.fn(() => true),\n    Module: vi.fn(),\n    Instance: vi.fn(),\n    Memory: vi.fn(),\n    Table: vi.fn(),\n    CompileError: Error,\n    RuntimeError: Error,\n    LinkError: Error\n  };\n}\n\n// è‡ªå®šä¹‰åŒ¹é…å™¨\nexpect.extend({\n  toBeWithinRange(received: number, floor: number, ceiling: number) {\n    const pass = received >= floor && received <= ceiling;\n    if (pass) {\n      return {\n        message: () => `expected ${received} not to be within range ${floor} - ${ceiling}`,\n        pass: true,\n      };\n    } else {\n      return {\n        message: () => `expected ${received} to be within range ${floor} - ${ceiling}`,\n        pass: false,\n      };\n    }\n  },\n  \n  toBeValidArchive(received: any) {\n    const pass = received && \n                 typeof received.id === 'string' &&\n                 typeof received.name === 'string' &&\n                 typeof received.format === 'string' &&\n                 Array.isArray(received.structure);\n    \n    return {\n      message: () => pass \n        ? `expected ${received} not to be a valid archive object`\n        : `expected ${received} to be a valid archive object with id, name, format, and structure`,\n      pass,\n    };\n  }\n});\n\n// ç±»å‹å£°æ˜æ‰©å±•\ndeclare module 'vitest' {\n  interface Assertion<T = any>\n    extends jest.Matchers<void, T> {\n    toBeWithinRange(floor: number, ceiling: number): T;\n    toBeValidArchive(): T;\n  }\n}\n\nexport {};","usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/tests/unit/components/FileUpload.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/tests/unit/formats/rar-format.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'TestDataGenerator' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":40},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'data' is defined but never used. Allowed unused args must match /^_/u.","line":57,"column":55,"nodeType":null,"messageId":"unusedVar","endLine":57,"endColumn":59},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'mockFile' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":144,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":144,"endColumn":23}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';\nimport { TestHelpers, TestDataGenerator } from '@tests/utils/test-helpers';\n\n/**\n * RARæ ¼å¼ä¸“é¡¹æµ‹è¯•\n * è¦†ç›–RARæ ¼å¼çš„å„ç§ç‰¹æ€§å’Œè¾¹ç•Œæƒ…å†µ\n */\ndescribe('RARæ ¼å¼å¤„ç†', () => {\n  let mockRarService: any;\n  let testFile: File;\n\n  beforeEach(() => {\n    // åˆ›å»ºåŸºç¡€RARæµ‹è¯•æ–‡ä»¶\n    testFile = TestHelpers.createMockArchiveFile('rar', 2048);\n    \n    // æ¨¡æ‹ŸRARæœåŠ¡\n    mockRarService = {\n      detectFormat: vi.fn(),\n      extractFiles: vi.fn(),\n      getFileList: vi.fn(),\n      extractSingleFile: vi.fn(),\n      validateArchive: vi.fn(),\n      checkPassword: vi.fn(),\n      getRarVersion: vi.fn(),\n      checkRecoveryRecord: vi.fn()\n    };\n  });\n\n  afterEach(() => {\n    vi.clearAllMocks();\n  });\n\n  describe('RARæ–‡ä»¶æ ¼å¼æ£€æµ‹', () => {\n    it('åº”è¯¥æ­£ç¡®è¯†åˆ«RAR 4.xæ ¼å¼', () => {\n      const rar4Signature = new Uint8Array([\n        0x52, 0x61, 0x72, 0x21, 0x1a, 0x07, 0x00\n      ]);\n      const format = detectRarFormat(rar4Signature);\n      expect(format).toBe('rar4');\n    });\n\n    it('åº”è¯¥æ­£ç¡®è¯†åˆ«RAR 5.xæ ¼å¼', () => {\n      const rar5Signature = new Uint8Array([\n        0x52, 0x61, 0x72, 0x21, 0x1a, 0x07, 0x01, 0x00\n      ]);\n      const format = detectRarFormat(rar5Signature);\n      expect(format).toBe('rar5');\n    });\n\n    it('åº”è¯¥è¯†åˆ«è‡ªè§£å‹RARæ–‡ä»¶', () => {\n      // è‡ªè§£å‹RARæ–‡ä»¶ä»¥PE/ELFå¤´å¼€å§‹ï¼Œä½†åŒ…å«RARç­¾å\n      const sfxSignature = new Uint8Array([\n        0x4d, 0x5a, 0x90, 0x00, // PEå¤´å¼€å§‹\n        // ... åé¢ä¼šæœ‰RARç­¾å\n      ]);\n      \n      mockRarService.detectFormat.mockImplementation((data) => {\n        // æ¨¡æ‹Ÿåœ¨æ–‡ä»¶ä¸­æœç´¢RARç­¾å\n        const rarSignaturePosition = 1024; // å‡è®¾åœ¨1KBä½ç½®æ‰¾åˆ°\n        return rarSignaturePosition > 0 ? 'rar-sfx' : 'unknown';\n      });\n\n      const format = mockRarService.detectFormat(sfxSignature);\n      expect(format).toBe('rar-sfx');\n    });\n\n    it('åº”è¯¥å¤„ç†RARåˆ†å·æ–‡ä»¶', () => {\n      const volumeExtensions = ['.part1.rar', '.part2.rar', '.r01', '.r02'];\n      \n      volumeExtensions.forEach(ext => {\n        const fileName = `archive${ext}`;\n        const isVolume = isRarVolume(fileName);\n        expect(isVolume).toBe(true);\n      });\n    });\n\n    it('åº”è¯¥æ‹’ç»æŸåçš„RARç­¾å', () => {\n      const corruptedSignature = new Uint8Array([\n        0x52, 0x61, 0x72, 0xFF, 0xFF, 0xFF, 0xFF\n      ]);\n      const format = detectRarFormat(corruptedSignature);\n      expect(format).toBe('unknown');\n    });\n  });\n\n  describe('RARç‰ˆæœ¬å…¼å®¹æ€§', () => {\n    it('åº”è¯¥æ”¯æŒRAR 1.xæ ¼å¼', async () => {\n      mockRarService.getRarVersion.mockResolvedValue('1.5');\n      \n      const version = await mockRarService.getRarVersion(testFile);\n      expect(version).toBe('1.5');\n    });\n\n    it('åº”è¯¥æ”¯æŒRAR 2.xæ ¼å¼', async () => {\n      mockRarService.getRarVersion.mockResolvedValue('2.9');\n      \n      const version = await mockRarService.getRarVersion(testFile);\n      expect(version).toBe('2.9');\n    });\n\n    it('åº”è¯¥æ”¯æŒRAR 3.xæ ¼å¼', async () => {\n      mockRarService.getRarVersion.mockResolvedValue('3.93');\n      \n      const version = await mockRarService.getRarVersion(testFile);\n      expect(version).toBe('3.93');\n    });\n\n    it('åº”è¯¥æ”¯æŒRAR 4.xæ ¼å¼', async () => {\n      mockRarService.getRarVersion.mockResolvedValue('4.20');\n      \n      const version = await mockRarService.getRarVersion(testFile);\n      expect(version).toBe('4.20');\n    });\n\n    it('åº”è¯¥æ”¯æŒRAR 5.xæ ¼å¼', async () => {\n      mockRarService.getRarVersion.mockResolvedValue('5.91');\n      \n      const version = await mockRarService.getRarVersion(testFile);\n      expect(version).toBe('5.91');\n    });\n\n    it('åº”è¯¥å¤„ç†æœªçŸ¥RARç‰ˆæœ¬', async () => {\n      mockRarService.getRarVersion.mockRejectedValue(\n        new Error('Unknown RAR version')\n      );\n\n      await expect(mockRarService.getRarVersion(testFile))\n        .rejects.toThrow('Unknown RAR version');\n    });\n  });\n\n  describe('RARå‹ç¼©æ–¹æ³•æ”¯æŒ', () => {\n    const rarCompressionMethods = [\n      { id: 0x30, name: 'Store (ä¸å‹ç¼©)' },\n      { id: 0x31, name: 'Fastest' },\n      { id: 0x32, name: 'Fast' },\n      { id: 0x33, name: 'Normal' },\n      { id: 0x34, name: 'Good' },\n      { id: 0x35, name: 'Best' }\n    ];\n\n    rarCompressionMethods.forEach(method => {\n      it(`åº”è¯¥æ”¯æŒ${method.name}å‹ç¼©æ–¹æ³•`, async () => {\n        const mockFile = {\n          name: 'test.txt',\n          compressionMethod: method.id,\n          size: 1024,\n          compressedSize: method.id === 0x30 ? 1024 : 512\n        };\n\n        mockRarService.extractSingleFile.mockResolvedValue({\n          content: new Uint8Array(1024),\n          compressionMethod: method.id\n        });\n\n        const result = await mockRarService.extractSingleFile('test.txt');\n        expect(result.compressionMethod).toBe(method.id);\n      });\n    });\n\n    it('åº”è¯¥æ”¯æŒRAR 5.xçš„æ–°å‹ç¼©ç®—æ³•', async () => {\n      const rar5Methods = [\n        { id: 0x40, name: 'RAR5 Normal' },\n        { id: 0x41, name: 'RAR5 Fast' },\n        { id: 0x42, name: 'RAR5 Best' }\n      ];\n\n      for (const method of rar5Methods) {\n        mockRarService.extractSingleFile.mockResolvedValue({\n          content: new Uint8Array(1024),\n          compressionMethod: method.id,\n          rarVersion: 5\n        });\n\n        const result = await mockRarService.extractSingleFile('test.txt');\n        expect(result.compressionMethod).toBe(method.id);\n        expect(result.rarVersion).toBe(5);\n      }\n    });\n  });\n\n  describe('RARå¯†ç ä¿æŠ¤å¤„ç†', () => {\n    it('åº”è¯¥æ£€æµ‹å¯†ç ä¿æŠ¤çš„RARæ–‡ä»¶', async () => {\n      mockRarService.checkPassword.mockResolvedValue(true);\n\n      const hasPassword = await mockRarService.checkPassword(testFile);\n      expect(hasPassword).toBe(true);\n    });\n\n    it('åº”è¯¥æ£€æµ‹æ–‡ä»¶ååŠ å¯†', async () => {\n      mockRarService.checkPassword.mockResolvedValue({\n        hasPassword: true,\n        isHeaderEncrypted: true,\n        encryptionType: 'aes256'\n      });\n\n      const result = await mockRarService.checkPassword(testFile);\n      expect(result.isHeaderEncrypted).toBe(true);\n      expect(result.encryptionType).toBe('aes256');\n    });\n\n    it('åº”è¯¥ä½¿ç”¨æ­£ç¡®å¯†ç è§£å‹æ–‡ä»¶', async () => {\n      const correctPassword = 'secret123';\n      const mockContent = new Uint8Array([82, 65, 82, 32, 84, 101, 115, 116]); // \"RAR Test\"\n\n      mockRarService.extractSingleFile.mockImplementation((filename, password) => {\n        if (password === correctPassword) {\n          return Promise.resolve({ content: mockContent });\n        }\n        return Promise.reject(new Error('Wrong password'));\n      });\n\n      const result = await mockRarService.extractSingleFile('test.txt', correctPassword);\n      expect(result.content).toEqual(mockContent);\n    });\n\n    it('åº”è¯¥æ”¯æŒä¸åŒçš„åŠ å¯†å¼ºåº¦', async () => {\n      const encryptionLevels = [\n        { level: 128, name: 'AES-128' },\n        { level: 256, name: 'AES-256' }\n      ];\n\n      for (const encryption of encryptionLevels) {\n        mockRarService.extractSingleFile.mockResolvedValue({\n          content: new Uint8Array(100),\n          encryptionLevel: encryption.level\n        });\n\n        const result = await mockRarService.extractSingleFile('test.txt', 'password');\n        expect(result.encryptionLevel).toBe(encryption.level);\n      }\n    });\n\n    it('åº”è¯¥å¤„ç†RAR5çš„å¯†ç éªŒè¯', async () => {\n      // RAR5ä½¿ç”¨ä¸åŒçš„å¯†ç éªŒè¯æœºåˆ¶\n      mockRarService.extractSingleFile.mockImplementation((filename, password) => {\n        // æ¨¡æ‹ŸRAR5çš„PBKDF2å¯†ç éªŒè¯\n        const isValidPassword = password && password.length >= 1;\n        if (isValidPassword) {\n          return Promise.resolve({\n            content: new Uint8Array(100),\n            rarVersion: 5,\n            passwordVerified: true\n          });\n        }\n        return Promise.reject(new Error('RAR5: Password verification failed'));\n      });\n\n      const result = await mockRarService.extractSingleFile('test.txt', 'validpass');\n      expect(result.rarVersion).toBe(5);\n      expect(result.passwordVerified).toBe(true);\n    });\n  });\n\n  describe('RARåˆ†å·å¤„ç†', () => {\n    it('åº”è¯¥æ£€æµ‹åˆ†å·RARæ–‡ä»¶', () => {\n      const volumeFiles = [\n        'archive.part1.rar',\n        'archive.part2.rar',\n        'archive.part3.rar'\n      ];\n\n      volumeFiles.forEach(filename => {\n        const isVolume = isRarVolume(filename);\n        expect(isVolume).toBe(true);\n      });\n    });\n\n    it('åº”è¯¥å¤„ç†è€å¼åˆ†å·å‘½å', () => {\n      const oldVolumeFiles = [\n        'archive.rar',  // ç¬¬ä¸€å·\n        'archive.r00',  // ç¬¬äºŒå·\n        'archive.r01',  // ç¬¬ä¸‰å·\n        'archive.r02'   // ç¬¬å››å·\n      ];\n\n      oldVolumeFiles.forEach(filename => {\n        const isVolume = isRarVolume(filename);\n        expect(isVolume).toBe(true);\n      });\n    });\n\n    it('åº”è¯¥æŒ‰é¡ºåºå¤„ç†åˆ†å·', async () => {\n      const volumes = [\n        'archive.part1.rar',\n        'archive.part2.rar',\n        'archive.part3.rar'\n      ];\n\n      mockRarService.extractFiles.mockImplementation((volumeList) => {\n        // éªŒè¯åˆ†å·é¡ºåº\n        const sortedVolumes = volumeList.sort();\n        expect(sortedVolumes).toEqual(volumes);\n        \n        return Promise.resolve([\n          { name: 'file1.txt', content: new Uint8Array(1000) },\n          { name: 'file2.txt', content: new Uint8Array(2000) }\n        ]);\n      });\n\n      const result = await mockRarService.extractFiles(volumes);\n      expect(result).toHaveLength(2);\n    });\n\n    it('åº”è¯¥å¤„ç†ç¼ºå¤±çš„åˆ†å·', async () => {\n      const incompleteVolumes = [\n        'archive.part1.rar',\n        // ç¼ºå°‘ part2\n        'archive.part3.rar'\n      ];\n\n      mockRarService.extractFiles.mockRejectedValue(\n        new Error('Missing volume: archive.part2.rar')\n      );\n\n      await expect(mockRarService.extractFiles(incompleteVolumes))\n        .rejects.toThrow('Missing volume: archive.part2.rar');\n    });\n  });\n\n  describe('RARç‰¹æ®ŠåŠŸèƒ½', () => {\n    it('åº”è¯¥æ”¯æŒæ¢å¤è®°å½•', async () => {\n      mockRarService.checkRecoveryRecord.mockResolvedValue({\n        hasRecoveryRecord: true,\n        recoverySize: 1024,\n        canRecover: true\n      });\n\n      const recoveryInfo = await mockRarService.checkRecoveryRecord(testFile);\n      expect(recoveryInfo.hasRecoveryRecord).toBe(true);\n      expect(recoveryInfo.canRecover).toBe(true);\n    });\n\n    it('åº”è¯¥æ”¯æŒå›ºå®å‹ç¼©æ£€æµ‹', async () => {\n      mockRarService.getFileList.mockResolvedValue([\n        {\n          name: 'file1.txt',\n          isSolid: true,\n          solidGroup: 1\n        },\n        {\n          name: 'file2.txt',\n          isSolid: true,\n          solidGroup: 1\n        }\n      ]);\n\n      const files = await mockRarService.getFileList(testFile);\n      expect(files.every(file => file.isSolid)).toBe(true);\n      expect(files.every(file => file.solidGroup === 1)).toBe(true);\n    });\n\n    it('åº”è¯¥æ”¯æŒæ–‡ä»¶æ³¨é‡Š', async () => {\n      mockRarService.getFileList.mockResolvedValue([\n        {\n          name: 'document.txt',\n          comment: 'è¿™æ˜¯ä¸€ä¸ªé‡è¦æ–‡æ¡£',\n          hasComment: true\n        }\n      ]);\n\n      const files = await mockRarService.getFileList(testFile);\n      expect(files[0].hasComment).toBe(true);\n      expect(files[0].comment).toBe('è¿™æ˜¯ä¸€ä¸ªé‡è¦æ–‡æ¡£');\n    });\n\n    it('åº”è¯¥æ”¯æŒå‹ç¼©åŒ…æ³¨é‡Š', async () => {\n      mockRarService.validateArchive.mockResolvedValue({\n        isValid: true,\n        archiveComment: 'Created with ZhugeExtract Test Suite',\n        hasComment: true\n      });\n\n      const result = await mockRarService.validateArchive(testFile);\n      expect(result.hasComment).toBe(true);\n      expect(result.archiveComment).toBe('Created with ZhugeExtract Test Suite');\n    });\n\n    it('åº”è¯¥æ”¯æŒå‹ç¼©å­—å…¸å¤§å°æ£€æµ‹', async () => {\n      const dictionarySizes = [64, 128, 256, 512, 1024, 2048, 4096];\n\n      for (const dictSize of dictionarySizes) {\n        mockRarService.getFileList.mockResolvedValue([\n          {\n            name: 'test.txt',\n            dictionarySize: dictSize * 1024 // KB to bytes\n          }\n        ]);\n\n        const files = await mockRarService.getFileList(testFile);\n        expect(files[0].dictionarySize).toBe(dictSize * 1024);\n      }\n    });\n  });\n\n  describe('RARæ€§èƒ½æµ‹è¯•', () => {\n    it('åº”è¯¥é«˜æ•ˆå¤„ç†å¤§å‹RARæ–‡ä»¶', async () => {\n      const largeFile = TestHelpers.createMockArchiveFile('rar', 500 * 1024 * 1024); // 500MB\n      const startTime = performance.now();\n\n      mockRarService.getFileList.mockImplementation(async () => {\n        // æ¨¡æ‹Ÿå¤§æ–‡ä»¶å¤„ç†æ—¶é—´\n        await new Promise(resolve => setTimeout(resolve, 200));\n        return Array.from({ length: 1000 }, (_, i) => ({\n          name: `file-${i}.txt`,\n          size: 500 * 1024 // 500KB each\n        }));\n      });\n\n      const result = await mockRarService.getFileList(largeFile);\n      const duration = performance.now() - startTime;\n\n      expect(result).toHaveLength(1000);\n      expect(duration).toBeLessThan(1000); // åº”è¯¥åœ¨1ç§’å†…å®Œæˆ\n    });\n\n    it('åº”è¯¥ä¼˜åŒ–å›ºå®å‹ç¼©çš„è§£å‹é¡ºåº', async () => {\n      // å›ºå®ì••ç¼©éœ€è¦æŒ‰é¡ºåºè§£å‹\n      const solidFiles = Array.from({ length: 100 }, (_, i) => `file-${i}.txt`);\n      \n      mockRarService.extractFiles.mockImplementation(async (fileList) => {\n        // æ¨¡æ‹Ÿå›ºì‹¤å‹ç¼©çš„é¡ºåºå¤„ç†\n        const extractedFiles = [];\n        for (let i = 0; i < fileList.length; i++) {\n          extractedFiles.push({\n            name: fileList[i],\n            content: new Uint8Array(1024),\n            extractionOrder: i\n          });\n        }\n        return extractedFiles;\n      });\n\n      const result = await mockRarService.extractFiles(solidFiles);\n      \n      // éªŒè¯è§£å‹é¡ºåº\n      for (let i = 0; i < result.length; i++) {\n        expect(result[i].extractionOrder).toBe(i);\n      }\n    });\n\n    it('åº”è¯¥æ§åˆ¶å†…å­˜ä½¿ç”¨é‡', async () => {\n      const initialMemory = performance.memory?.usedJSHeapSize || 0;\n\n      mockRarService.extractFiles.mockImplementation(async () => {\n        // æ¨¡æ‹Ÿå†…å­˜æ§åˆ¶æœºåˆ¶\n        const maxMemoryPerFile = 10 * 1024 * 1024; // 10MB per file\n        return [\n          { name: 'large.txt', content: new Uint8Array(maxMemoryPerFile) }\n        ];\n      });\n\n      await mockRarService.extractFiles([testFile]);\n      \n      const finalMemory = performance.memory?.usedJSHeapSize || 0;\n      const memoryIncrease = finalMemory - initialMemory;\n      \n      // å†…å­˜å¢é•¿åº”è¯¥å¯æ§\n      expect(memoryIncrease).toBeLessThan(50 * 1024 * 1024); // å°äº50MB\n    });\n  });\n\n  describe('RARé”™è¯¯å¤„ç†', () => {\n    it('åº”è¯¥å¤„ç†æŸåçš„RARå¤´', async () => {\n      mockRarService.validateArchive.mockRejectedValue(\n        new Error('RAR header is corrupted')\n      );\n\n      await expect(mockRarService.validateArchive(testFile))\n        .rejects.toThrow('RAR header is corrupted');\n    });\n\n    it('åº”è¯¥å¤„ç†CRCé”™è¯¯', async () => {\n      mockRarService.extractSingleFile.mockRejectedValue(\n        new Error('CRC error in file: test.txt')\n      );\n\n      await expect(mockRarService.extractSingleFile('test.txt'))\n        .rejects.toThrow('CRC error in file: test.txt');\n    });\n\n    it('åº”è¯¥å¤„ç†ä¸æ”¯æŒçš„RARç‰ˆæœ¬', async () => {\n      mockRarService.getRarVersion.mockRejectedValue(\n        new Error('Unsupported RAR version: 6.0')\n      );\n\n      await expect(mockRarService.getRarVersion(testFile))\n        .rejects.toThrow('Unsupported RAR version: 6.0');\n    });\n\n    it('åº”è¯¥å¤„ç†åˆ†å·è¯»å–é”™è¯¯', async () => {\n      mockRarService.extractFiles.mockRejectedValue(\n        new Error('Cannot read volume 2 of 3')\n      );\n\n      await expect(mockRarService.extractFiles([testFile]))\n        .rejects.toThrow('Cannot read volume 2 of 3');\n    });\n\n    it('åº”è¯¥å¤„ç†å›ºå®å‹ç¼©ä¸­æ–­', async () => {\n      mockRarService.extractFiles.mockRejectedValue(\n        new Error('Solid archive extraction interrupted')\n      );\n\n      await expect(mockRarService.extractFiles([testFile]))\n        .rejects.toThrow('Solid archive extraction interrupted');\n    });\n  });\n\n  describe('RARå…¼å®¹æ€§æµ‹è¯•', () => {\n    it('åº”è¯¥å…¼å®¹WinRARåˆ›å»ºçš„æ–‡ä»¶', async () => {\n      mockRarService.validateArchive.mockResolvedValue({\n        isValid: true,\n        createdBy: 'WinRAR 6.11',\n        platform: 'Windows'\n      });\n\n      const result = await mockRarService.validateArchive(testFile);\n      expect(result.createdBy).toContain('WinRAR');\n      expect(result.platform).toBe('Windows');\n    });\n\n    it('åº”è¯¥å…¼å®¹7-Zipåˆ›å»ºçš„RARæ–‡ä»¶', async () => {\n      mockRarService.validateArchive.mockResolvedValue({\n        isValid: true,\n        createdBy: '7-Zip 21.07',\n        platform: 'Multi-platform'\n      });\n\n      const result = await mockRarService.validateArchive(testFile);\n      expect(result.createdBy).toContain('7-Zip');\n    });\n\n    it('åº”è¯¥å…¼å®¹å‘½ä»¤è¡ŒRARåˆ›å»ºçš„æ–‡ä»¶', async () => {\n      mockRarService.validateArchive.mockResolvedValue({\n        isValid: true,\n        createdBy: 'RAR 6.11 Command Line',\n        platform: 'Linux'\n      });\n\n      const result = await mockRarService.validateArchive(testFile);\n      expect(result.createdBy).toContain('Command Line');\n      expect(result.platform).toBe('Linux');\n    });\n\n    it('åº”è¯¥å¤„ç†ä¸åŒå­—ç¬¦ç¼–ç ', async () => {\n      const encodingTests = [\n        { name: 'æµ‹è¯•æ–‡ä»¶.txt', encoding: 'utf-8' },\n        { name: 'Ñ‚ĞµÑÑ‚.txt', encoding: 'utf-8' },\n        { name: 'ãƒ†ã‚¹ãƒˆ.txt', encoding: 'utf-8' },\n        { name: 'test.txt', encoding: 'cp1252' }\n      ];\n\n      for (const test of encodingTests) {\n        mockRarService.getFileList.mockResolvedValue([\n          {\n            name: test.name,\n            encoding: test.encoding,\n            isDirectory: false\n          }\n        ]);\n\n        const result = await mockRarService.getFileList(testFile);\n        expect(result[0].name).toBe(test.name);\n        expect(result[0].encoding).toBe(test.encoding);\n      }\n    });\n  });\n});\n\n// è¾…åŠ©å‡½æ•°\nfunction detectRarFormat(signature: Uint8Array): string {\n  if (signature.length < 7) {return 'unknown';}\n  \n  // æ£€æŸ¥RARç­¾å \"Rar!\"\n  if (signature[0] === 0x52 && signature[1] === 0x61 && \n      signature[2] === 0x72 && signature[3] === 0x21) {\n    \n    // æ£€æŸ¥ç‰ˆæœ¬æ ‡è¯†\n    if (signature[6] === 0x00) {return 'rar4';}\n    if (signature[6] === 0x01 && signature[7] === 0x00) {return 'rar5';}\n  }\n  \n  return 'unknown';\n}\n\nfunction isRarVolume(filename: string): boolean {\n  const volumePatterns = [\n    /\\.part\\d+\\.rar$/i,  // archive.part1.rar\n    /\\.r\\d{2}$/i,        // archive.r01\n    /\\.rar$/i            // archive.rar (ç¬¬ä¸€å·)\n  ];\n  \n  return volumePatterns.some(pattern => pattern.test(filename));\n}","usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/tests/unit/formats/zip-format.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'TestDataGenerator' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":40},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'mockFile' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":181,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":181,"endColumn":23}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';\nimport { TestHelpers, TestDataGenerator } from '@tests/utils/test-helpers';\n\n/**\n * ZIPæ ¼å¼ä¸“é¡¹æµ‹è¯•\n * è¦†ç›–ZIPæ ¼å¼çš„å„ç§ç‰¹æ€§å’Œè¾¹ç•Œæƒ…å†µ\n */\ndescribe('ZIPæ ¼å¼å¤„ç†', () => {\n  let mockZipService: any;\n  let testFile: File;\n\n  beforeEach(() => {\n    // åˆ›å»ºåŸºç¡€ZIPæµ‹è¯•æ–‡ä»¶\n    testFile = TestHelpers.createMockArchiveFile('zip', 1024);\n    \n    // æ¨¡æ‹ŸZIPæœåŠ¡\n    mockZipService = {\n      detectFormat: vi.fn(),\n      extractFiles: vi.fn(),\n      getFileList: vi.fn(),\n      extractSingleFile: vi.fn(),\n      validateArchive: vi.fn(),\n      checkPassword: vi.fn()\n    };\n  });\n\n  afterEach(() => {\n    vi.clearAllMocks();\n  });\n\n  describe('ZIPæ–‡ä»¶æ ¼å¼æ£€æµ‹', () => {\n    it('åº”è¯¥æ­£ç¡®è¯†åˆ«æ ‡å‡†ZIPæ–‡ä»¶', () => {\n      const zipSignature = new Uint8Array([0x50, 0x4b, 0x03, 0x04]);\n      const format = detectZipFormat(zipSignature);\n      expect(format).toBe('zip');\n    });\n\n    it('åº”è¯¥è¯†åˆ«ç©ºZIPæ–‡ä»¶', () => {\n      const emptyZipSignature = new Uint8Array([0x50, 0x4b, 0x05, 0x06]);\n      const format = detectZipFormat(emptyZipSignature);\n      expect(format).toBe('zip');\n    });\n\n    it('åº”è¯¥è¯†åˆ«è·¨å·ZIPæ–‡ä»¶', () => {\n      const multiVolumeSignature = new Uint8Array([0x50, 0x4b, 0x07, 0x08]);\n      const format = detectZipFormat(multiVolumeSignature);\n      expect(format).toBe('zip');\n    });\n\n    it('åº”è¯¥è¯†åˆ«ZIP64æ ¼å¼', () => {\n      const zip64Signature = new Uint8Array([0x50, 0x4b, 0x06, 0x06]);\n      const format = detectZipFormat(zip64Signature);\n      expect(format).toBe('zip64');\n    });\n\n    it('åº”è¯¥æ‹’ç»æŸåçš„ZIPç­¾å', () => {\n      const corruptedSignature = new Uint8Array([0x50, 0x4b, 0xFF, 0xFF]);\n      const format = detectZipFormat(corruptedSignature);\n      expect(format).toBe('unknown');\n    });\n\n    it('åº”è¯¥å¤„ç†æ–‡ä»¶å¤ªå°çš„æƒ…å†µ', () => {\n      const tooSmall = new Uint8Array([0x50]);\n      const format = detectZipFormat(tooSmall);\n      expect(format).toBe('unknown');\n    });\n  });\n\n  describe('ZIPæ–‡ä»¶ç»“æ„è§£æ', () => {\n    it('åº”è¯¥æ­£ç¡®è§£æåŸºæœ¬ZIPæ–‡ä»¶ç»“æ„', async () => {\n      const mockStructure = [\n        {\n          name: 'document.txt',\n          path: 'document.txt',\n          size: 1024,\n          compressedSize: 512,\n          compressionMethod: 8, // deflate\n          crc32: 0x12345678,\n          lastModified: new Date('2024-01-01'),\n          isDirectory: false,\n          isEncrypted: false\n        },\n        {\n          name: 'images',\n          path: 'images/',\n          size: 0,\n          compressedSize: 0,\n          compressionMethod: 0,\n          crc32: 0,\n          lastModified: new Date('2024-01-01'),\n          isDirectory: true,\n          isEncrypted: false\n        }\n      ];\n\n      mockZipService.getFileList.mockResolvedValue(mockStructure);\n      const result = await mockZipService.getFileList(testFile);\n\n      expect(result).toHaveLength(2);\n      expect(result[0]).toMatchObject({\n        name: 'document.txt',\n        isDirectory: false,\n        compressionMethod: 8\n      });\n      expect(result[1]).toMatchObject({\n        name: 'images',\n        isDirectory: true\n      });\n    });\n\n    it('åº”è¯¥å¤„ç†æ·±å±‚åµŒå¥—ç›®å½•ç»“æ„', async () => {\n      const mockNestedStructure = Array.from({ length: 100 }, (_, i) => ({\n        name: `file-${i}.txt`,\n        path: `level1/level2/level3/level4/file-${i}.txt`,\n        size: Math.random() * 10000,\n        isDirectory: false,\n        lastModified: new Date()\n      }));\n\n      mockZipService.getFileList.mockResolvedValue(mockNestedStructure);\n      const result = await mockZipService.getFileList(testFile);\n\n      expect(result).toHaveLength(100);\n      expect(result.every(item => item.path.split('/').length === 5)).toBe(true);\n    });\n\n    it('åº”è¯¥æ­£ç¡®å¤„ç†ä¸­æ–‡æ–‡ä»¶å', async () => {\n      const chineseFiles = [\n        {\n          name: 'æµ‹è¯•æ–‡æ¡£.txt',\n          path: 'æ–‡ä»¶å¤¹/æµ‹è¯•æ–‡æ¡£.txt',\n          size: 1024,\n          isDirectory: false,\n          encoding: 'utf-8'\n        },\n        {\n          name: 'å›¾ç‰‡æ–‡ä»¶å¤¹',\n          path: 'å›¾ç‰‡æ–‡ä»¶å¤¹/',\n          size: 0,\n          isDirectory: true,\n          encoding: 'utf-8'\n        }\n      ];\n\n      mockZipService.getFileList.mockResolvedValue(chineseFiles);\n      const result = await mockZipService.getFileList(testFile);\n\n      expect(result[0].name).toBe('æµ‹è¯•æ–‡æ¡£.txt');\n      expect(result[1].name).toBe('å›¾ç‰‡æ–‡ä»¶å¤¹');\n    });\n\n    it('åº”è¯¥å¤„ç†ç‰¹æ®Šå­—ç¬¦æ–‡ä»¶å', async () => {\n      const specialCharFiles = [\n        { name: 'file with spaces.txt', isDirectory: false },\n        { name: 'file@#$%^&*().txt', isDirectory: false },\n        { name: 'file[brackets].txt', isDirectory: false },\n        { name: 'file{braces}.txt', isDirectory: false }\n      ];\n\n      mockZipService.getFileList.mockResolvedValue(specialCharFiles);\n      const result = await mockZipService.getFileList(testFile);\n\n      expect(result).toHaveLength(4);\n      expect(result.every(item => item.name.length > 0)).toBe(true);\n    });\n  });\n\n  describe('ZIPå‹ç¼©æ–¹æ³•æ”¯æŒ', () => {\n    const compressionMethods = [\n      { id: 0, name: 'Store (ä¸å‹ç¼©)' },\n      { id: 8, name: 'Deflate' },\n      { id: 9, name: 'Deflate64' },\n      { id: 12, name: 'BZIP2' },\n      { id: 14, name: 'LZMA' },\n      { id: 95, name: 'XZ' },\n      { id: 98, name: 'PPMd' }\n    ];\n\n    compressionMethods.forEach(method => {\n      it(`åº”è¯¥æ”¯æŒ${method.name}å‹ç¼©æ–¹æ³•`, async () => {\n        const mockFile = {\n          name: 'test.txt',\n          compressionMethod: method.id,\n          size: 1024,\n          compressedSize: method.id === 0 ? 1024 : 512\n        };\n\n        mockZipService.extractSingleFile.mockResolvedValue({\n          content: new Uint8Array(1024),\n          compressionMethod: method.id\n        });\n\n        const result = await mockZipService.extractSingleFile('test.txt');\n        expect(result.compressionMethod).toBe(method.id);\n      });\n    });\n\n    it('åº”è¯¥å¤„ç†ä¸æ”¯æŒçš„å‹ç¼©æ–¹æ³•', async () => {\n      const unsupportedMethod = 999;\n      mockZipService.extractSingleFile.mockRejectedValue(\n        new Error(`Unsupported compression method: ${unsupportedMethod}`)\n      );\n\n      await expect(mockZipService.extractSingleFile('test.txt'))\n        .rejects.toThrow('Unsupported compression method');\n    });\n  });\n\n  describe('ZIPå¯†ç ä¿æŠ¤å¤„ç†', () => {\n    it('åº”è¯¥æ£€æµ‹å¯†ç ä¿æŠ¤çš„ZIPæ–‡ä»¶', async () => {\n      const passwordProtectedFile = TestHelpers.createMockArchiveFile('zip', 2048);\n      mockZipService.checkPassword.mockResolvedValue(true);\n\n      const hasPassword = await mockZipService.checkPassword(passwordProtectedFile);\n      expect(hasPassword).toBe(true);\n    });\n\n    it('åº”è¯¥ä½¿ç”¨æ­£ç¡®å¯†ç è§£å‹æ–‡ä»¶', async () => {\n      const correctPassword = 'test123';\n      const mockContent = new Uint8Array([72, 101, 108, 108, 111]); // \"Hello\"\n\n      mockZipService.extractSingleFile.mockImplementation((filename, password) => {\n        if (password === correctPassword) {\n          return Promise.resolve({ content: mockContent });\n        }\n        return Promise.reject(new Error('Wrong password'));\n      });\n\n      const result = await mockZipService.extractSingleFile('test.txt', correctPassword);\n      expect(result.content).toEqual(mockContent);\n    });\n\n    it('åº”è¯¥æ‹’ç»é”™è¯¯å¯†ç ', async () => {\n      const wrongPassword = 'wrong123';\n\n      mockZipService.extractSingleFile.mockImplementation((filename, password) => {\n        if (password === 'correct123') {\n          return Promise.resolve({ content: new Uint8Array() });\n        }\n        return Promise.reject(new Error('Wrong password'));\n      });\n\n      await expect(mockZipService.extractSingleFile('test.txt', wrongPassword))\n        .rejects.toThrow('Wrong password');\n    });\n\n    it('åº”è¯¥å¤„ç†ç©ºå¯†ç ', async () => {\n      mockZipService.extractSingleFile.mockImplementation((filename, password) => {\n        if (password === '' || password === null || password === undefined) {\n          return Promise.reject(new Error('Password required'));\n        }\n        return Promise.resolve({ content: new Uint8Array() });\n      });\n\n      await expect(mockZipService.extractSingleFile('test.txt', ''))\n        .rejects.toThrow('Password required');\n      \n      await expect(mockZipService.extractSingleFile('test.txt', null))\n        .rejects.toThrow('Password required');\n    });\n\n    it('åº”è¯¥æ”¯æŒä¸åŒçš„åŠ å¯†æ–¹æ³•', async () => {\n      const encryptionMethods = [\n        { id: 1, name: 'Traditional PKWARE' },\n        { id: 2, name: 'AES-128' },\n        { id: 3, name: 'AES-192' },\n        { id: 4, name: 'AES-256' }\n      ];\n\n      for (const method of encryptionMethods) {\n        mockZipService.extractSingleFile.mockResolvedValue({\n          content: new Uint8Array(100),\n          encryptionMethod: method.id\n        });\n\n        const result = await mockZipService.extractSingleFile('test.txt', 'password');\n        expect(result.encryptionMethod).toBe(method.id);\n      }\n    });\n  });\n\n  describe('ZIPæ–‡ä»¶å¤§å°å¤„ç†', () => {\n    it('åº”è¯¥å¤„ç†å°æ–‡ä»¶ (< 1KB)', async () => {\n      const smallFile = TestHelpers.createMockArchiveFile('zip', 512);\n      mockZipService.validateArchive.mockResolvedValue(true);\n      \n      const isValid = await mockZipService.validateArchive(smallFile);\n      expect(isValid).toBe(true);\n    });\n\n    it('åº”è¯¥å¤„ç†ä¸­ç­‰æ–‡ä»¶ (1MB - 100MB)', async () => {\n      const mediumFile = TestHelpers.createMockArchiveFile('zip', 50 * 1024 * 1024);\n      mockZipService.validateArchive.mockResolvedValue(true);\n      \n      const isValid = await mockZipService.validateArchive(mediumFile);\n      expect(isValid).toBe(true);\n    });\n\n    it('åº”è¯¥å¤„ç†å¤§æ–‡ä»¶ (> 100MB)', async () => {\n      const largeFile = TestHelpers.createMockArchiveFile('zip', 200 * 1024 * 1024);\n      \n      // æ¨¡æ‹Ÿåˆ†å—å¤„ç†\n      mockZipService.extractFiles.mockImplementation(async (file, options) => {\n        const chunkSize = options?.chunkSize || 1024 * 1024;\n        const totalChunks = Math.ceil(file.size / chunkSize);\n        \n        const results = [];\n        for (let i = 0; i < Math.min(totalChunks, 10); i++) {\n          results.push({\n            name: `chunk-${i}.txt`,\n            content: new Uint8Array(chunkSize)\n          });\n        }\n        \n        return results;\n      });\n\n      const result = await mockZipService.extractFiles(largeFile, { chunkSize: 1024 * 1024 });\n      expect(result).toHaveLength(10);\n    });\n\n    it('åº”è¯¥å¤„ç†ZIP64æ ¼å¼çš„è¶…å¤§æ–‡ä»¶', async () => {\n      const zip64File = TestHelpers.createMockArchiveFile('zip', 5 * 1024 * 1024 * 1024); // 5GBæ¨¡æ‹Ÿ\n      \n      mockZipService.validateArchive.mockImplementation(async (file) => {\n        // æ£€æŸ¥æ˜¯å¦éœ€è¦ZIP64\n        return file.size > 4 * 1024 * 1024 * 1024; // 4GB\n      });\n\n      const needsZip64 = await mockZipService.validateArchive(zip64File);\n      expect(needsZip64).toBe(true);\n    });\n  });\n\n  describe('ZIPæ€§èƒ½æµ‹è¯•', () => {\n    it('åº”è¯¥åœ¨åˆç†æ—¶é—´å†…å®Œæˆå°æ–‡ä»¶è§£å‹', async () => {\n      const startTime = performance.now();\n      \n      mockZipService.extractFiles.mockImplementation(async () => {\n        await new Promise(resolve => setTimeout(resolve, 50)); // æ¨¡æ‹Ÿ50mså¤„ç†æ—¶é—´\n        return [{ name: 'test.txt', content: new Uint8Array(1024) }];\n      });\n\n      await mockZipService.extractFiles(testFile);\n      \n      const duration = performance.now() - startTime;\n      expect(duration).toBeLessThan(200); // åº”è¯¥åœ¨200mså†…å®Œæˆ\n    });\n\n    it('åº”è¯¥é«˜æ•ˆå¤„ç†å¤§é‡å°æ–‡ä»¶', async () => {\n      const fileCount = 1000;\n      const startTime = performance.now();\n\n      mockZipService.extractFiles.mockImplementation(async () => {\n        return Array.from({ length: fileCount }, (_, i) => ({\n          name: `file-${i}.txt`,\n          content: new Uint8Array(100)\n        }));\n      });\n\n      const result = await mockZipService.extractFiles(testFile);\n      const duration = performance.now() - startTime;\n\n      expect(result).toHaveLength(fileCount);\n      expect(duration).toBeLessThan(1000); // 1000ä¸ªæ–‡ä»¶åº”è¯¥åœ¨1ç§’å†…å¤„ç†å®Œæˆ\n    });\n\n    it('åº”è¯¥æ§åˆ¶å†…å­˜ä½¿ç”¨', async () => {\n      const initialMemory = TestHelpers.getMemoryUsage?.() || 0;\n\n      mockZipService.extractFiles.mockImplementation(async () => {\n        // æ¨¡æ‹Ÿå†…å­˜ä½¿ç”¨\n        const tempBuffer = new ArrayBuffer(10 * 1024 * 1024); // 10MB\n        return [{ name: 'large.txt', content: new Uint8Array(tempBuffer) }];\n      });\n\n      await mockZipService.extractFiles(testFile);\n      \n      const finalMemory = TestHelpers.getMemoryUsage?.() || 0;\n      const memoryIncrease = finalMemory - initialMemory;\n      \n      // å†…å­˜å¢é•¿åº”è¯¥åˆç† (å°äº20MB)\n      expect(memoryIncrease).toBeLessThan(20 * 1024 * 1024);\n    });\n  });\n\n  describe('ZIPé”™è¯¯å¤„ç†', () => {\n    it('åº”è¯¥å¤„ç†æŸåçš„ZIPæ–‡ä»¶', async () => {\n      const corruptedFile = TestHelpers.createErrorScenarios().corruptedFile;\n      \n      mockZipService.validateArchive.mockRejectedValue(\n        new Error('Archive is corrupted or invalid')\n      );\n\n      await expect(mockZipService.validateArchive(corruptedFile))\n        .rejects.toThrow('Archive is corrupted or invalid');\n    });\n\n    it('åº”è¯¥å¤„ç†æˆªæ–­çš„ZIPæ–‡ä»¶', async () => {\n      mockZipService.extractFiles.mockRejectedValue(\n        new Error('Unexpected end of archive')\n      );\n\n      await expect(mockZipService.extractFiles(testFile))\n        .rejects.toThrow('Unexpected end of archive');\n    });\n\n    it('åº”è¯¥å¤„ç†CRCæ ¡éªŒå¤±è´¥', async () => {\n      mockZipService.extractSingleFile.mockRejectedValue(\n        new Error('CRC check failed for file: test.txt')\n      );\n\n      await expect(mockZipService.extractSingleFile('test.txt'))\n        .rejects.toThrow('CRC check failed');\n    });\n\n    it('åº”è¯¥å¤„ç†ç½‘ç»œä¸­æ–­', async () => {\n      mockZipService.extractFiles.mockRejectedValue(\n        new Error('Network connection interrupted')\n      );\n\n      await expect(mockZipService.extractFiles(testFile))\n        .rejects.toThrow('Network connection interrupted');\n    });\n\n    it('åº”è¯¥ä¼˜é›…å¤„ç†å†…å­˜ä¸è¶³', async () => {\n      mockZipService.extractFiles.mockRejectedValue(\n        new Error('Out of memory')\n      );\n\n      await expect(mockZipService.extractFiles(testFile))\n        .rejects.toThrow('Out of memory');\n    });\n  });\n\n  describe('ZIPå…¼å®¹æ€§æµ‹è¯•', () => {\n    it('åº”è¯¥å…¼å®¹Windowsåˆ›å»ºçš„ZIPæ–‡ä»¶', async () => {\n      // æ¨¡æ‹ŸWindowsè·¯å¾„åˆ†éš”ç¬¦\n      const windowsFiles = [\n        { name: 'folder\\\\file.txt', path: 'folder\\\\file.txt', isDirectory: false },\n        { name: 'folder\\\\', path: 'folder\\\\', isDirectory: true }\n      ];\n\n      mockZipService.getFileList.mockResolvedValue(windowsFiles);\n      const result = await mockZipService.getFileList(testFile);\n\n      expect(result).toHaveLength(2);\n      expect(result[0].path).toContain('\\\\');\n    });\n\n    it('åº”è¯¥å…¼å®¹macOSåˆ›å»ºçš„ZIPæ–‡ä»¶', async () => {\n      // æ¨¡æ‹ŸmacOSç‰¹æ®Šæ–‡ä»¶\n      const macFiles = [\n        { name: '.DS_Store', isDirectory: false, hidden: true },\n        { name: '__MACOSX/', isDirectory: true, hidden: true },\n        { name: 'normal-file.txt', isDirectory: false, hidden: false }\n      ];\n\n      mockZipService.getFileList.mockResolvedValue(macFiles);\n      const result = await mockZipService.getFileList(testFile);\n\n      expect(result).toHaveLength(3);\n      expect(result.some(file => file.name === '.DS_Store')).toBe(true);\n    });\n\n    it('åº”è¯¥å…¼å®¹Linuxåˆ›å»ºçš„ZIPæ–‡ä»¶', async () => {\n      // æ¨¡æ‹ŸLinuxæƒé™å’Œç¬¦å·é“¾æ¥\n      const linuxFiles = [\n        { \n          name: 'script.sh', \n          isDirectory: false, \n          permissions: 0o755,\n          isExecutable: true \n        },\n        { \n          name: 'link-to-file', \n          isDirectory: false, \n          isSymlink: true,\n          linkTarget: 'script.sh'\n        }\n      ];\n\n      mockZipService.getFileList.mockResolvedValue(linuxFiles);\n      const result = await mockZipService.getFileList(testFile);\n\n      expect(result).toHaveLength(2);\n      expect(result[0].isExecutable).toBe(true);\n      expect(result[1].isSymlink).toBe(true);\n    });\n  });\n});\n\n// è¾…åŠ©å‡½æ•°\nfunction detectZipFormat(signature: Uint8Array): string {\n  if (signature.length < 4) {return 'unknown';}\n  \n  const first4 = Array.from(signature.slice(0, 4));\n  \n  // æ ‡å‡†ZIPç­¾å\n  if (first4[0] === 0x50 && first4[1] === 0x4b) {\n    if (first4[2] === 0x03 && first4[3] === 0x04) {return 'zip';} // æœ¬åœ°æ–‡ä»¶å¤´\n    if (first4[2] === 0x05 && first4[3] === 0x06) {return 'zip';} // ä¸­å¤®ç›®å½•ç»“æŸ\n    if (first4[2] === 0x07 && first4[3] === 0x08) {return 'zip';} // è·¨å·\n    if (first4[2] === 0x06 && first4[3] === 0x06) {return 'zip64';} // ZIP64\n  }\n  \n  return 'unknown';\n}","usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/tests/unit/services/archive-service.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/tests/unit/utils/file-utils.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'beforeEach' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":32,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":42}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, beforeEach, vi } from 'vitest';\nimport { FileUtils } from '@/utils/file-utils';\n\ndescribe('FileUtils', () => {\n  describe('æ–‡ä»¶å¤§å°æ ¼å¼åŒ–', () => {\n    const testCases = [\n      { bytes: 0, expected: '0 B' },\n      { bytes: 1023, expected: '1023 B' },\n      { bytes: 1024, expected: '1.0 KB' },\n      { bytes: 1536, expected: '1.5 KB' },\n      { bytes: 1024 * 1024, expected: '1.0 MB' },\n      { bytes: 1.5 * 1024 * 1024, expected: '1.5 MB' },\n      { bytes: 1024 * 1024 * 1024, expected: '1.0 GB' },\n      { bytes: 2.5 * 1024 * 1024 * 1024, expected: '2.5 GB' },\n      { bytes: 1024 * 1024 * 1024 * 1024, expected: '1.0 TB' },\n    ];\n\n    testCases.forEach(({ bytes, expected }) => {\n      it(`åº”è¯¥æ ¼å¼åŒ– ${bytes} å­—èŠ‚ä¸º ${expected}`, () => {\n        expect(FileUtils.formatFileSize(bytes)).toBe(expected);\n      });\n    });\n\n    it('åº”è¯¥å¤„ç†è´Ÿæ•°', () => {\n      expect(FileUtils.formatFileSize(-1024)).toBe('0 B');\n    });\n\n    it('åº”è¯¥å¤„ç†NaN', () => {\n      expect(FileUtils.formatFileSize(NaN)).toBe('0 B');\n    });\n\n    it('åº”è¯¥å¤„ç†Infinity', () => {\n      expect(FileUtils.formatFileSize(Infinity)).toBe('âˆ');\n    });\n  });\n\n  describe('æ–‡ä»¶æ‰©å±•åæå–', () => {\n    const testCases = [\n      { filename: 'test.txt', expected: 'txt' },\n      { filename: 'archive.tar.gz', expected: 'gz' },\n      { filename: 'document.pdf', expected: 'pdf' },\n      { filename: 'image.jpeg', expected: 'jpeg' },\n      { filename: 'noextension', expected: '' },\n      { filename: '.hidden', expected: '' },\n      { filename: '.hidden.txt', expected: 'txt' },\n      { filename: 'file.with.dots.zip', expected: 'zip' },\n      { filename: '', expected: '' },\n    ];\n\n    testCases.forEach(({ filename, expected }) => {\n      it(`åº”è¯¥ä» \"${filename}\" æå–æ‰©å±•å \"${expected}\"`, () => {\n        expect(FileUtils.getFileExtension(filename)).toBe(expected);\n      });\n    });\n  });\n\n  describe('æ–‡ä»¶åæ¸…ç†', () => {\n    const testCases = [\n      { input: 'normal-file.txt', expected: 'normal-file.txt' },\n      { input: 'file with spaces.txt', expected: 'file with spaces.txt' },\n      { input: 'file<with>invalid:chars.txt', expected: 'file_with_invalid_chars.txt' },\n      { input: 'file|with\"quotes.txt', expected: 'file_with_quotes.txt' },\n      { input: 'file*with?wildcards.txt', expected: 'file_with_wildcards.txt' },\n      { input: '../../../dangerous.txt', expected: '______dangerous.txt' },\n      { input: 'file\\nwith\\nnewlines.txt', expected: 'file_with_newlines.txt' },\n      { input: 'very-long-filename-that-exceeds-normal-limits-and-should-be-truncated-to-reasonable-length.txt', expected: 'very-long-filename-that-exceeds-normal-limits-and-should-be-truncated-to-reason.txt' },\n    ];\n\n    testCases.forEach(({ input, expected }) => {\n      it(`åº”è¯¥æ¸…ç†æ–‡ä»¶å \"${input}\" ä¸º \"${expected}\"`, () => {\n        expect(FileUtils.sanitizeFileName(input)).toBe(expected);\n      });\n    });\n\n    it('åº”è¯¥å¤„ç†ç©ºæ–‡ä»¶å', () => {\n      expect(FileUtils.sanitizeFileName('')).toBe('untitled');\n    });\n\n    it('åº”è¯¥å¤„ç†åªæœ‰éæ³•å­—ç¬¦çš„æ–‡ä»¶å', () => {\n      expect(FileUtils.sanitizeFileName('<>:\"/?*')).toBe('untitled');\n    });\n  });\n\n  describe('è·¯å¾„æ“ä½œ', () => {\n    describe('è·¯å¾„æ‹¼æ¥', () => {\n      const testCases = [\n        { parts: ['folder', 'file.txt'], expected: 'folder/file.txt' },\n        { parts: ['folder/', 'file.txt'], expected: 'folder/file.txt' },\n        { parts: ['folder', '/file.txt'], expected: 'folder/file.txt' },\n        { parts: ['folder/', '/file.txt'], expected: 'folder/file.txt' },\n        { parts: ['', 'file.txt'], expected: 'file.txt' },\n        { parts: ['folder', ''], expected: 'folder/' },\n        { parts: ['a', 'b', 'c', 'd.txt'], expected: 'a/b/c/d.txt' },\n      ];\n\n      testCases.forEach(({ parts, expected }) => {\n        it(`åº”è¯¥æ‹¼æ¥è·¯å¾„ [${parts.join(', ')}] ä¸º \"${expected}\"`, () => {\n          expect(FileUtils.joinPath(...parts)).toBe(expected);\n        });\n      });\n    });\n\n    describe('è·¯å¾„è§£æ', () => {\n      const testCases = [\n        { \n          path: 'folder/subfolder/file.txt', \n          expected: { dir: 'folder/subfolder', name: 'file.txt', ext: 'txt' }\n        },\n        { \n          path: 'file.txt', \n          expected: { dir: '', name: 'file.txt', ext: 'txt' }\n        },\n        { \n          path: 'folder/file', \n          expected: { dir: 'folder', name: 'file', ext: '' }\n        },\n        { \n          path: 'folder/', \n          expected: { dir: 'folder', name: '', ext: '' }\n        },\n      ];\n\n      testCases.forEach(({ path, expected }) => {\n        it(`åº”è¯¥è§£æè·¯å¾„ \"${path}\"`, () => {\n          expect(FileUtils.parsePath(path)).toEqual(expected);\n        });\n      });\n    });\n  });\n\n  describe('æ–‡ä»¶ç±»å‹æ£€æµ‹', () => {\n    it('åº”è¯¥æ£€æµ‹æ–‡æœ¬æ–‡ä»¶', () => {\n      const textExtensions = ['txt', 'md', 'json', 'xml', 'html', 'css', 'js', 'ts'];\n      textExtensions.forEach(ext => {\n        expect(FileUtils.isTextFile(`file.${ext}`)).toBe(true);\n      });\n    });\n\n    it('åº”è¯¥æ£€æµ‹å›¾ç‰‡æ–‡ä»¶', () => {\n      const imageExtensions = ['jpg', 'jpeg', 'png', 'gif', 'svg', 'webp', 'bmp'];\n      imageExtensions.forEach(ext => {\n        expect(FileUtils.isImageFile(`image.${ext}`)).toBe(true);\n      });\n    });\n\n    it('åº”è¯¥æ£€æµ‹è§†é¢‘æ–‡ä»¶', () => {\n      const videoExtensions = ['mp4', 'avi', 'mkv', 'mov', 'wmv', 'flv', 'webm'];\n      videoExtensions.forEach(ext => {\n        expect(FileUtils.isVideoFile(`video.${ext}`)).toBe(true);\n      });\n    });\n\n    it('åº”è¯¥æ£€æµ‹éŸ³é¢‘æ–‡ä»¶', () => {\n      const audioExtensions = ['mp3', 'wav', 'flac', 'aac', 'ogg', 'm4a'];\n      audioExtensions.forEach(ext => {\n        expect(FileUtils.isAudioFile(`audio.${ext}`)).toBe(true);\n      });\n    });\n\n    it('åº”è¯¥æ£€æµ‹å‹ç¼©æ–‡ä»¶', () => {\n      const archiveExtensions = ['zip', 'rar', '7z', 'tar', 'gz', 'bz2'];\n      archiveExtensions.forEach(ext => {\n        expect(FileUtils.isArchiveFile(`archive.${ext}`)).toBe(true);\n      });\n    });\n  });\n\n  describe('æ–‡ä»¶è¯»å–', () => {\n    it('åº”è¯¥è¯»å–æ–‡ä»¶ä¸ºArrayBuffer', async () => {\n      const mockFile = new File(['Hello World'], 'test.txt', { type: 'text/plain' });\n      const buffer = await FileUtils.readFileAsArrayBuffer(mockFile);\n      \n      expect(buffer).toBeInstanceOf(ArrayBuffer);\n      expect(buffer.byteLength).toBe(11);\n    });\n\n    it('åº”è¯¥è¯»å–æ–‡ä»¶ä¸ºæ–‡æœ¬', async () => {\n      const mockFile = new File(['Hello World'], 'test.txt', { type: 'text/plain' });\n      const text = await FileUtils.readFileAsText(mockFile);\n      \n      expect(text).toBe('Hello World');\n    });\n\n    it('åº”è¯¥è¯»å–æ–‡ä»¶ä¸ºBase64', async () => {\n      const mockFile = new File(['Hello'], 'test.txt', { type: 'text/plain' });\n      const base64 = await FileUtils.readFileAsBase64(mockFile);\n      \n      expect(base64).toMatch(/^data:text\\/plain;base64,/);\n    });\n\n    it('åº”è¯¥è¯»å–æ–‡ä»¶å¤´éƒ¨', async () => {\n      const content = new Uint8Array([0x50, 0x4B, 0x03, 0x04, 0x00, 0x01, 0x02, 0x03]);\n      const mockFile = new File([content], 'test.zip');\n      \n      const header = await FileUtils.readFileHeader(mockFile, 4);\n      \n      expect(header).toEqual(new Uint8Array([0x50, 0x4B, 0x03, 0x04]));\n    });\n\n    it('åº”è¯¥å¤„ç†æ–‡ä»¶è¯»å–é”™è¯¯', async () => {\n      const invalidFile = null as any;\n      \n      await expect(FileUtils.readFileAsText(invalidFile)).rejects.toThrow();\n    });\n  });\n\n  describe('æ–‡ä»¶éªŒè¯', () => {\n    it('åº”è¯¥éªŒè¯æ–‡ä»¶å¤§å°', () => {\n      const smallFile = new File(['content'], 'small.txt');\n      const maxSize = 1024 * 1024; // 1MB\n      \n      expect(FileUtils.validateFileSize(smallFile, maxSize)).toBe(true);\n    });\n\n    it('åº”è¯¥æ‹’ç»è¿‡å¤§æ–‡ä»¶', () => {\n      const largeContent = new Array(1024 * 1024 + 1).fill('a').join('');\n      const largeFile = new File([largeContent], 'large.txt');\n      const maxSize = 1024 * 1024; // 1MB\n      \n      expect(FileUtils.validateFileSize(largeFile, maxSize)).toBe(false);\n    });\n\n    it('åº”è¯¥éªŒè¯æ–‡ä»¶ç±»å‹', () => {\n      const allowedTypes = ['text/plain', 'application/json'];\n      const validFile = new File(['content'], 'test.txt', { type: 'text/plain' });\n      const invalidFile = new File(['content'], 'test.exe', { type: 'application/octet-stream' });\n      \n      expect(FileUtils.validateFileType(validFile, allowedTypes)).toBe(true);\n      expect(FileUtils.validateFileType(invalidFile, allowedTypes)).toBe(false);\n    });\n\n    it('åº”è¯¥éªŒè¯æ–‡ä»¶æ‰©å±•å', () => {\n      const allowedExtensions = ['txt', 'json', 'md'];\n      \n      expect(FileUtils.validateFileExtension('test.txt', allowedExtensions)).toBe(true);\n      expect(FileUtils.validateFileExtension('test.exe', allowedExtensions)).toBe(false);\n    });\n  });\n\n  describe('URLå’ŒBlobæ“ä½œ', () => {\n    it('åº”è¯¥åˆ›å»ºå’Œæ’¤é”€å¯¹è±¡URL', () => {\n      const mockFile = new File(['content'], 'test.txt');\n      const url = FileUtils.createObjectURL(mockFile);\n      \n      expect(url).toMatch(/^blob:/);\n      \n      // æ’¤é”€URLï¼ˆä¸ä¼šæŠ›å‡ºé”™è¯¯ï¼‰\n      expect(() => FileUtils.revokeObjectURL(url)).not.toThrow();\n    });\n\n    it('åº”è¯¥ä»Base64åˆ›å»ºBlob', () => {\n      const base64 = 'SGVsbG8gV29ybGQ='; // \"Hello World\"\n      const blob = FileUtils.base64ToBlob(base64, 'text/plain');\n      \n      expect(blob.size).toBe(11);\n      expect(blob.type).toBe('text/plain');\n    });\n\n    it('åº”è¯¥ä¸‹è½½Blobä¸ºæ–‡ä»¶', () => {\n      const mockBlob = new Blob(['content'], { type: 'text/plain' });\n      const filename = 'test.txt';\n      \n      // æ¨¡æ‹ŸDOMå…ƒç´ \n      const mockA = {\n        href: '',\n        download: '',\n        click: vi.fn(),\n        style: { display: '' }\n      };\n      \n      const createElementSpy = vi.spyOn(document, 'createElement').mockReturnValue(mockA as any);\n      const appendChildSpy = vi.spyOn(document.body, 'appendChild').mockImplementation(() => mockA as any);\n      const removeChildSpy = vi.spyOn(document.body, 'removeChild').mockImplementation(() => mockA as any);\n      \n      FileUtils.downloadBlob(mockBlob, filename);\n      \n      expect(createElementSpy).toHaveBeenCalledWith('a');\n      expect(mockA.download).toBe(filename);\n      expect(mockA.click).toHaveBeenCalled();\n      expect(appendChildSpy).toHaveBeenCalledWith(mockA);\n      expect(removeChildSpy).toHaveBeenCalledWith(mockA);\n      \n      createElementSpy.mockRestore();\n      appendChildSpy.mockRestore();\n      removeChildSpy.mockRestore();\n    });\n  });\n\n  describe('æ€§èƒ½æµ‹è¯•', () => {\n    it('åº”è¯¥å¿«é€Ÿå¤„ç†æ–‡ä»¶å¤§å°æ ¼å¼åŒ–', () => {\n      const startTime = performance.now();\n      \n      // æ‰§è¡Œ1000æ¬¡æ ¼å¼åŒ–\n      for (let i = 0; i < 1000; i++) {\n        FileUtils.formatFileSize(Math.random() * 1024 * 1024 * 1024);\n      }\n      \n      const endTime = performance.now();\n      const totalTime = endTime - startTime;\n      \n      expect(totalTime).toBeLessThan(50); // åº”è¯¥åœ¨50mså†…å®Œæˆ\n    });\n\n    it('åº”è¯¥å¿«é€Ÿå¤„ç†æ–‡ä»¶åæ¸…ç†', () => {\n      const dirtyFilenames = [\n        'file<with>invalid:chars.txt',\n        'file|with\"quotes.txt',\n        '../../../dangerous.txt',\n        'file*with?wildcards.txt'\n      ];\n      \n      const startTime = performance.now();\n      \n      // æ‰§è¡Œ1000æ¬¡æ¸…ç†\n      for (let i = 0; i < 1000; i++) {\n        const filename = dirtyFilenames[i % dirtyFilenames.length];\n        FileUtils.sanitizeFileName(filename);\n      }\n      \n      const endTime = performance.now();\n      const totalTime = endTime - startTime;\n      \n      expect(totalTime).toBeLessThan(100); // åº”è¯¥åœ¨100mså†…å®Œæˆ\n    });\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/tests/unit/utils/format-detector.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/tests/unit/utils/memory-manager.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/tests/utils/benchmark-runner.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token. A constructor, method, accessor, or property was expected.","line":14,"column":2,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { performance } from 'perf_hooks';\nimport { writeFileSync } from 'fs';\nimport { join } from 'path';\n\n/**\n * åŸºå‡†æµ‹è¯•è¿è¡Œå™¨\n * ç”¨äºæ‰§è¡Œæ€§èƒ½åŸºå‡†æµ‹è¯•å¹¶ç”ŸæˆæŠ¥å‘Š\n */\nexport class BenchmarkRunner {\n  private results: BenchmarkResult[] = [];\n  private startTime: number = 0;\n\n  // åŸºå‡†æµ‹è¯•ç»“æœæ¥å£\n  interface BenchmarkResult {\n    name: string;\n    iterations: number;\n    totalTime: number;\n    averageTime: number;\n    minTime: number;\n    maxTime: number;\n    medianTime: number;\n    operationsPerSecond: number;\n    memoryUsage: {\n      initial: number;\n      peak: number;\n      final: number;\n      delta: number;\n    };\n    metadata?: Record<string, any>;\n  }\n\n  // è¿è¡ŒåŸºå‡†æµ‹è¯•\n  async runBenchmark(\n    name: string,\n    testFunction: () => Promise<void> | void,\n    options: {\n      iterations?: number;\n      warmupIterations?: number;\n      measureMemory?: boolean;\n      metadata?: Record<string, any>;\n    } = {}\n  ): Promise<BenchmarkResult> {\n    const {\n      iterations = 1000,\n      warmupIterations = 10,\n      measureMemory = true,\n      metadata = {}\n    } = options;\n\n    console.log(`ğŸƒâ€â™‚ï¸ è¿è¡ŒåŸºå‡†æµ‹è¯•: ${name}`);\n    console.log(`   è¿­ä»£æ¬¡æ•°: ${iterations}`);\n    console.log(`   é¢„çƒ­æ¬¡æ•°: ${warmupIterations}`);\n\n    // é¢„çƒ­é˜¶æ®µ\n    console.log('ğŸ”¥ é¢„çƒ­ä¸­...');\n    for (let i = 0; i < warmupIterations; i++) {\n      await testFunction();\n    }\n\n    // ç­‰å¾…åƒåœ¾å›æ”¶\n    if (global.gc) {\n      global.gc();\n    }\n    await this.sleep(100);\n\n    // è®°å½•åˆå§‹å†…å­˜\n    const initialMemory = measureMemory ? this.getMemoryUsage() : 0;\n    let peakMemory = initialMemory;\n\n    // æ­£å¼æµ‹è¯•\n    console.log('âš¡ å¼€å§‹åŸºå‡†æµ‹è¯•...');\n    const times: number[] = [];\n    \n    for (let i = 0; i < iterations; i++) {\n      const startTime = performance.now();\n      await testFunction();\n      const endTime = performance.now();\n      \n      times.push(endTime - startTime);\n      \n      // æ›´æ–°å†…å­˜å³°å€¼\n      if (measureMemory) {\n        const currentMemory = this.getMemoryUsage();\n        if (currentMemory > peakMemory) {\n          peakMemory = currentMemory;\n        }\n      }\n\n      // è¿›åº¦æŠ¥å‘Š\n      if ((i + 1) % Math.max(1, Math.floor(iterations / 10)) === 0) {\n        const progress = ((i + 1) / iterations * 100).toFixed(1);\n        console.log(`   è¿›åº¦: ${progress}%`);\n      }\n    }\n\n    // è®°å½•æœ€ç»ˆå†…å­˜\n    const finalMemory = measureMemory ? this.getMemoryUsage() : 0;\n\n    // è®¡ç®—ç»Ÿè®¡æ•°æ®\n    const totalTime = times.reduce((sum, time) => sum + time, 0);\n    const averageTime = totalTime / times.length;\n    const minTime = Math.min(...times);\n    const maxTime = Math.max(...times);\n    const sortedTimes = times.sort((a, b) => a - b);\n    const medianTime = sortedTimes[Math.floor(sortedTimes.length / 2)];\n    const operationsPerSecond = 1000 / averageTime;\n\n    const result: BenchmarkResult = {\n      name,\n      iterations,\n      totalTime,\n      averageTime,\n      minTime,\n      maxTime,\n      medianTime,\n      operationsPerSecond,\n      memoryUsage: {\n        initial: initialMemory,\n        peak: peakMemory,\n        final: finalMemory,\n        delta: finalMemory - initialMemory\n      },\n      metadata\n    };\n\n    this.results.push(result);\n    this.printResult(result);\n    \n    return result;\n  }\n\n  // è¿è¡Œå‹ç¼©è§£å‹åŸºå‡†æµ‹è¯•\n  async runCompressionBenchmark(\n    archiveData: ArrayBuffer,\n    archiveFormat: string\n  ) {\n    const testCases = [\n      {\n        name: `${archiveFormat.toUpperCase()} - æ ¼å¼æ£€æµ‹`,\n        test: async () => {\n          // æ¨¡æ‹Ÿæ ¼å¼æ£€æµ‹\n          const view = new Uint8Array(archiveData.slice(0, 16));\n          return this.detectFormat(view);\n        }\n      },\n      {\n        name: `${archiveFormat.toUpperCase()} - æ–‡ä»¶åˆ—è¡¨è·å–`,\n        test: async () => {\n          // æ¨¡æ‹Ÿè·å–æ–‡ä»¶åˆ—è¡¨\n          await this.sleep(Math.random() * 10);\n          return Array.from({ length: 10 }, (_, i) => `file-${i}.txt`);\n        }\n      },\n      {\n        name: `${archiveFormat.toUpperCase()} - å•æ–‡ä»¶è§£å‹`,\n        test: async () => {\n          // æ¨¡æ‹Ÿå•æ–‡ä»¶è§£å‹\n          await this.sleep(Math.random() * 20);\n          return new Uint8Array(1024);\n        }\n      },\n      {\n        name: `${archiveFormat.toUpperCase()} - å…¨éƒ¨è§£å‹`,\n        test: async () => {\n          // æ¨¡æ‹Ÿå…¨éƒ¨æ–‡ä»¶è§£å‹\n          await this.sleep(Math.random() * 50);\n          return Array.from({ length: 10 }, () => new Uint8Array(1024));\n        }\n      }\n    ];\n\n    const results = [];\n    for (const testCase of testCases) {\n      const result = await this.runBenchmark(\n        testCase.name, \n        testCase.test,\n        {\n          iterations: 100,\n          metadata: {\n            archiveSize: archiveData.byteLength,\n            format: archiveFormat\n          }\n        }\n      );\n      results.push(result);\n    }\n\n    return results;\n  }\n\n  // è¿è¡Œå†…å­˜å‹åŠ›æµ‹è¯•\n  async runMemoryStressTest(maxMemoryMB: number = 100) {\n    const chunkSize = 1024 * 1024; // 1MB\n    const chunks: ArrayBuffer[] = [];\n\n    return await this.runBenchmark(\n      `å†…å­˜å‹åŠ›æµ‹è¯• (${maxMemoryMB}MB)`,\n      async () => {\n        // åˆ†é…å†…å­˜\n        if (chunks.length < maxMemoryMB) {\n          const chunk = new ArrayBuffer(chunkSize);\n          const view = new Uint8Array(chunk);\n          // å†™å…¥æ•°æ®ç¡®ä¿å†…å­˜è¢«å ç”¨\n          for (let i = 0; i < chunkSize; i += 1024) {\n            view[i] = Math.floor(Math.random() * 256);\n          }\n          chunks.push(chunk);\n        }\n\n        // éšæœºè®¿é—®å·²åˆ†é…çš„å†…å­˜\n        if (chunks.length > 0) {\n          const randomChunk = chunks[Math.floor(Math.random() * chunks.length)];\n          const view = new Uint8Array(randomChunk);\n          const sum = Array.from(view.slice(0, 1024)).reduce((a, b) => a + b, 0);\n        }\n\n        // å®šæœŸæ¸…ç†ä¸€äº›å†…å­˜\n        if (chunks.length > maxMemoryMB * 0.8 && Math.random() < 0.1) {\n          chunks.splice(0, Math.floor(chunks.length * 0.1));\n        }\n      },\n      {\n        iterations: 1000,\n        measureMemory: true,\n        metadata: {\n          maxMemoryMB,\n          testType: 'memory-stress'\n        }\n      }\n    );\n  }\n\n  // ç”Ÿæˆæ€§èƒ½æŠ¥å‘Š\n  generateReport(): string {\n    const report: string[] = [];\n    \n    report.push('# ZhugeExtract æ€§èƒ½åŸºå‡†æµ‹è¯•æŠ¥å‘Š');\n    report.push('');\n    report.push(`ç”Ÿæˆæ—¶é—´: ${new Date().toISOString()}`);\n    report.push(`æ€»æµ‹è¯•æ•°: ${this.results.length}`);\n    report.push('');\n\n    // æ±‡æ€»ç»Ÿè®¡\n    report.push('## æµ‹è¯•æ±‡æ€»');\n    report.push('');\n    report.push('| æµ‹è¯•åç§° | è¿­ä»£æ¬¡æ•° | å¹³å‡è€—æ—¶(ms) | æœ€å°è€—æ—¶(ms) | æœ€å¤§è€—æ—¶(ms) | OPS | å†…å­˜å˜åŒ–(MB) |');\n    report.push('|---------|---------|-------------|-------------|-------------|-----|-------------|');\n\n    for (const result of this.results) {\n      const memoryDeltaMB = (result.memoryUsage.delta / 1024 / 1024).toFixed(2);\n      report.push(\n        `| ${result.name} | ${result.iterations} | ${result.averageTime.toFixed(2)} | ${result.minTime.toFixed(2)} | ${result.maxTime.toFixed(2)} | ${result.operationsPerSecond.toFixed(0)} | ${memoryDeltaMB} |`\n      );\n    }\n\n    report.push('');\n\n    // è¯¦ç»†ç»“æœ\n    report.push('## è¯¦ç»†æµ‹è¯•ç»“æœ');\n    report.push('');\n\n    for (const result of this.results) {\n      report.push(`### ${result.name}`);\n      report.push('');\n      report.push(`- **è¿­ä»£æ¬¡æ•°**: ${result.iterations}`);\n      report.push(`- **æ€»è€—æ—¶**: ${result.totalTime.toFixed(2)}ms`);\n      report.push(`- **å¹³å‡è€—æ—¶**: ${result.averageTime.toFixed(2)}ms`);\n      report.push(`- **æœ€å°è€—æ—¶**: ${result.minTime.toFixed(2)}ms`);\n      report.push(`- **æœ€å¤§è€—æ—¶**: ${result.maxTime.toFixed(2)}ms`);\n      report.push(`- **ä¸­ä½æ•°è€—æ—¶**: ${result.medianTime.toFixed(2)}ms`);\n      report.push(`- **æ¯ç§’æ“ä½œæ•°**: ${result.operationsPerSecond.toFixed(0)} ops/sec`);\n      report.push('');\n      report.push('**å†…å­˜ä½¿ç”¨æƒ…å†µ**:');\n      report.push(`- åˆå§‹å†…å­˜: ${(result.memoryUsage.initial / 1024 / 1024).toFixed(2)}MB`);\n      report.push(`- å³°å€¼å†…å­˜: ${(result.memoryUsage.peak / 1024 / 1024).toFixed(2)}MB`);\n      report.push(`- æœ€ç»ˆå†…å­˜: ${(result.memoryUsage.final / 1024 / 1024).toFixed(2)}MB`);\n      report.push(`- å†…å­˜å˜åŒ–: ${(result.memoryUsage.delta / 1024 / 1024).toFixed(2)}MB`);\n      report.push('');\n\n      if (result.metadata && Object.keys(result.metadata).length > 0) {\n        report.push('**å…ƒæ•°æ®**:');\n        for (const [key, value] of Object.entries(result.metadata)) {\n          report.push(`- ${key}: ${value}`);\n        }\n        report.push('');\n      }\n    }\n\n    return report.join('\\n');\n  }\n\n  // ä¿å­˜æŠ¥å‘Šåˆ°æ–‡ä»¶\n  saveReport(filePath?: string): string {\n    const report = this.generateReport();\n    const outputPath = filePath || join(process.cwd(), 'benchmark-results', `benchmark-${Date.now()}.md`);\n    \n    writeFileSync(outputPath, report, 'utf8');\n    console.log(`ğŸ“Š åŸºå‡†æµ‹è¯•æŠ¥å‘Šå·²ä¿å­˜åˆ°: ${outputPath}`);\n    \n    return outputPath;\n  }\n\n  // æ¸…ç©ºç»“æœ\n  clearResults(): void {\n    this.results = [];\n  }\n\n  // è·å–æ‰€æœ‰ç»“æœ\n  getResults(): BenchmarkResult[] {\n    return [...this.results];\n  }\n\n  // ç§æœ‰è¾…åŠ©æ–¹æ³•\n  private getMemoryUsage(): number {\n    if (typeof performance !== 'undefined' && performance.memory) {\n      return performance.memory.usedJSHeapSize;\n    }\n    \n    // Node.jsç¯å¢ƒ\n    if (typeof process !== 'undefined' && process.memoryUsage) {\n      return process.memoryUsage().heapUsed;\n    }\n    \n    return 0;\n  }\n\n  private async sleep(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  private printResult(result: BenchmarkResult): void {\n    console.log(`âœ… ${result.name} å®Œæˆ:`);\n    console.log(`   å¹³å‡: ${result.averageTime.toFixed(2)}ms`);\n    console.log(`   èŒƒå›´: ${result.minTime.toFixed(2)}ms - ${result.maxTime.toFixed(2)}ms`);\n    console.log(`   OPS: ${result.operationsPerSecond.toFixed(0)}`);\n    console.log(`   å†…å­˜å˜åŒ–: ${(result.memoryUsage.delta / 1024 / 1024).toFixed(2)}MB`);\n    console.log('');\n  }\n\n  private detectFormat(signature: Uint8Array): string {\n    // ZIP\n    if (signature[0] === 0x50 && signature[1] === 0x4b) return 'zip';\n    // RAR\n    if (signature[0] === 0x52 && signature[1] === 0x61) return 'rar';\n    // 7Z\n    if (signature[0] === 0x37 && signature[1] === 0x7a) return '7z';\n    // TAR\n    if (signature[257] === 0x75 && signature[258] === 0x73) return 'tar';\n    // GZIP\n    if (signature[0] === 0x1f && signature[1] === 0x8b) return 'gz';\n    \n    return 'unknown';\n  }\n}\n\n// å¯¼å‡ºå•ä¾‹å®ä¾‹\nexport const benchmarkRunner = new BenchmarkRunner();","usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/tests/utils/global-setup.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'config' is defined but never used. Allowed unused args must match /^_/u.","line":5,"column":28,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":34}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { chromium, FullConfig } from '@playwright/test';\nimport fs from 'fs';\nimport path from 'path';\n\nasync function globalSetup(config: FullConfig) {\n  console.log('ğŸš€ å¼€å§‹å…¨å±€æµ‹è¯•è®¾ç½®...');\n\n  // åˆ›å»ºæµ‹è¯•ç»“æœç›®å½•\n  const testDirs = [\n    'test-results',\n    'test-results/e2e-artifacts',\n    'test-results/screenshots',\n    'test-results/videos',\n    'playwright-report',\n    'coverage'\n  ];\n\n  for (const dir of testDirs) {\n    const fullPath = path.resolve(dir);\n    if (!fs.existsSync(fullPath)) {\n      fs.mkdirSync(fullPath, { recursive: true });\n    }\n  }\n\n  // å¯åŠ¨æµè§ˆå™¨è¿›è¡Œé¢„çƒ­\n  const browser = await chromium.launch({\n    args: [\n      '--enable-features=SharedArrayBuffer',\n      '--cross-origin-embedder-policy=require-corp',\n      '--cross-origin-opener-policy=same-origin'\n    ]\n  });\n\n  // åˆ›å»ºæµ‹è¯•é¡µé¢å¹¶é¢„åŠ è½½\n  const context = await browser.newContext({\n    viewport: { width: 1280, height: 720 }\n  });\n  \n  const page = await context.newPage();\n  \n  try {\n    // é¢„çƒ­åº”ç”¨\n    await page.goto('http://localhost:4173');\n    await page.waitForLoadState('networkidle');\n  } catch (error) {\n    console.warn('âš ï¸ æ— æ³•é¢„çƒ­åº”ç”¨ï¼Œå¯èƒ½æœåŠ¡å™¨æœªå¯åŠ¨');\n  }\n\n  await browser.close();\n\n  // ç”Ÿæˆæµ‹è¯•æ•°æ®æ–‡ä»¶\n  await generateTestFixtures();\n\n  console.log('âœ… å…¨å±€æµ‹è¯•è®¾ç½®å®Œæˆ');\n}\n\nasync function generateTestFixtures() {\n  const fixturesDir = path.resolve('tests/fixtures');\n  \n  if (!fs.existsSync(fixturesDir)) {\n    fs.mkdirSync(fixturesDir, { recursive: true });\n  }\n\n  // ç”ŸæˆZIPæµ‹è¯•æ–‡ä»¶\n  const zipBuffer = Buffer.from([\n    0x50, 0x4b, 0x03, 0x04, 0x14, 0x00, 0x00, 0x00, 0x08, 0x00,\n    // ... ZIPæ–‡ä»¶å¤´å’Œæ•°æ®\n    0x50, 0x4b, 0x05, 0x06, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,\n    0x01, 0x00, 0x2e, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00,\n    0x00, 0x00\n  ]);\n  \n  fs.writeFileSync(path.join(fixturesDir, 'test.zip'), zipBuffer);\n\n  // ç”ŸæˆRARæµ‹è¯•æ–‡ä»¶ç­¾å\n  const rarBuffer = Buffer.from([\n    0x52, 0x61, 0x72, 0x21, 0x1a, 0x07, 0x01, 0x00,\n    // RARæ–‡ä»¶ç­¾å\n  ]);\n  \n  fs.writeFileSync(path.join(fixturesDir, 'test.rar'), rarBuffer);\n\n  // ç”Ÿæˆ7Zæµ‹è¯•æ–‡ä»¶ç­¾å\n  const sevenZBuffer = Buffer.from([\n    0x37, 0x7a, 0xbc, 0xaf, 0x27, 0x1c, 0x00, 0x04\n  ]);\n  \n  fs.writeFileSync(path.join(fixturesDir, 'test.7z'), sevenZBuffer);\n\n  console.log('ğŸ“¦ æµ‹è¯•æ•°æ®æ–‡ä»¶ç”Ÿæˆå®Œæˆ');\n}\n\nexport default globalSetup;","usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/tests/utils/global-teardown.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'config' is defined but never used. Allowed unused args must match /^_/u.","line":5,"column":31,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":37}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { FullConfig } from '@playwright/test';\nimport fs from 'fs';\nimport path from 'path';\n\nasync function globalTeardown(config: FullConfig) {\n  console.log('ğŸ§¹ å¼€å§‹å…¨å±€æµ‹è¯•æ¸…ç†...');\n\n  // æ¸…ç†ä¸´æ—¶æµ‹è¯•æ–‡ä»¶\n  const tempDirs = [\n    'tests/fixtures/temp',\n    'test-results/temp'\n  ];\n\n  for (const dir of tempDirs) {\n    const fullPath = path.resolve(dir);\n    if (fs.existsSync(fullPath)) {\n      fs.rmSync(fullPath, { recursive: true, force: true });\n    }\n  }\n\n  // ç”Ÿæˆæµ‹è¯•æŠ¥å‘Šæ‘˜è¦\n  generateTestSummary();\n\n  console.log('âœ… å…¨å±€æµ‹è¯•æ¸…ç†å®Œæˆ');\n}\n\nfunction generateTestSummary() {\n  const summaryPath = path.resolve('test-results/summary.json');\n  const summary = {\n    timestamp: new Date().toISOString(),\n    testRun: 'completed',\n    environment: process.env.NODE_ENV || 'test',\n    artifacts: {\n      screenshots: fs.existsSync('test-results/screenshots'),\n      videos: fs.existsSync('test-results/videos'),\n      coverage: fs.existsSync('coverage'),\n      htmlReport: fs.existsSync('playwright-report')\n    }\n  };\n\n  fs.writeFileSync(summaryPath, JSON.stringify(summary, null, 2));\n  console.log('ğŸ“Š æµ‹è¯•æ‘˜è¦å·²ç”Ÿæˆ');\n}\n\nexport default globalTeardown;","usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/tests/utils/performance-helpers.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'vi' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":12},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":180,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":180,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4564,4567],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4564,4567],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":180,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":180,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4571,4574],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4571,4574],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":229,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":229,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6108,6111],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6108,6111],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":262,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":262,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7156,7159],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7156,7159],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":265,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":265,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7314,7317],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7314,7317],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { vi } from 'vitest';\n\n/**\n * æ€§èƒ½æµ‹è¯•è¾…åŠ©å·¥å…·\n */\nexport class PerformanceHelpers {\n  private static measurements: Map<string, number> = new Map();\n\n  // å¼€å§‹æ€§èƒ½æµ‹é‡\n  static startMeasurement(label: string): void {\n    this.measurements.set(label, performance.now());\n  }\n\n  // ç»“æŸæ€§èƒ½æµ‹é‡å¹¶è¿”å›è€—æ—¶\n  static endMeasurement(label: string): number {\n    const startTime = this.measurements.get(label);\n    if (!startTime) {\n      throw new Error(`No measurement started for label: ${label}`);\n    }\n    \n    const endTime = performance.now();\n    const duration = endTime - startTime;\n    this.measurements.delete(label);\n    \n    return duration;\n  }\n\n  // æµ‹é‡å¼‚æ­¥å‡½æ•°æ‰§è¡Œæ—¶é—´\n  static async measureAsync<T>(\n    fn: () => Promise<T>,\n    label: string = 'async-operation'\n  ): Promise<{ result: T; duration: number }> {\n    this.startMeasurement(label);\n    const result = await fn();\n    const duration = this.endMeasurement(label);\n    \n    return { result, duration };\n  }\n\n  // æµ‹é‡åŒæ­¥å‡½æ•°æ‰§è¡Œæ—¶é—´\n  static measureSync<T>(\n    fn: () => T,\n    label: string = 'sync-operation'\n  ): { result: T; duration: number } {\n    this.startMeasurement(label);\n    const result = fn();\n    const duration = this.endMeasurement(label);\n    \n    return { result, duration };\n  }\n\n  // æ¨¡æ‹Ÿå†…å­˜å‹åŠ›æµ‹è¯•\n  static simulateMemoryPressure(sizeMB: number): ArrayBuffer[] {\n    const buffers: ArrayBuffer[] = [];\n    const chunkSize = 1024 * 1024; // 1MB chunks\n    \n    for (let i = 0; i < sizeMB; i++) {\n      const buffer = new ArrayBuffer(chunkSize);\n      const view = new Uint8Array(buffer);\n      \n      // å¡«å……æ•°æ®ä»¥ç¡®ä¿å†…å­˜è¢«å®é™…å ç”¨\n      for (let j = 0; j < chunkSize; j += 1024) {\n        view[j] = Math.floor(Math.random() * 256);\n      }\n      \n      buffers.push(buffer);\n    }\n    \n    return buffers;\n  }\n\n  // æ¸…ç†å†…å­˜å‹åŠ›æµ‹è¯•çš„ç¼“å†²åŒº\n  static cleanupMemoryPressure(buffers: ArrayBuffer[]): void {\n    buffers.length = 0;\n    \n    // å¼ºåˆ¶åƒåœ¾å›æ”¶ (åœ¨æµ‹è¯•ç¯å¢ƒä¸­)\n    if (global.gc) {\n      global.gc();\n    }\n  }\n\n  // ç›‘æ§å†…å­˜ä½¿ç”¨æƒ…å†µ\n  static getMemoryUsage(): {\n    used: number;\n    total: number;\n    percentage: number;\n  } {\n    const memory = performance.memory || {\n      usedJSHeapSize: 50 * 1024 * 1024,\n      totalJSHeapSize: 100 * 1024 * 1024,\n      jsHeapSizeLimit: 2 * 1024 * 1024 * 1024\n    };\n    \n    return {\n      used: memory.usedJSHeapSize,\n      total: memory.totalJSHeapSize,\n      percentage: (memory.usedJSHeapSize / memory.totalJSHeapSize) * 100\n    };\n  }\n\n  // ç­‰å¾…å†…å­˜ç¨³å®š\n  static async waitForMemoryStable(\n    maxWaitMs: number = 5000\n  ): Promise<void> {\n    const startTime = performance.now();\n    let lastMemoryUsage = this.getMemoryUsage().used;\n    \n    while (performance.now() - startTime < maxWaitMs) {\n      await new Promise(resolve => setTimeout(resolve, 100));\n      \n      const currentMemoryUsage = this.getMemoryUsage().used;\n      const memoryDiff = Math.abs(currentMemoryUsage - lastMemoryUsage);\n      \n      // å¦‚æœå†…å­˜ä½¿ç”¨å˜åŒ–å°äº1MBï¼Œè®¤ä¸ºå·²ç¨³å®š\n      if (memoryDiff < 1024 * 1024) {\n        return;\n      }\n      \n      lastMemoryUsage = currentMemoryUsage;\n    }\n  }\n\n  // åˆ›å»ºæ€§èƒ½åŸºå‡†æµ‹è¯•\n  static createBenchmark(\n    name: string,\n    fn: () => Promise<void> | void,\n    iterations: number = 100\n  ) {\n    return async () => {\n      const durations: number[] = [];\n      const memoryUsages: number[] = [];\n      \n      // é¢„çƒ­\n      for (let i = 0; i < 5; i++) {\n        await fn();\n      }\n      \n      // ç­‰å¾…å†…å­˜ç¨³å®š\n      await this.waitForMemoryStable();\n      \n      // æ­£å¼æµ‹è¯•\n      for (let i = 0; i < iterations; i++) {\n        const initialMemory = this.getMemoryUsage().used;\n        const startTime = performance.now();\n        \n        await fn();\n        \n        const endTime = performance.now();\n        const finalMemory = this.getMemoryUsage().used;\n        \n        durations.push(endTime - startTime);\n        memoryUsages.push(finalMemory - initialMemory);\n      }\n      \n      // è®¡ç®—ç»Ÿè®¡ä¿¡æ¯\n      const avgDuration = durations.reduce((a, b) => a + b, 0) / durations.length;\n      const minDuration = Math.min(...durations);\n      const maxDuration = Math.max(...durations);\n      const avgMemory = memoryUsages.reduce((a, b) => a + b, 0) / memoryUsages.length;\n      \n      return {\n        name,\n        iterations,\n        duration: {\n          average: avgDuration,\n          min: minDuration,\n          max: maxDuration,\n          median: durations.sort((a, b) => a - b)[Math.floor(durations.length / 2)]\n        },\n        memory: {\n          average: avgMemory,\n          peak: Math.max(...memoryUsages)\n        }\n      };\n    };\n  }\n\n  // æ€§èƒ½æ–­è¨€è¾…åŠ©å‡½æ•°\n  static expectPerformance(\n    operation: () => Promise<any> | any,\n    constraints: {\n      maxDuration?: number;\n      maxMemory?: number;    // bytes\n      minThroughput?: number; // operations per second\n    }\n  ) {\n    return async () => {\n      const startTime = performance.now();\n      const initialMemory = this.getMemoryUsage().used;\n      \n      await operation();\n      \n      const endTime = performance.now();\n      const finalMemory = this.getMemoryUsage().used;\n      \n      const duration = endTime - startTime;\n      const memoryUsed = finalMemory - initialMemory;\n      \n      if (constraints.maxDuration && duration > constraints.maxDuration) {\n        throw new Error(\n          `Operation took ${duration.toFixed(2)}ms, exceeding limit of ${constraints.maxDuration}ms`\n        );\n      }\n      \n      if (constraints.maxMemory && memoryUsed > constraints.maxMemory) {\n        throw new Error(\n          `Operation used ${(memoryUsed / 1024 / 1024).toFixed(2)}MB, exceeding limit of ${(constraints.maxMemory / 1024 / 1024).toFixed(2)}MB`\n        );\n      }\n      \n      if (constraints.minThroughput) {\n        const throughput = 1000 / duration; // operations per second\n        if (throughput < constraints.minThroughput) {\n          throw new Error(\n            `Operation throughput ${throughput.toFixed(2)} ops/sec is below minimum ${constraints.minThroughput} ops/sec`\n          );\n        }\n      }\n      \n      return {\n        duration,\n        memoryUsed,\n        throughput: 1000 / duration\n      };\n    };\n  }\n\n  // ç”Ÿæˆæ€§èƒ½æŠ¥å‘Š\n  static generatePerformanceReport(results: any[]): string {\n    let report = '# Performance Test Report\\n\\n';\n    report += `Generated: ${new Date().toISOString()}\\n\\n`;\n    \n    results.forEach(result => {\n      report += `## ${result.name}\\n`;\n      report += `- Iterations: ${result.iterations}\\n`;\n      report += `- Average Duration: ${result.duration.average.toFixed(2)}ms\\n`;\n      report += `- Min Duration: ${result.duration.min.toFixed(2)}ms\\n`;\n      report += `- Max Duration: ${result.duration.max.toFixed(2)}ms\\n`;\n      report += `- Median Duration: ${result.duration.median.toFixed(2)}ms\\n`;\n      report += `- Average Memory: ${(result.memory.average / 1024 / 1024).toFixed(2)}MB\\n`;\n      report += `- Peak Memory: ${(result.memory.peak / 1024 / 1024).toFixed(2)}MB\\n\\n`;\n    });\n    \n    return report;\n  }\n\n  // æ¸…ç†æ‰€æœ‰æµ‹é‡æ•°æ®\n  static cleanup(): void {\n    this.measurements.clear();\n  }\n}\n\n// æ€§èƒ½æµ‹è¯•è£…é¥°å™¨\nexport function benchmark(\n  name: string,\n  iterations: number = 100,\n  constraints?: {\n    maxDuration?: number;\n    maxMemory?: number;\n  }\n) {\n  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n    const originalMethod = descriptor.value;\n    \n    descriptor.value = async function (...args: any[]) {\n      const benchmark = PerformanceHelpers.createBenchmark(\n        name,\n        () => originalMethod.apply(this, args),\n        iterations\n      );\n      \n      const result = await benchmark();\n      \n      // æ£€æŸ¥çº¦æŸæ¡ä»¶\n      if (constraints) {\n        if (constraints.maxDuration && result.duration.average > constraints.maxDuration) {\n          throw new Error(\n            `Benchmark ${name} exceeded max duration: ${result.duration.average.toFixed(2)}ms > ${constraints.maxDuration}ms`\n          );\n        }\n        \n        if (constraints.maxMemory && result.memory.average > constraints.maxMemory) {\n          throw new Error(\n            `Benchmark ${name} exceeded max memory: ${(result.memory.average / 1024 / 1024).toFixed(2)}MB > ${(constraints.maxMemory / 1024 / 1024).toFixed(2)}MB`\n          );\n        }\n      }\n      \n      return result;\n    };\n    \n    return descriptor;\n  };\n}\n\nexport default PerformanceHelpers;","usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/tests/utils/test-helpers.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":133,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":133,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3426,3429],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3426,3429],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":147,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":147,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3879,3882],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3879,3882],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":160,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":160,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4236,4239],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4236,4239],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":175,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":175,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4724,4727],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4724,4727],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'initialProps' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":182,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":182,"endColumn":23}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { vi } from 'vitest';\nimport { render, RenderOptions } from '@testing-library/react';\nimport { ReactElement } from 'react';\n\n// æµ‹è¯•å·¥å…·å‡½æ•°\nexport class TestHelpers {\n  // åˆ›å»ºæ¨¡æ‹Ÿæ–‡ä»¶\n  static createMockFile(\n    name: string,\n    content: string | ArrayBuffer,\n    type: string = 'text/plain'\n  ): File {\n    const file = new File([content], name, { type });\n    return file;\n  }\n\n  // åˆ›å»ºæ¨¡æ‹Ÿå‹ç¼©æ–‡ä»¶\n  static createMockArchiveFile(format: string, size: number = 1024): File {\n    const signatures = {\n      'zip': [0x50, 0x4b, 0x03, 0x04],\n      'rar': [0x52, 0x61, 0x72, 0x21],\n      '7z': [0x37, 0x7a, 0xbc, 0xaf],\n      'tar': [0x75, 0x73, 0x74, 0x61, 0x72],\n      'gz': [0x1f, 0x8b, 0x08, 0x00]\n    };\n\n    const signature = signatures[format as keyof typeof signatures] || [0x00];\n    const buffer = new ArrayBuffer(size);\n    const view = new Uint8Array(buffer);\n    \n    // è®¾ç½®æ–‡ä»¶ç­¾å\n    signature.forEach((byte, index) => {\n      view[index] = byte;\n    });\n\n    return new File([buffer], `test.${format}`, { \n      type: `application/${format}` \n    });\n  }\n\n  // æ¨¡æ‹Ÿå‹ç¼©æ–‡ä»¶ç»“æ„\n  static createMockArchiveStructure(fileCount: number = 5) {\n    const structure = [];\n    \n    for (let i = 0; i < fileCount; i++) {\n      structure.push({\n        name: `file-${i}.txt`,\n        path: `folder-${Math.floor(i / 2)}/file-${i}.txt`,\n        size: Math.random() * 10000,\n        isDirectory: false,\n        lastModified: new Date(Date.now() - Math.random() * 10000000)\n      });\n    }\n\n    // æ·»åŠ ä¸€äº›ç›®å½•\n    structure.push({\n      name: 'folder-0',\n      path: 'folder-0/',\n      size: 0,\n      isDirectory: true,\n      lastModified: new Date()\n    });\n\n    return structure;\n  }\n\n  // åˆ›å»ºæ€§èƒ½æµ‹è¯•æ•°æ®\n  static createPerformanceTestData(sizeInMB: number) {\n    const size = sizeInMB * 1024 * 1024;\n    const buffer = new ArrayBuffer(size);\n    const view = new Uint8Array(buffer);\n    \n    // ç”Ÿæˆéšæœºæ•°æ®\n    for (let i = 0; i < size; i++) {\n      view[i] = Math.floor(Math.random() * 256);\n    }\n    \n    return buffer;\n  }\n\n  // ç­‰å¾…å¼‚æ­¥æ“ä½œå®Œæˆ\n  static async waitForAsync(ms: number = 0) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  // æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿ\n  static mockNetworkDelay(delay: number = 100) {\n    const originalFetch = global.fetch;\n    \n    global.fetch = vi.fn((...args) => {\n      return new Promise(resolve => {\n        setTimeout(() => {\n          resolve(originalFetch.apply(global, args));\n        }, delay);\n      });\n    });\n\n    return () => {\n      global.fetch = originalFetch;\n    };\n  }\n\n  // æ¨¡æ‹Ÿå†…å­˜ä½¿ç”¨æƒ…å†µ\n  static mockMemoryUsage(usedMB: number, totalMB: number = 1000) {\n    const mockPerformance = {\n      ...global.performance,\n      memory: {\n        usedJSHeapSize: usedMB * 1024 * 1024,\n        totalJSHeapSize: totalMB * 1024 * 1024,\n        jsHeapSizeLimit: totalMB * 2 * 1024 * 1024\n      }\n    };\n\n    Object.defineProperty(global, 'performance', {\n      value: mockPerformance,\n      writable: true\n    });\n  }\n\n  // åˆ›å»ºé”™è¯¯æµ‹è¯•åœºæ™¯\n  static createErrorScenarios() {\n    return {\n      corruptedFile: this.createMockFile('corrupted.zip', 'invalid content'),\n      oversizedFile: this.createMockArchiveFile('zip', 100 * 1024 * 1024),\n      passwordProtected: this.createMockArchiveFile('zip', 1024),\n      networkError: new Error('Network request failed'),\n      memoryError: new Error('Out of memory'),\n      parseError: new Error('Failed to parse archive')\n    };\n  }\n\n  // æ–­è¨€å·¥å…·\n  static expectArchiveStructure(structure: any[]) {\n    expect(Array.isArray(structure)).toBe(true);\n    expect(structure.length).toBeGreaterThan(0);\n    \n    structure.forEach(item => {\n      expect(item).toHaveProperty('name');\n      expect(item).toHaveProperty('path');\n      expect(item).toHaveProperty('size');\n      expect(item).toHaveProperty('isDirectory');\n      expect(typeof item.isDirectory).toBe('boolean');\n    });\n  }\n\n  // æ€§èƒ½æ–­è¨€\n  static expectPerformance(operation: () => Promise<any>, maxTimeMs: number) {\n    return async () => {\n      const startTime = performance.now();\n      await operation();\n      const endTime = performance.now();\n      const duration = endTime - startTime;\n      \n      expect(duration).toBeLessThan(maxTimeMs);\n      return duration;\n    };\n  }\n\n  // å†…å­˜æ–­è¨€\n  static expectMemoryUsage(operation: () => Promise<any>, maxMemoryMB: number) {\n    return async () => {\n      const initialMemory = performance.memory?.usedJSHeapSize || 0;\n      await operation();\n      const finalMemory = performance.memory?.usedJSHeapSize || 0;\n      const memoryUsed = (finalMemory - initialMemory) / (1024 * 1024);\n      \n      expect(memoryUsed).toBeLessThan(maxMemoryMB);\n      return memoryUsed;\n    };\n  }\n}\n\n// Reactç»„ä»¶æµ‹è¯•å·¥å…·\ninterface CustomRenderOptions extends Omit<RenderOptions, 'wrapper'> {\n  initialProps?: any;\n}\n\nexport function renderWithContext(\n  ui: ReactElement,\n  options?: CustomRenderOptions\n) {\n  const { initialProps, ...renderOptions } = options || {};\n\n  // å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ  Provider åŒ…è£…å™¨\n  return render(ui, renderOptions);\n}\n\n// æµ‹è¯•æ•°æ®ç”Ÿæˆå™¨\nexport class TestDataGenerator {\n  // ç”Ÿæˆéšæœºå­—ç¬¦ä¸²\n  static randomString(length: number = 10): string {\n    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n    let result = '';\n    for (let i = 0; i < length; i++) {\n      result += chars.charAt(Math.floor(Math.random() * chars.length));\n    }\n    return result;\n  }\n\n  // ç”Ÿæˆéšæœºæ–‡ä»¶è·¯å¾„\n  static randomFilePath(depth: number = 3): string {\n    const parts = [];\n    for (let i = 0; i < depth; i++) {\n      parts.push(this.randomString(8));\n    }\n    return `${parts.join('/')  }.txt`;\n  }\n\n  // ç”Ÿæˆæµ‹è¯•ç”¨æˆ·æ•°æ®\n  static generateUserData() {\n    return {\n      id: this.randomString(8),\n      name: this.randomString(12),\n      preferences: {\n        theme: Math.random() > 0.5 ? 'dark' : 'light',\n        language: Math.random() > 0.5 ? 'zh-CN' : 'en-US',\n        compressionLevel: Math.floor(Math.random() * 9) + 1\n      }\n    };\n  }\n\n  // ç”Ÿæˆå‹ç¼©å†å²è®°å½•\n  static generateCompressionHistory(count: number = 10) {\n    const history = [];\n    \n    for (let i = 0; i < count; i++) {\n      history.push({\n        id: this.randomString(16),\n        fileName: `archive-${i}.zip`,\n        originalSize: Math.floor(Math.random() * 1000000),\n        compressedSize: Math.floor(Math.random() * 500000),\n        timestamp: new Date(Date.now() - Math.random() * 10000000),\n        status: Math.random() > 0.8 ? 'failed' : 'completed'\n      });\n    }\n    \n    return history;\n  }\n}\n\n// è‡ªå®šä¹‰åŒ¹é…å™¨\nexport const customMatchers = {\n  toBeValidFile(received: File) {\n    const pass = received instanceof File && \n                 received.name.length > 0 && \n                 received.size >= 0;\n    \n    return {\n      message: () => pass \n        ? `expected ${received} not to be a valid File object`\n        : `expected ${received} to be a valid File object`,\n      pass,\n    };\n  },\n\n  toHaveValidArchiveFormat(received: string) {\n    const validFormats = ['zip', 'rar', '7z', 'tar', 'gz', 'bz2'];\n    const pass = validFormats.includes(received.toLowerCase());\n    \n    return {\n      message: () =>  pass \n        ? `expected ${received} not to be a valid archive format`\n        : `expected ${received} to be one of: ${validFormats.join(', ')}`,\n      pass,\n    };\n  },\n\n  toBeWithinMemoryLimit(received: number, limitMB: number) {\n    const receivedMB = received / (1024 * 1024);\n    const pass = receivedMB <= limitMB;\n    \n    return {\n      message: () => pass \n        ? `expected ${receivedMB.toFixed(2)}MB not to be within ${limitMB}MB limit`\n        : `expected ${receivedMB.toFixed(2)}MB to be within ${limitMB}MB limit`,\n      pass,\n    };\n  }\n};\n\n// å¯¼å‡ºæ‰€æœ‰å·¥å…·\nexport default TestHelpers;","usedDeprecatedRules":[]}]