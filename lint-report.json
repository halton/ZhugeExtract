[{"filePath":"/Users/halton/work/ZhugeExtract/backend/src/config/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/backend/src/database/index.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'db' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":79,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":79,"endColumn":11}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { drizzle } from 'drizzle-orm/postgres-js'\nimport postgres from 'postgres'\nimport { config } from '../config/index.js'\nimport * as schema from './schema.js'\n\nlet connection: postgres.Sql | null = null\nlet db: ReturnType<typeof drizzle> | null = null\n\nexport async function setupDatabase() {\n  if (db) {\n    return db\n  }\n\n  try {\n    // 创建PostgreSQL连接\n    connection = postgres(config.DATABASE_URL, {\n      max: config.DB_POOL_SIZE,\n      idle_timeout: 20,\n      connect_timeout: 10,\n    })\n\n    // 创建Drizzle实例\n    db = drizzle(connection, { \n      schema,\n      logger: config.NODE_ENV === 'development'\n    })\n\n    // 测试连接\n    await connection`SELECT 1 as test`\n    console.log('✅ Database connected successfully')\n\n    return db\n\n  } catch (error) {\n    console.error('❌ Database connection failed:', error)\n    throw error\n  }\n}\n\nexport async function closeDatabase() {\n  if (connection) {\n    await connection.end()\n    connection = null\n    db = null\n    console.log('🔄 Database connection closed')\n  }\n}\n\nexport function getDatabase() {\n  if (!db) {\n    throw new Error('Database not initialized. Call setupDatabase() first.')\n  }\n  return db\n}\n\n// 健康检查\nexport async function checkDatabaseHealth() {\n  try {\n    if (!connection) {\n      throw new Error('No database connection')\n    }\n\n    const result = await connection`SELECT NOW() as current_time`\n    return {\n      status: 'healthy',\n      timestamp: result[0].current_time,\n      pool_size: config.DB_POOL_SIZE\n    }\n  } catch (error) {\n    return {\n      status: 'unhealthy',\n      error: error instanceof Error ? error.message : 'Unknown error'\n    }\n  }\n}\n\n// 数据库迁移和初始化\nexport async function initializeDatabase() {\n  const db = getDatabase()\n  \n  try {\n    // 这里可以添加初始化数据\n    console.log('📊 Database initialized successfully')\n  } catch (error) {\n    console.error('❌ Database initialization failed:', error)\n    throw error\n  }\n}\n\nexport { schema }\nexport type Database = NonNullable<typeof db>","usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/backend/src/database/schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/backend/src/middleware/auth.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'reply' is defined but never used. Allowed unused args must match /^_/u.","line":66,"column":71,"nodeType":null,"messageId":"unusedVar","endLine":66,"endColumn":76}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { FastifyRequest, FastifyReply } from 'fastify'\nimport { AuthService } from '../services/auth.service.js'\n\nconst authService = new AuthService()\n\ndeclare module 'fastify' {\n  interface FastifyRequest {\n    user?: {\n      userId: string\n      email: string\n      username: string\n      sessionId: string\n    }\n  }\n}\n\nexport async function authMiddleware(request: FastifyRequest, reply: FastifyReply) {\n  try {\n    const authHeader = request.headers.authorization\n    \n    if (!authHeader) {\n      return reply.status(401).send({\n        success: false,\n        error: {\n          code: 'MISSING_TOKEN',\n          message: '缺少认证令牌'\n        }\n      })\n    }\n\n    const token = authHeader.replace(/^Bearer\\s+/, '')\n    \n    if (!token) {\n      return reply.status(401).send({\n        success: false,\n        error: {\n          code: 'INVALID_TOKEN_FORMAT',\n          message: '令牌格式无效'\n        }\n      })\n    }\n\n    // 验证令牌\n    const payload = await authService.verifyToken(token)\n    \n    // 将用户信息添加到请求对象\n    request.user = {\n      userId: payload.userId,\n      email: payload.email,\n      username: payload.username,\n      sessionId: payload.sessionId\n    }\n\n  } catch (error) {\n    return reply.status(401).send({\n      success: false,\n      error: {\n        code: 'TOKEN_VERIFICATION_FAILED',\n        message: error instanceof Error ? error.message : '令牌验证失败'\n      }\n    })\n  }\n}\n\n// 可选认证中间件（不强制要求认证）\nexport async function optionalAuthMiddleware(request: FastifyRequest, reply: FastifyReply) {\n  try {\n    const authHeader = request.headers.authorization\n    \n    if (authHeader) {\n      const token = authHeader.replace(/^Bearer\\s+/, '')\n      \n      if (token) {\n        const payload = await authService.verifyToken(token)\n        request.user = {\n          userId: payload.userId,\n          email: payload.email,\n          username: payload.username,\n          sessionId: payload.sessionId\n        }\n      }\n    }\n    \n    // 即使没有认证也继续执行\n  } catch (error) {\n    // 忽略认证错误，继续执行\n    request.log.warn('Optional auth failed:', error)\n  }\n}\n\n// 角色检查中间件\nexport function requireRole(roles: string[]) {\n  return async (request: FastifyRequest, reply: FastifyReply) => {\n    if (!request.user) {\n      return reply.status(401).send({\n        success: false,\n        error: {\n          code: 'AUTHENTICATION_REQUIRED',\n          message: '需要认证'\n        }\n      })\n    }\n\n    // 获取用户详细信息以检查角色\n    const user = await authService.getUserById(request.user.userId)\n    \n    if (!user) {\n      return reply.status(401).send({\n        success: false,\n        error: {\n          code: 'USER_NOT_FOUND',\n          message: '用户不存在'\n        }\n      })\n    }\n\n    // 检查用户角色（这里简化处理，实际项目中可能需要更复杂的角色系统）\n    const userRole = user.subscriptionTier || 'free'\n    \n    if (!roles.includes(userRole)) {\n      return reply.status(403).send({\n        success: false,\n        error: {\n          code: 'INSUFFICIENT_PERMISSIONS',\n          message: '权限不足'\n        }\n      })\n    }\n  }\n}\n\n// 资源所有者检查中间件\nexport function requireOwnership(getResourceUserId: (request: FastifyRequest) => Promise<string>) {\n  return async (request: FastifyRequest, reply: FastifyReply) => {\n    if (!request.user) {\n      return reply.status(401).send({\n        success: false,\n        error: {\n          code: 'AUTHENTICATION_REQUIRED',\n          message: '需要认证'\n        }\n      })\n    }\n\n    try {\n      const resourceUserId = await getResourceUserId(request)\n      \n      if (resourceUserId !== request.user.userId) {\n        return reply.status(403).send({\n          success: false,\n          error: {\n            code: 'ACCESS_DENIED',\n            message: '无权访问此资源'\n          }\n        })\n      }\n    } catch (error) {\n      return reply.status(500).send({\n        success: false,\n        error: {\n          code: 'OWNERSHIP_CHECK_FAILED',\n          message: '资源所有权检查失败'\n        }\n      })\n    }\n  }\n}","usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/backend/src/routes/auth.ts","messages":[{"ruleId":"@typescript-eslint/ban-ts-comment","severity":2,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":209,"column":7,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":209,"endColumn":48,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[5972,6013],"text":"// @ts-expect-error - user属性在authenticate中间件中添加"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}]},{"ruleId":"@typescript-eslint/ban-ts-comment","severity":2,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":261,"column":7,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":261,"endColumn":20,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[7419,7432],"text":"// @ts-expect-error"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}]},{"ruleId":"@typescript-eslint/ban-ts-comment","severity":2,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":309,"column":7,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":309,"endColumn":20,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[8632,8645],"text":"// @ts-expect-error"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}]},{"ruleId":"@typescript-eslint/ban-ts-comment","severity":2,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":349,"column":7,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":349,"endColumn":20,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[9755,9768],"text":"// @ts-expect-error"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify'\nimport { z } from 'zod'\nimport { AuthService } from '../services/auth.service.js'\n\nconst authService = new AuthService()\n\n// 验证模式\nconst registerSchema = z.object({\n  email: z.string().email('请输入有效的邮箱地址'),\n  username: z.string().min(3, '用户名至少3个字符').max(50, '用户名最多50个字符').regex(/^[a-zA-Z0-9_-]+$/, '用户名只能包含字母、数字、下划线和连字符'),\n  password: z.string().min(8, '密码至少8个字符').max(128, '密码最多128个字符'),\n  displayName: z.string().max(100, '显示名称最多100个字符').optional()\n})\n\nconst loginSchema = z.object({\n  email: z.string().email('请输入有效的邮箱地址'),\n  password: z.string().min(1, '请输入密码')\n})\n\nconst refreshTokenSchema = z.object({\n  refreshToken: z.string().min(1, '刷新令牌不能为空')\n})\n\nconst changePasswordSchema = z.object({\n  currentPassword: z.string().min(1, '请输入当前密码'),\n  newPassword: z.string().min(8, '新密码至少8个字符').max(128, '新密码最多128个字符')\n})\n\nconst updateProfileSchema = z.object({\n  displayName: z.string().max(100, '显示名称最多100个字符').optional(),\n  avatarUrl: z.string().url('请输入有效的头像URL').optional(),\n  settings: z.record(z.any()).optional()\n})\n\nexport default async function authRoutes(fastify: FastifyInstance) {\n  \n  // 用户注册\n  fastify.post('/register', {\n    schema: {\n      tags: ['Authentication'],\n      summary: '用户注册',\n      body: {\n        type: 'object',\n        required: ['email', 'username', 'password'],\n        properties: {\n          email: { type: 'string', format: 'email', description: '邮箱地址' },\n          username: { type: 'string', minLength: 3, maxLength: 50, description: '用户名' },\n          password: { type: 'string', minLength: 8, maxLength: 128, description: '密码' },\n          displayName: { type: 'string', maxLength: 100, description: '显示名称' }\n        }\n      },\n      response: {\n        201: {\n          type: 'object',\n          properties: {\n            success: { type: 'boolean' },\n            data: {\n              type: 'object',\n              properties: {\n                user: {\n                  type: 'object',\n                  properties: {\n                    id: { type: 'string' },\n                    email: { type: 'string' },\n                    username: { type: 'string' },\n                    displayName: { type: 'string' },\n                    createdAt: { type: 'string', format: 'date-time' }\n                  }\n                },\n                token: { type: 'string' },\n                refreshToken: { type: 'string' },\n                expiresAt: { type: 'string', format: 'date-time' }\n              }\n            },\n            message: { type: 'string' }\n          }\n        }\n      }\n    }\n  }, async (request: FastifyRequest, reply: FastifyReply) => {\n    try {\n      const data = registerSchema.parse(request.body)\n      \n      const result = await authService.register(data)\n      \n      return reply.status(201).send({\n        success: true,\n        data: result,\n        message: '注册成功'\n      })\n    } catch (error) {\n      return reply.status(400).send({\n        success: false,\n        error: {\n          code: 'REGISTRATION_FAILED',\n          message: error instanceof Error ? error.message : '注册失败'\n        }\n      })\n    }\n  })\n\n  // 用户登录\n  fastify.post('/login', {\n    schema: {\n      tags: ['Authentication'],\n      summary: '用户登录',\n      body: {\n        type: 'object',\n        required: ['email', 'password'],\n        properties: {\n          email: { type: 'string', format: 'email', description: '邮箱地址' },\n          password: { type: 'string', description: '密码' }\n        }\n      },\n      response: {\n        200: {\n          type: 'object',\n          properties: {\n            success: { type: 'boolean' },\n            data: {\n              type: 'object',\n              properties: {\n                user: {\n                  type: 'object',\n                  properties: {\n                    id: { type: 'string' },\n                    email: { type: 'string' },\n                    username: { type: 'string' },\n                    displayName: { type: 'string' }\n                  }\n                },\n                token: { type: 'string' },\n                refreshToken: { type: 'string' },\n                expiresAt: { type: 'string', format: 'date-time' }\n              }\n            },\n            message: { type: 'string' }\n          }\n        }\n      }\n    }\n  }, async (request: FastifyRequest, reply: FastifyReply) => {\n    try {\n      const credentials = loginSchema.parse(request.body)\n      \n      const result = await authService.login(credentials)\n      \n      return reply.send({\n        success: true,\n        data: result,\n        message: '登录成功'\n      })\n    } catch (error) {\n      return reply.status(401).send({\n        success: false,\n        error: {\n          code: 'LOGIN_FAILED',\n          message: error instanceof Error ? error.message : '登录失败'\n        }\n      })\n    }\n  })\n\n  // 刷新令牌\n  fastify.post('/refresh', {\n    schema: {\n      tags: ['Authentication'],\n      summary: '刷新访问令牌',\n      body: {\n        type: 'object',\n        required: ['refreshToken'],\n        properties: {\n          refreshToken: { type: 'string', description: '刷新令牌' }\n        }\n      }\n    }\n  }, async (request: FastifyRequest, reply: FastifyReply) => {\n    try {\n      const { refreshToken } = refreshTokenSchema.parse(request.body)\n      \n      const result = await authService.refreshToken(refreshToken)\n      \n      return reply.send({\n        success: true,\n        data: result,\n        message: '令牌刷新成功'\n      })\n    } catch (error) {\n      return reply.status(401).send({\n        success: false,\n        error: {\n          code: 'TOKEN_REFRESH_FAILED',\n          message: error instanceof Error ? error.message : '令牌刷新失败'\n        }\n      })\n    }\n  })\n\n  // 登出\n  fastify.post('/logout', {\n    preHandler: [fastify.authenticate],\n    schema: {\n      tags: ['Authentication'],\n      summary: '用户登出',\n      security: [{ Bearer: [] }]\n    }\n  }, async (request: FastifyRequest, reply: FastifyReply) => {\n    try {\n      // @ts-ignore - user属性在authenticate中间件中添加\n      const { sessionId } = request.user\n      \n      await authService.logout(sessionId)\n      \n      return reply.send({\n        success: true,\n        message: '登出成功'\n      })\n    } catch (error) {\n      return reply.status(500).send({\n        success: false,\n        error: {\n          code: 'LOGOUT_FAILED',\n          message: error instanceof Error ? error.message : '登出失败'\n        }\n      })\n    }\n  })\n\n  // 获取当前用户信息\n  fastify.get('/me', {\n    preHandler: [fastify.authenticate],\n    schema: {\n      tags: ['Authentication'],\n      summary: '获取当前用户信息',\n      security: [{ Bearer: [] }],\n      response: {\n        200: {\n          type: 'object',\n          properties: {\n            success: { type: 'boolean' },\n            data: {\n              type: 'object',\n              properties: {\n                id: { type: 'string' },\n                email: { type: 'string' },\n                username: { type: 'string' },\n                displayName: { type: 'string' },\n                avatarUrl: { type: 'string' },\n                settings: { type: 'object' },\n                subscriptionTier: { type: 'string' },\n                createdAt: { type: 'string', format: 'date-time' },\n                lastLoginAt: { type: 'string', format: 'date-time' }\n              }\n            }\n          }\n        }\n      }\n    }\n  }, async (request: FastifyRequest, reply: FastifyReply) => {\n    try {\n      // @ts-ignore\n      const { userId } = request.user\n      \n      const user = await authService.getUserById(userId)\n      \n      if (!user) {\n        return reply.status(404).send({\n          success: false,\n          error: {\n            code: 'USER_NOT_FOUND',\n            message: '用户不存在'\n          }\n        })\n      }\n      \n      return reply.send({\n        success: true,\n        data: user\n      })\n    } catch (error) {\n      return reply.status(500).send({\n        success: false,\n        error: {\n          code: 'FETCH_USER_FAILED',\n          message: error instanceof Error ? error.message : '获取用户信息失败'\n        }\n      })\n    }\n  })\n\n  // 更新用户资料\n  fastify.put('/profile', {\n    preHandler: [fastify.authenticate],\n    schema: {\n      tags: ['Authentication'],\n      summary: '更新用户资料',\n      security: [{ Bearer: [] }],\n      body: {\n        type: 'object',\n        properties: {\n          displayName: { type: 'string', maxLength: 100, description: '显示名称' },\n          avatarUrl: { type: 'string', format: 'uri', description: '头像URL' },\n          settings: { type: 'object', description: '用户设置' }\n        }\n      }\n    }\n  }, async (request: FastifyRequest, reply: FastifyReply) => {\n    try {\n      // @ts-ignore\n      const { userId } = request.user\n      const updates = updateProfileSchema.parse(request.body)\n      \n      const updatedUser = await authService.updateProfile(userId, updates)\n      \n      return reply.send({\n        success: true,\n        data: updatedUser,\n        message: '资料更新成功'\n      })\n    } catch (error) {\n      return reply.status(400).send({\n        success: false,\n        error: {\n          code: 'PROFILE_UPDATE_FAILED',\n          message: error instanceof Error ? error.message : '资料更新失败'\n        }\n      })\n    }\n  })\n\n  // 修改密码\n  fastify.post('/change-password', {\n    preHandler: [fastify.authenticate],\n    schema: {\n      tags: ['Authentication'],\n      summary: '修改密码',\n      security: [{ Bearer: [] }],\n      body: {\n        type: 'object',\n        required: ['currentPassword', 'newPassword'],\n        properties: {\n          currentPassword: { type: 'string', description: '当前密码' },\n          newPassword: { type: 'string', minLength: 8, maxLength: 128, description: '新密码' }\n        }\n      }\n    }\n  }, async (request: FastifyRequest, reply: FastifyReply) => {\n    try {\n      // @ts-ignore\n      const { userId } = request.user\n      const { currentPassword, newPassword } = changePasswordSchema.parse(request.body)\n      \n      await authService.changePassword(userId, currentPassword, newPassword)\n      \n      return reply.send({\n        success: true,\n        message: '密码修改成功，请重新登录'\n      })\n    } catch (error) {\n      return reply.status(400).send({\n        success: false,\n        error: {\n          code: 'PASSWORD_CHANGE_FAILED',\n          message: error instanceof Error ? error.message : '密码修改失败'\n        }\n      })\n    }\n  })\n}","usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/backend/src/server.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":46,"column":9,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":46,"endColumn":12,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1445,1448],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1445,1448],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":47,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":47,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1460,1463],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1460,1463],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":48,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":48,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1477,1480],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1477,1480],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'req' is defined but never used. Allowed unused args must match /^_/u.","line":138,"column":60,"nodeType":null,"messageId":"unusedVar","endLine":138,"endColumn":63},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'request' is defined but never used. Allowed unused args must match /^_/u.","line":148,"column":29,"nodeType":null,"messageId":"unusedVar","endLine":148,"endColumn":36},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'reply' is defined but never used. Allowed unused args must match /^_/u.","line":148,"column":38,"nodeType":null,"messageId":"unusedVar","endLine":148,"endColumn":43}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import Fastify from 'fastify'\nimport cors from '@fastify/cors'\nimport jwt from '@fastify/jwt'\nimport multipart from '@fastify/multipart'\nimport websocket from '@fastify/websocket'\nimport swagger from '@fastify/swagger'\nimport swaggerUi from '@fastify/swagger-ui'\n\nimport { config } from './config/index.js'\nimport { setupDatabase } from './database/index.js'\nimport { setupRedis } from './services/redis.js'\nimport { setupStorage } from './services/storage.js'\n\n// Routes\nimport authRoutes from './routes/auth.js'\nimport fileRoutes from './routes/files.js'\nimport shareRoutes from './routes/shares.js'\nimport syncRoutes from './routes/sync.js'\nimport analyticsRoutes from './routes/analytics.js'\nimport healthRoutes from './routes/health.js'\n\n// Middleware\nimport { authMiddleware } from './middleware/auth.js'\nimport { rateLimitMiddleware } from './middleware/rateLimit.js'\nimport { metricsMiddleware } from './middleware/metrics.js'\nimport { errorHandler } from './middleware/errorHandler.js'\n\nconst fastify = Fastify({\n  logger: {\n    level: config.LOG_LEVEL,\n    transport: config.NODE_ENV === 'development' ? {\n      target: 'pino-pretty',\n      options: {\n        colorize: true,\n        translateTime: 'HH:MM:ss Z',\n        ignore: 'pid,hostname'\n      }\n    } : undefined\n  }\n})\n\n// 声明类型扩展\ndeclare module 'fastify' {\n  interface FastifyInstance {\n    authenticate: (request: FastifyRequest, reply: FastifyReply) => Promise<void>\n    db: any\n    redis: any\n    storage: any\n  }\n}\n\nasync function buildServer() {\n  try {\n    // 基础插件\n    await fastify.register(cors, {\n      origin: config.CORS_ORIGINS,\n      credentials: true\n    })\n\n    await fastify.register(jwt, {\n      secret: config.JWT_SECRET,\n      sign: {\n        expiresIn: config.JWT_EXPIRES_IN\n      }\n    })\n\n    await fastify.register(multipart, {\n      limits: {\n        fileSize: config.MAX_FILE_SIZE,\n        files: 1\n      }\n    })\n\n    await fastify.register(websocket)\n\n    // API文档\n    await fastify.register(swagger, {\n      swagger: {\n        info: {\n          title: 'ZhugeExtract API',\n          description: 'Archive extraction and sharing service API',\n          version: '1.0.0'\n        },\n        host: `localhost:${config.PORT}`,\n        schemes: ['http', 'https'],\n        consumes: ['application/json', 'multipart/form-data'],\n        produces: ['application/json'],\n        securityDefinitions: {\n          Bearer: {\n            type: 'apiKey',\n            name: 'Authorization',\n            in: 'header'\n          }\n        }\n      }\n    })\n\n    await fastify.register(swaggerUi, {\n      routePrefix: '/docs',\n      uiConfig: {\n        docExpansion: 'full',\n        deepLinking: false\n      }\n    })\n\n    // 服务初始化\n    const db = await setupDatabase()\n    const redis = await setupRedis()\n    const storage = await setupStorage()\n\n    // 注册服务到fastify实例\n    fastify.decorate('db', db)\n    fastify.decorate('redis', redis)\n    fastify.decorate('storage', storage)\n\n    // 认证装饰器\n    fastify.decorate('authenticate', authMiddleware)\n\n    // 全局中间件\n    await fastify.register(rateLimitMiddleware)\n    await fastify.register(metricsMiddleware)\n\n    // 错误处理\n    fastify.setErrorHandler(errorHandler)\n\n    // 健康检查\n    await fastify.register(healthRoutes, { prefix: '/health' })\n\n    // API路由\n    await fastify.register(authRoutes, { prefix: '/api/v1/auth' })\n    await fastify.register(fileRoutes, { prefix: '/api/v1/files' })\n    await fastify.register(shareRoutes, { prefix: '/api/v1/shares' })\n    await fastify.register(syncRoutes, { prefix: '/api/v1/sync' })\n    await fastify.register(analyticsRoutes, { prefix: '/api/v1/analytics' })\n\n    // WebSocket路由\n    fastify.register(async function (fastify) {\n      fastify.get('/ws', { websocket: true }, (connection, req) => {\n        connection.socket.on('message', (message) => {\n          // WebSocket消息处理逻辑\n          console.log('Received message:', message.toString())\n          connection.socket.send('Hello from server!')\n        })\n      })\n    })\n\n    // 根路径\n    fastify.get('/', async (request, reply) => {\n      return {\n        message: 'ZhugeExtract Backend API',\n        version: '1.0.0',\n        documentation: '/docs',\n        health: '/health'\n      }\n    })\n\n    return fastify\n\n  } catch (error) {\n    fastify.log.error(error)\n    process.exit(1)\n  }\n}\n\nasync function start() {\n  try {\n    const server = await buildServer()\n    \n    await server.listen({\n      port: config.PORT,\n      host: config.HOST\n    })\n\n    console.log(`🚀 Server ready at http://${config.HOST}:${config.PORT}`)\n    console.log(`📚 Documentation available at http://${config.HOST}:${config.PORT}/docs`)\n\n  } catch (error) {\n    console.error('❌ Server startup failed:', error)\n    process.exit(1)\n  }\n}\n\n// 优雅关闭处理\nprocess.on('SIGINT', async () => {\n  try {\n    await fastify.close()\n    console.log('🔄 Server closed gracefully')\n    process.exit(0)\n  } catch (error) {\n    console.error('❌ Error during shutdown:', error)\n    process.exit(1)\n  }\n})\n\n// 启动服务器\nif (import.meta.url === `file://${process.argv[1]}`) {\n  start()\n}\n\nexport { buildServer }","usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/backend/src/services/auth.service.ts","messages":[{"ruleId":"no-duplicate-imports","severity":2,"message":"'../database/schema.js' import is duplicated.","line":9,"column":1,"nodeType":"ImportDeclaration","messageId":"import","endLine":9,"endColumn":80},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Session' is defined but never used. Allowed unused vars must match /^_/u.","line":9,"column":30,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":37},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'passwordHash' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":355,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":355,"endColumn":25}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import bcrypt from 'bcryptjs'\nimport jwt from 'jsonwebtoken'\nimport { nanoid } from 'nanoid'\nimport { eq, and } from 'drizzle-orm'\n\nimport { getDatabase } from '../database/index.js'\nimport { users, sessions } from '../database/schema.js'\nimport { config } from '../config/index.js'\nimport type { User, NewUser, Session, NewSession } from '../database/schema.js'\n\nexport interface LoginCredentials {\n  email: string\n  password: string\n}\n\nexport interface RegisterData {\n  email: string\n  username: string\n  password: string\n  displayName?: string\n}\n\nexport interface AuthResult {\n  user: Omit<User, 'passwordHash'>\n  token: string\n  refreshToken: string\n  expiresAt: Date\n}\n\nexport interface TokenPayload {\n  userId: string\n  email: string\n  username: string\n  sessionId: string\n}\n\nexport class AuthService {\n  private db = getDatabase()\n\n  // 用户注册\n  async register(data: RegisterData): Promise<AuthResult> {\n    const { email, username, password, displayName } = data\n\n    // 检查用户是否已存在\n    const existingUser = await this.db\n      .select()\n      .from(users)\n      .where(eq(users.email, email))\n      .limit(1)\n\n    if (existingUser.length > 0) {\n      throw new Error('用户已存在')\n    }\n\n    // 检查用户名是否已存在\n    const existingUsername = await this.db\n      .select()\n      .from(users)\n      .where(eq(users.username, username))\n      .limit(1)\n\n    if (existingUsername.length > 0) {\n      throw new Error('用户名已被使用')\n    }\n\n    // 密码哈希\n    const passwordHash = await this.hashPassword(password)\n\n    // 创建用户\n    const newUser: NewUser = {\n      email,\n      username,\n      passwordHash,\n      displayName: displayName || username,\n      emailVerified: false,\n    }\n\n    const [user] = await this.db\n      .insert(users)\n      .values(newUser)\n      .returning()\n\n    // 创建会话\n    const authResult = await this.createSession(user)\n\n    return authResult\n  }\n\n  // 用户登录\n  async login(credentials: LoginCredentials): Promise<AuthResult> {\n    const { email, password } = credentials\n\n    // 查找用户\n    const [user] = await this.db\n      .select()\n      .from(users)\n      .where(and(\n        eq(users.email, email),\n        eq(users.isActive, true)\n      ))\n      .limit(1)\n\n    if (!user) {\n      throw new Error('用户不存在或已被禁用')\n    }\n\n    // 验证密码\n    const isValidPassword = await this.verifyPassword(password, user.passwordHash)\n    if (!isValidPassword) {\n      throw new Error('密码错误')\n    }\n\n    // 更新最后登录时间\n    await this.db\n      .update(users)\n      .set({ lastLoginAt: new Date() })\n      .where(eq(users.id, user.id))\n\n    // 删除旧的会话（可选：单点登录）\n    await this.revokeUserSessions(user.id)\n\n    // 创建新会话\n    const authResult = await this.createSession(user)\n\n    return authResult\n  }\n\n  // 刷新令牌\n  async refreshToken(refreshToken: string): Promise<AuthResult> {\n    try {\n      // 验证刷新令牌\n      const payload = jwt.verify(refreshToken, config.JWT_SECRET) as TokenPayload & { type: 'refresh' }\n\n      if (payload.type !== 'refresh') {\n        throw new Error('Invalid token type')\n      }\n\n      // 查找会话\n      const [session] = await this.db\n        .select()\n        .from(sessions)\n        .where(and(\n          eq(sessions.id, payload.sessionId),\n          eq(sessions.refreshToken, refreshToken),\n          eq(sessions.isActive, true)\n        ))\n        .limit(1)\n\n      if (!session) {\n        throw new Error('会话不存在或已失效')\n      }\n\n      // 检查会话是否过期\n      if (session.expiresAt < new Date()) {\n        await this.revokeSession(session.id)\n        throw new Error('会话已过期')\n      }\n\n      // 查找用户\n      const [user] = await this.db\n        .select()\n        .from(users)\n        .where(and(\n          eq(users.id, session.userId),\n          eq(users.isActive, true)\n        ))\n        .limit(1)\n\n      if (!user) {\n        throw new Error('用户不存在或已被禁用')\n      }\n\n      // 生成新的令牌\n      const newTokens = this.generateTokens(user, session.id)\n\n      // 更新会话\n      await this.db\n        .update(sessions)\n        .set({\n          token: newTokens.token,\n          refreshToken: newTokens.refreshToken,\n          lastUsedAt: new Date()\n        })\n        .where(eq(sessions.id, session.id))\n\n      return {\n        user: this.sanitizeUser(user),\n        ...newTokens,\n        expiresAt: new Date(Date.now() + this.parseTimeString(config.JWT_EXPIRES_IN))\n      }\n\n    } catch (error) {\n      throw new Error(`令牌刷新失败: ${  error instanceof Error ? error.message : 'Unknown error'}`)\n    }\n  }\n\n  // 登出\n  async logout(sessionId: string): Promise<void> {\n    await this.revokeSession(sessionId)\n  }\n\n  // 验证令牌\n  async verifyToken(token: string): Promise<TokenPayload> {\n    try {\n      const payload = jwt.verify(token, config.JWT_SECRET) as TokenPayload\n\n      // 验证会话是否存在且活跃\n      const [session] = await this.db\n        .select()\n        .from(sessions)\n        .where(and(\n          eq(sessions.id, payload.sessionId),\n          eq(sessions.token, token),\n          eq(sessions.isActive, true)\n        ))\n        .limit(1)\n\n      if (!session) {\n        throw new Error('会话不存在或已失效')\n      }\n\n      if (session.expiresAt < new Date()) {\n        await this.revokeSession(session.id)\n        throw new Error('会话已过期')\n      }\n\n      // 更新最后使用时间\n      await this.db\n        .update(sessions)\n        .set({ lastUsedAt: new Date() })\n        .where(eq(sessions.id, session.id))\n\n      return payload\n\n    } catch (error) {\n      throw new Error(`令牌验证失败: ${  error instanceof Error ? error.message : 'Unknown error'}`)\n    }\n  }\n\n  // 获取用户信息\n  async getUserById(userId: string): Promise<Omit<User, 'passwordHash'> | null> {\n    const [user] = await this.db\n      .select()\n      .from(users)\n      .where(and(\n        eq(users.id, userId),\n        eq(users.isActive, true)\n      ))\n      .limit(1)\n\n    return user ? this.sanitizeUser(user) : null\n  }\n\n  // 更新用户资料\n  async updateProfile(userId: string, updates: Partial<Pick<User, 'displayName' | 'avatarUrl' | 'settings'>>): Promise<Omit<User, 'passwordHash'>> {\n    const [updatedUser] = await this.db\n      .update(users)\n      .set({\n        ...updates,\n        updatedAt: new Date()\n      })\n      .where(eq(users.id, userId))\n      .returning()\n\n    return this.sanitizeUser(updatedUser)\n  }\n\n  // 修改密码\n  async changePassword(userId: string, currentPassword: string, newPassword: string): Promise<void> {\n    // 获取用户信息\n    const [user] = await this.db\n      .select()\n      .from(users)\n      .where(eq(users.id, userId))\n      .limit(1)\n\n    if (!user) {\n      throw new Error('用户不存在')\n    }\n\n    // 验证当前密码\n    const isValidPassword = await this.verifyPassword(currentPassword, user.passwordHash)\n    if (!isValidPassword) {\n      throw new Error('当前密码错误')\n    }\n\n    // 更新密码\n    const newPasswordHash = await this.hashPassword(newPassword)\n    await this.db\n      .update(users)\n      .set({\n        passwordHash: newPasswordHash,\n        updatedAt: new Date()\n      })\n      .where(eq(users.id, userId))\n\n    // 撤销所有会话，强制重新登录\n    await this.revokeUserSessions(userId)\n  }\n\n  // 私有方法\n  private async createSession(user: User): Promise<AuthResult> {\n    const sessionId = nanoid()\n    const tokens = this.generateTokens(user, sessionId)\n    const expiresAt = new Date(Date.now() + this.parseTimeString(config.JWT_REFRESH_EXPIRES_IN))\n\n    const newSession: NewSession = {\n      id: sessionId,\n      userId: user.id,\n      token: tokens.token,\n      refreshToken: tokens.refreshToken,\n      expiresAt,\n      isActive: true\n    }\n\n    await this.db.insert(sessions).values(newSession)\n\n    return {\n      user: this.sanitizeUser(user),\n      ...tokens,\n      expiresAt: new Date(Date.now() + this.parseTimeString(config.JWT_EXPIRES_IN))\n    }\n  }\n\n  private generateTokens(user: User, sessionId: string) {\n    const payload: TokenPayload = {\n      userId: user.id,\n      email: user.email,\n      username: user.username,\n      sessionId\n    }\n\n    const token = jwt.sign(payload, config.JWT_SECRET, {\n      expiresIn: config.JWT_EXPIRES_IN\n    })\n\n    const refreshToken = jwt.sign(\n      { ...payload, type: 'refresh' },\n      config.JWT_SECRET,\n      { expiresIn: config.JWT_REFRESH_EXPIRES_IN }\n    )\n\n    return { token, refreshToken }\n  }\n\n  private async hashPassword(password: string): Promise<string> {\n    return bcrypt.hash(password, config.BCRYPT_ROUNDS)\n  }\n\n  private async verifyPassword(password: string, hash: string): Promise<boolean> {\n    return bcrypt.compare(password, hash)\n  }\n\n  private sanitizeUser(user: User): Omit<User, 'passwordHash'> {\n    const { passwordHash, ...sanitizedUser } = user\n    return sanitizedUser\n  }\n\n  private async revokeSession(sessionId: string): Promise<void> {\n    await this.db\n      .update(sessions)\n      .set({ isActive: false })\n      .where(eq(sessions.id, sessionId))\n  }\n\n  private async revokeUserSessions(userId: string): Promise<void> {\n    await this.db\n      .update(sessions)\n      .set({ isActive: false })\n      .where(eq(sessions.userId, userId))\n  }\n\n  private parseTimeString(timeString: string): number {\n    const units = {\n      s: 1000,\n      m: 60 * 1000,\n      h: 60 * 60 * 1000,\n      d: 24 * 60 * 60 * 1000\n    }\n\n    const match = timeString.match(/^(\\d+)([smhd])$/)\n    if (!match) {\n      throw new Error(`Invalid time string: ${timeString}`)\n    }\n\n    const [, amount, unit] = match\n    return parseInt(amount) * units[unit as keyof typeof units]\n  }\n}","usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/src/App.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/src/components/ErrorBoundary.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/src/components/layout/Header.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/src/components/layout/MainLayout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/src/components/ui/ErrorBoundary.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/src/components/ui/FileTree.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/src/components/ui/FileUpload.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/src/components/ui/LoadingSpinner.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/src/components/ui/PreviewPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/src/components/ui/ProgressBar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/src/components/ui/ThemeProvider.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":79,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":79,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { createContext, useContext, useEffect, useState } from 'react'\n\ntype Theme = 'light' | 'dark' | 'system'\n\ninterface ThemeContextType {\n  theme: Theme\n  setTheme: (theme: Theme) => void\n  isDark: boolean\n}\n\nconst ThemeContext = createContext<ThemeContextType | undefined>(undefined)\n\ninterface ThemeProviderProps {\n  children: React.ReactNode\n  defaultTheme?: Theme\n}\n\nexport function ThemeProvider({ children, defaultTheme = 'system' }: ThemeProviderProps) {\n  const [theme, setTheme] = useState<Theme>(() => {\n    if (typeof window !== 'undefined') {\n      return (localStorage.getItem('zhuge-theme') as Theme) || defaultTheme\n    }\n    return defaultTheme\n  })\n\n  const [isDark, setIsDark] = useState(false)\n\n  useEffect(() => {\n    const root = window.document.documentElement\n\n    root.classList.remove('light', 'dark')\n\n    if (theme === 'system') {\n      const systemTheme = window.matchMedia('(prefers-color-scheme: dark)').matches\n        ? 'dark'\n        : 'light'\n\n      root.classList.add(systemTheme)\n      setIsDark(systemTheme === 'dark')\n    } else {\n      root.classList.add(theme)\n      setIsDark(theme === 'dark')\n    }\n  }, [theme])\n\n  useEffect(() => {\n    const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)')\n    \n    const handleChange = () => {\n      if (theme === 'system') {\n        const systemTheme = mediaQuery.matches ? 'dark' : 'light'\n        const root = window.document.documentElement\n        root.classList.remove('light', 'dark')\n        root.classList.add(systemTheme)\n        setIsDark(systemTheme === 'dark')\n      }\n    }\n\n    mediaQuery.addEventListener('change', handleChange)\n    return () => mediaQuery.removeEventListener('change', handleChange)\n  }, [theme])\n\n  const value: ThemeContextType = {\n    theme,\n    setTheme: (theme: Theme) => {\n      localStorage.setItem('zhuge-theme', theme)\n      setTheme(theme)\n    },\n    isDark,\n  }\n\n  return (\n    <ThemeContext.Provider value={value}>\n      {children}\n    </ThemeContext.Provider>\n  )\n}\n\nexport const useTheme = () => {\n  const context = useContext(ThemeContext)\n\n  if (context === undefined) {\n    throw new Error('useTheme must be used within a ThemeProvider')\n  }\n\n  return context\n}","usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/src/components/ui/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/src/contexts/ArchiveContext.tsx","messages":[{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":64,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":64,"endColumn":56},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":79,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":79,"endColumn":83},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":80,"column":7,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":82,"endColumn":31},{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":249,"column":17,"nodeType":"Identifier","messageId":"namedExport","endLine":249,"endColumn":27},{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":258,"column":17,"nodeType":"Identifier","messageId":"namedExport","endLine":258,"endColumn":32},{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":263,"column":17,"nodeType":"Identifier","messageId":"namedExport","endLine":263,"endColumn":34}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { createContext, useContext, useReducer, useCallback } from 'react'\nimport type { Archive, ArchiveFile, ExtractionProgress, PreviewData, ErrorInfo } from '@/types'\nimport { getArchiveService } from '@/services'\n\ninterface ArchiveState {\n  archives: Archive[]\n  currentArchive: Archive | null\n  selectedFile: ArchiveFile | null\n  extractionProgress: ExtractionProgress | null\n  previewData: Map<string, PreviewData>\n  errors: ErrorInfo[]\n  isLoading: boolean\n}\n\ntype ArchiveAction =\n  | { type: 'SET_LOADING'; payload: boolean }\n  | { type: 'ADD_ARCHIVE'; payload: Archive }\n  | { type: 'SET_CURRENT_ARCHIVE'; payload: Archive | null }\n  | { type: 'SELECT_FILE'; payload: ArchiveFile | null }\n  | { type: 'SET_EXTRACTION_PROGRESS'; payload: ExtractionProgress | null }\n  | { type: 'SET_PREVIEW_DATA'; payload: { fileId: string; data: PreviewData } }\n  | { type: 'ADD_ERROR'; payload: ErrorInfo }\n  | { type: 'CLEAR_ERRORS' }\n  | { type: 'REMOVE_ARCHIVE'; payload: string }\n  | { type: 'CLEAR_ALL' }\n\nconst initialState: ArchiveState = {\n  archives: [],\n  currentArchive: null,\n  selectedFile: null,\n  extractionProgress: null,\n  previewData: new Map(),\n  errors: [],\n  isLoading: false,\n}\n\nfunction archiveReducer(state: ArchiveState, action: ArchiveAction): ArchiveState {\n  switch (action.type) {\n    case 'SET_LOADING':\n      return { ...state, isLoading: action.payload }\n\n    case 'ADD_ARCHIVE':\n      return {\n        ...state,\n        archives: [...state.archives, action.payload],\n        currentArchive: action.payload,\n        isLoading: false,\n      }\n\n    case 'SET_CURRENT_ARCHIVE':\n      return {\n        ...state,\n        currentArchive: action.payload,\n        selectedFile: null, // 切换压缩包时清除选择的文件\n      }\n\n    case 'SELECT_FILE':\n      return { ...state, selectedFile: action.payload }\n\n    case 'SET_EXTRACTION_PROGRESS':\n      return { ...state, extractionProgress: action.payload }\n\n    case 'SET_PREVIEW_DATA':\n      const newPreviewData = new Map(state.previewData)\n      newPreviewData.set(action.payload.fileId, action.payload.data)\n      return { ...state, previewData: newPreviewData }\n\n    case 'ADD_ERROR':\n      return {\n        ...state,\n        errors: [...state.errors, action.payload],\n        isLoading: false,\n      }\n\n    case 'CLEAR_ERRORS':\n      return { ...state, errors: [] }\n\n    case 'REMOVE_ARCHIVE':\n      const filteredArchives = state.archives.filter(a => a.id !== action.payload)\n      const newCurrentArchive = state.currentArchive?.id === action.payload \n        ? filteredArchives[0] || null \n        : state.currentArchive\n      \n      return {\n        ...state,\n        archives: filteredArchives,\n        currentArchive: newCurrentArchive,\n        selectedFile: state.currentArchive?.id === action.payload ? null : state.selectedFile,\n      }\n\n    case 'CLEAR_ALL':\n      return { ...initialState }\n\n    default:\n      return state\n  }\n}\n\ninterface ArchiveContextType {\n  state: ArchiveState\n  actions: {\n    setLoading: (loading: boolean) => void\n    addArchive: (archive: Archive) => void\n    setCurrentArchive: (archive: Archive | null) => void\n    selectFile: (file: ArchiveFile | null) => void\n    setExtractionProgress: (progress: ExtractionProgress | null) => void\n    setPreviewData: (fileId: string, data: PreviewData) => void\n    addError: (error: ErrorInfo) => void\n    clearErrors: () => void\n    removeArchive: (archiveId: string) => void\n    clearAll: () => void\n    // 新增高级操作\n    loadArchive: (file: File, password?: string) => Promise<void>\n    generatePreview: (file: ArchiveFile, password?: string) => Promise<void>\n    downloadFile: (file: ArchiveFile, password?: string) => Promise<void>\n  }\n}\n\nconst ArchiveContext = createContext<ArchiveContextType | undefined>(undefined)\n\nexport function ArchiveProvider({ children }: { children: React.ReactNode }) {\n  const [state, dispatch] = useReducer(archiveReducer, initialState)\n  const archiveService = getArchiveService()\n\n  // Action creators\n  const actions = {\n    setLoading: useCallback((loading: boolean) => {\n      dispatch({ type: 'SET_LOADING', payload: loading })\n    }, []),\n\n    addArchive: useCallback((archive: Archive) => {\n      dispatch({ type: 'ADD_ARCHIVE', payload: archive })\n    }, []),\n\n    setCurrentArchive: useCallback((archive: Archive | null) => {\n      dispatch({ type: 'SET_CURRENT_ARCHIVE', payload: archive })\n    }, []),\n\n    selectFile: useCallback((file: ArchiveFile | null) => {\n      dispatch({ type: 'SELECT_FILE', payload: file })\n    }, []),\n\n    setExtractionProgress: useCallback((progress: ExtractionProgress | null) => {\n      dispatch({ type: 'SET_EXTRACTION_PROGRESS', payload: progress })\n    }, []),\n\n    setPreviewData: useCallback((fileId: string, data: PreviewData) => {\n      dispatch({ type: 'SET_PREVIEW_DATA', payload: { fileId, data } })\n    }, []),\n\n    addError: useCallback((error: ErrorInfo) => {\n      dispatch({ type: 'ADD_ERROR', payload: error })\n      // 自动清理错误：5秒后移除\n      setTimeout(() => {\n        dispatch({ type: 'CLEAR_ERRORS' })\n      }, 5000)\n    }, []),\n\n    clearErrors: useCallback(() => {\n      dispatch({ type: 'CLEAR_ERRORS' })\n    }, []),\n\n    removeArchive: useCallback((archiveId: string) => {\n      dispatch({ type: 'REMOVE_ARCHIVE', payload: archiveId })\n    }, []),\n\n    clearAll: useCallback(() => {\n      dispatch({ type: 'CLEAR_ALL' })\n    }, []),\n\n    // 高级操作\n    loadArchive: useCallback(async (file: File, password?: string) => {\n      try {\n        dispatch({ type: 'SET_LOADING', payload: true })\n        dispatch({ type: 'CLEAR_ERRORS' })\n\n        const archive = await archiveService.loadArchive(\n          file,\n          password,\n          (progress) => {\n            dispatch({ type: 'SET_EXTRACTION_PROGRESS', payload: progress })\n          }\n        )\n\n        dispatch({ type: 'ADD_ARCHIVE', payload: archive })\n        dispatch({ type: 'SET_EXTRACTION_PROGRESS', payload: null })\n      } catch (error) {\n        const errorInfo: ErrorInfo = {\n          id: Date.now().toString(),\n          type: 'parsing',\n          message: error instanceof Error ? error.message : '未知错误',\n          timestamp: new Date()\n        }\n        dispatch({ type: 'ADD_ERROR', payload: errorInfo })\n      } finally {\n        dispatch({ type: 'SET_LOADING', payload: false })\n      }\n    }, [archiveService]),\n\n    generatePreview: useCallback(async (file: ArchiveFile, password?: string) => {\n      try {\n        const previewData = await archiveService.generatePreview(file, password)\n        dispatch({ type: 'SET_PREVIEW_DATA', payload: { fileId: file.id, data: previewData } })\n      } catch (error) {\n        const errorInfo: ErrorInfo = {\n          id: Date.now().toString(),\n          type: 'preview',\n          message: `预览失败: ${error instanceof Error ? error.message : '未知错误'}`,\n          timestamp: new Date()\n        }\n        dispatch({ type: 'ADD_ERROR', payload: errorInfo })\n      }\n    }, [archiveService]),\n\n    downloadFile: useCallback(async (file: ArchiveFile, password?: string) => {\n      try {\n        await archiveService.downloadFile(\n          file,\n          password,\n          (progress) => {\n            dispatch({ type: 'SET_EXTRACTION_PROGRESS', payload: progress })\n          }\n        )\n        dispatch({ type: 'SET_EXTRACTION_PROGRESS', payload: null })\n      } catch (error) {\n        const errorInfo: ErrorInfo = {\n          id: Date.now().toString(),\n          type: 'extraction',\n          message: `下载失败: ${error instanceof Error ? error.message : '未知错误'}`,\n          timestamp: new Date()\n        }\n        dispatch({ type: 'ADD_ERROR', payload: errorInfo })\n      }\n    }, [archiveService]),\n  }\n\n  const contextValue: ArchiveContextType = {\n    state,\n    actions,\n  }\n\n  return (\n    <ArchiveContext.Provider value={contextValue}>\n      {children}\n    </ArchiveContext.Provider>\n  )\n}\n\nexport function useArchive() {\n  const context = useContext(ArchiveContext)\n  if (context === undefined) {\n    throw new Error('useArchive must be used within an ArchiveProvider')\n  }\n  return context\n}\n\n// 便捷的Hook导出\nexport function useArchiveState() {\n  const { state } = useArchive()\n  return state\n}\n\nexport function useArchiveActions() {\n  const { actions } = useArchive()\n  return actions\n}","usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/src/contexts/ThemeContext.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":76,"column":17,"nodeType":"Identifier","messageId":"namedExport","endLine":76,"endColumn":25}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { createContext, useContext, useState, useEffect } from 'react'\nimport type { Theme } from '@/types'\n\ninterface ThemeContextType {\n  theme: Theme\n  setTheme: (theme: Theme) => void\n  isDark: boolean\n}\n\nconst ThemeContext = createContext<ThemeContextType | undefined>(undefined)\n\nexport function ThemeProvider({ children }: { children: React.ReactNode }) {\n  const [theme, setTheme] = useState<Theme>(() => {\n    // 从localStorage读取主题设置\n    const saved = localStorage.getItem('zhuge-extract-theme')\n    return (saved as Theme) || 'system'\n  })\n\n  const [isDark, setIsDark] = useState(false)\n\n  useEffect(() => {\n    // 保存主题设置到localStorage\n    localStorage.setItem('zhuge-extract-theme', theme)\n\n    // 计算实际的暗色模式状态\n    const computeDarkMode = () => {\n      if (theme === 'dark') {\n        return true\n      }\n      if (theme === 'light') {\n        return false\n      }\n      // system模式：根据系统偏好\n      return window.matchMedia('(prefers-color-scheme: dark)').matches\n    }\n\n    const updateDarkMode = () => {\n      const shouldBeDark = computeDarkMode()\n      setIsDark(shouldBeDark)\n      \n      // 更新DOM类名\n      if (shouldBeDark) {\n        document.documentElement.classList.add('dark')\n      } else {\n        document.documentElement.classList.remove('dark')\n      }\n    }\n\n    updateDarkMode()\n\n    // 监听系统主题变化\n    const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)')\n    const handleChange = () => {\n      if (theme === 'system') {\n        updateDarkMode()\n      }\n    }\n\n    mediaQuery.addEventListener('change', handleChange)\n    return () => mediaQuery.removeEventListener('change', handleChange)\n  }, [theme])\n\n  const contextValue: ThemeContextType = {\n    theme,\n    setTheme,\n    isDark,\n  }\n\n  return (\n    <ThemeContext.Provider value={contextValue}>\n      {children}\n    </ThemeContext.Provider>\n  )\n}\n\nexport function useTheme() {\n  const context = useContext(ThemeContext)\n  if (context === undefined) {\n    throw new Error('useTheme must be used within a ThemeProvider')\n  }\n  return context\n}","usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/src/main.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/src/pages/AboutPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/src/pages/HelpPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/src/pages/HomePage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/src/pages/PrivacyPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/src/services/archive-service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/src/services/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/src/services/wasm/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/src/services/wasm/libarchive-wrapper.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":262,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":262,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6740,6743],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6740,6743],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":280,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":280,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7217,7220],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7217,7220],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * LibArchive.js WebAssembly Wrapper\n * \n * 这个模块封装了libarchive.js的WebAssembly功能，提供了统一的API来处理各种压缩格式\n */\n\nimport { Archive as LibArchiveJS } from 'libarchive.js/main.js'\nimport { ArchiveFile, Archive, SupportedFormat, ExtractionProgress } from '@/types'\n\n// WebAssembly模块初始化状态\nlet isLibArchiveInitialized = false\nlet libArchiveModule: typeof LibArchiveJS | null = null\n\n/**\n * 初始化LibArchive WebAssembly模块\n */\nexport async function initializeLibArchive(): Promise<void> {\n  if (isLibArchiveInitialized && libArchiveModule) {\n    return\n  }\n\n  try {\n    // 设置WebAssembly文件路径\n    const wasmPath = new URL('libarchive.js/dist/libarchive.wasm', import.meta.url).href\n    \n    // 初始化LibArchive模块\n    libArchiveModule = await LibArchiveJS.init({\n      locateFile: (path: string) => {\n        if (path.endsWith('.wasm')) {\n          return wasmPath\n        }\n        return path\n      }\n    })\n\n    isLibArchiveInitialized = true\n    console.log('LibArchive WebAssembly module initialized successfully')\n  } catch (error) {\n    console.error('Failed to initialize LibArchive:', error)\n    throw new Error(`WebAssembly initialization failed: ${error}`)\n  }\n}\n\n/**\n * 检测文件格式\n */\nexport function detectArchiveFormat(fileBuffer: ArrayBuffer): SupportedFormat {\n  const signature = new Uint8Array(fileBuffer.slice(0, 16))\n  \n  // ZIP格式签名 (PK\\x03\\x04 或 PK\\x05\\x06 或 PK\\x07\\x08)\n  if (signature[0] === 0x50 && signature[1] === 0x4B) {\n    if ((signature[2] === 0x03 && signature[3] === 0x04) ||\n        (signature[2] === 0x05 && signature[3] === 0x06) ||\n        (signature[2] === 0x07 && signature[3] === 0x08)) {\n      return 'zip'\n    }\n  }\n  \n  // RAR格式签名\n  if (signature[0] === 0x52 && signature[1] === 0x61 && signature[2] === 0x72 && signature[3] === 0x21) {\n    return 'rar'\n  }\n  \n  // 7Z格式签名\n  if (signature[0] === 0x37 && signature[1] === 0x7A && signature[2] === 0xBC && signature[3] === 0xAF) {\n    return '7z'\n  }\n  \n  // TAR格式 (检查文件头的特定位置)\n  const tarCheck = new Uint8Array(fileBuffer.slice(257, 262))\n  if (String.fromCharCode(...tarCheck) === 'ustar') {\n    return 'tar'\n  }\n  \n  // GZIP格式签名\n  if (signature[0] === 0x1F && signature[1] === 0x8B) {\n    return 'gz'\n  }\n  \n  // BZIP2格式签名\n  if (signature[0] === 0x42 && signature[1] === 0x5A && signature[2] === 0x68) {\n    return 'bz2'\n  }\n  \n  return 'unknown'\n}\n\n/**\n * 解析压缩文件结构\n */\nexport async function parseArchiveStructure(\n  fileBuffer: ArrayBuffer,\n  fileName: string,\n  password?: string,\n  onProgress?: (progress: ExtractionProgress) => void\n): Promise<Archive> {\n  if (!isLibArchiveInitialized || !libArchiveModule) {\n    throw new Error('LibArchive module not initialized. Call initializeLibArchive() first.')\n  }\n\n  try {\n    onProgress?.({\n      bytesProcessed: 0,\n      totalBytes: fileBuffer.byteLength,\n      percentage: 0,\n      stage: 'parsing',\n      message: '正在解析压缩文件结构...'\n    })\n\n    // 创建LibArchive实例\n    const archive = await libArchiveModule.open(fileBuffer, password)\n    \n    // 获取文件列表\n    const files = archive.getFilesArray()\n    const format = detectArchiveFormat(fileBuffer)\n    \n    // 转换为我们的Archive格式\n    const archiveData: Archive = {\n      id: generateId(),\n      name: fileName,\n      format,\n      size: fileBuffer.byteLength,\n      fileCount: files.length,\n      isPasswordProtected: archive.hasPassword(),\n      structure: files.map(convertLibArchiveFile),\n      metadata: {\n        compressionRatio: calculateCompressionRatio(files, fileBuffer.byteLength)\n      }\n    }\n\n    onProgress?.({\n      bytesProcessed: fileBuffer.byteLength,\n      totalBytes: fileBuffer.byteLength,\n      percentage: 100,\n      stage: 'completed',\n      message: '解析完成'\n    })\n\n    return archiveData\n  } catch (error) {\n    onProgress?.({\n      bytesProcessed: 0,\n      totalBytes: fileBuffer.byteLength,\n      percentage: 0,\n      stage: 'error',\n      message: `解析失败: ${error}`\n    })\n    \n    throw new Error(`Failed to parse archive: ${error}`)\n  }\n}\n\n/**\n * 提取单个文件\n */\nexport async function extractSingleFile(\n  fileBuffer: ArrayBuffer,\n  filePath: string,\n  password?: string,\n  onProgress?: (progress: ExtractionProgress) => void\n): Promise<ArrayBuffer> {\n  if (!isLibArchiveInitialized || !libArchiveModule) {\n    throw new Error('LibArchive module not initialized')\n  }\n\n  try {\n    onProgress?.({\n      bytesProcessed: 0,\n      totalBytes: fileBuffer.byteLength,\n      percentage: 0,\n      stage: 'extracting',\n      message: `正在提取文件: ${filePath}`,\n      fileName: filePath\n    })\n\n    const archive = await libArchiveModule.open(fileBuffer, password)\n    const extractedData = await archive.extractSingleFile(filePath, password)\n\n    onProgress?.({\n      bytesProcessed: extractedData.byteLength,\n      totalBytes: extractedData.byteLength,\n      percentage: 100,\n      stage: 'completed',\n      message: '提取完成',\n      fileName: filePath\n    })\n\n    return extractedData\n  } catch (error) {\n    onProgress?.({\n      bytesProcessed: 0,\n      totalBytes: fileBuffer.byteLength,\n      percentage: 0,\n      stage: 'error',\n      message: `提取失败: ${error}`,\n      fileName: filePath\n    })\n    \n    throw new Error(`Failed to extract file ${filePath}: ${error}`)\n  }\n}\n\n/**\n * 批量提取文件\n */\nexport async function extractMultipleFiles(\n  fileBuffer: ArrayBuffer,\n  filePaths: string[],\n  password?: string,\n  onProgress?: (progress: ExtractionProgress) => void\n): Promise<Map<string, ArrayBuffer>> {\n  if (!isLibArchiveInitialized || !libArchiveModule) {\n    throw new Error('LibArchive module not initialized')\n  }\n\n  const results = new Map<string, ArrayBuffer>()\n  let processedCount = 0\n\n  try {\n    const archive = await libArchiveModule.open(fileBuffer, password)\n\n    for (const filePath of filePaths) {\n      onProgress?.({\n        bytesProcessed: processedCount,\n        totalBytes: filePaths.length,\n        percentage: (processedCount / filePaths.length) * 100,\n        stage: 'extracting',\n        message: `正在提取文件 ${processedCount + 1}/${filePaths.length}: ${filePath}`,\n        fileName: filePath\n      })\n\n      const extractedData = await archive.extractSingleFile(filePath, password)\n      results.set(filePath, extractedData)\n      processedCount++\n    }\n\n    onProgress?.({\n      bytesProcessed: filePaths.length,\n      totalBytes: filePaths.length,\n      percentage: 100,\n      stage: 'completed',\n      message: `成功提取 ${filePaths.length} 个文件`\n    })\n\n    return results\n  } catch (error) {\n    onProgress?.({\n      bytesProcessed: processedCount,\n      totalBytes: filePaths.length,\n      percentage: (processedCount / filePaths.length) * 100,\n      stage: 'error',\n      message: `批量提取失败: ${error}`\n    })\n    \n    throw new Error(`Failed to extract files: ${error}`)\n  }\n}\n\n/**\n * 转换LibArchive文件对象到我们的格式\n */\nfunction convertLibArchiveFile(file: any): ArchiveFile {\n  return {\n    id: generateId(),\n    name: file.name || '',\n    path: file.path || file.name || '',\n    size: file.size || 0,\n    compressedSize: file.compressedSize,\n    lastModified: file.lastModified ? new Date(file.lastModified) : new Date(),\n    isDirectory: file.type === 'directory',\n    isEncrypted: file.encrypted || false,\n    compressionMethod: file.method,\n    crc32: file.crc32\n  }\n}\n\n/**\n * 计算压缩比\n */\nfunction calculateCompressionRatio(files: any[], archiveSize: number): number {\n  const totalUncompressedSize = files.reduce((sum, file) => sum + (file.size || 0), 0)\n  if (totalUncompressedSize === 0) {return 0}\n  return (archiveSize / totalUncompressedSize)\n}\n\n/**\n * 生成唯一ID\n */\nfunction generateId(): string {\n  return Math.random().toString(36).substr(2, 9) + Date.now().toString(36)\n}\n\n/**\n * 检查WebAssembly支持\n */\nexport function checkWebAssemblySupport(): boolean {\n  try {\n    if (typeof WebAssembly === 'object' && \n        typeof WebAssembly.instantiate === 'function') {\n      // 检查SharedArrayBuffer支持 (某些压缩算法需要)\n      const hasSharedArrayBuffer = typeof SharedArrayBuffer !== 'undefined'\n      \n      if (!hasSharedArrayBuffer) {\n        console.warn('SharedArrayBuffer not available. Some features may be limited.')\n      }\n      \n      return true\n    }\n    return false\n  } catch {\n    return false\n  }\n}\n\n/**\n * 获取支持的格式列表\n */\nexport function getSupportedFormats(): SupportedFormat[] {\n  return ['zip', 'rar', '7z', 'tar', 'gz', 'bz2']\n}\n\n/**\n * 清理资源\n */\nexport function cleanup(): void {\n  // 在这里可以添加清理逻辑，如释放WebAssembly内存等\n  console.log('LibArchive wrapper cleanup completed')\n}","usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/src/services/wasm/worker-manager.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":12,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":12,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[274,277],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[274,277],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":137,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":137,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3238,3241],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3238,3241],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":139,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":139,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3313,3316],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3313,3316],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * WebAssembly Worker Manager\n * \n * 管理WebAssembly Worker的生命周期，提供队列处理和错误恢复\n */\n\nimport { Archive, ExtractionProgress, SupportedFormat } from '@/types'\nimport type { WorkerMessage, WorkerResponse } from './worker'\n\ninterface PendingTask {\n  id: string\n  resolve: (value: any) => void\n  reject: (error: Error) => void\n  onProgress?: (progress: ExtractionProgress) => void\n}\n\nexport class WorkerManager {\n  private worker: Worker | null = null\n  private isInitialized = false\n  private pendingTasks = new Map<string, PendingTask>()\n  private taskIdCounter = 0\n  private maxRetries = 3\n  private retryCount = 0\n\n  constructor() {\n    this.initializeWorker()\n  }\n\n  /**\n   * 初始化Worker\n   */\n  private async initializeWorker(): Promise<void> {\n    try {\n      // 创建Worker\n      this.worker = new Worker(\n        new URL('./worker.ts', import.meta.url),\n        { type: 'module' }\n      )\n\n      // 监听Worker消息\n      this.worker.addEventListener('message', this.handleWorkerMessage.bind(this))\n      this.worker.addEventListener('error', this.handleWorkerError.bind(this))\n\n      // 初始化WebAssembly模块\n      await this.sendMessage('init', {})\n      this.isInitialized = true\n      this.retryCount = 0\n\n      console.log('WebAssembly Worker initialized successfully')\n    } catch (error) {\n      console.error('Failed to initialize WebAssembly Worker:', error)\n      throw new Error(`Worker initialization failed: ${error}`)\n    }\n  }\n\n  /**\n   * 检测压缩文件格式\n   */\n  async detectFormat(fileBuffer: ArrayBuffer): Promise<SupportedFormat> {\n    this.ensureInitialized()\n    \n    const result = await this.sendMessage('detect-format', { fileBuffer })\n    return result.format\n  }\n\n  /**\n   * 解析压缩文件结构\n   */\n  async parseArchive(\n    fileBuffer: ArrayBuffer,\n    fileName: string,\n    password?: string,\n    onProgress?: (progress: ExtractionProgress) => void\n  ): Promise<Archive> {\n    this.ensureInitialized()\n    \n    const result = await this.sendMessage('parse', {\n      fileBuffer,\n      fileName,\n      password\n    }, onProgress)\n    \n    return result.archive\n  }\n\n  /**\n   * 提取单个文件\n   */\n  async extractSingleFile(\n    fileBuffer: ArrayBuffer,\n    filePath: string,\n    password?: string,\n    onProgress?: (progress: ExtractionProgress) => void\n  ): Promise<ArrayBuffer> {\n    this.ensureInitialized()\n    \n    const result = await this.sendMessage('extract-single', {\n      fileBuffer,\n      filePath,\n      password\n    }, onProgress)\n    \n    return result.data\n  }\n\n  /**\n   * 批量提取文件\n   */\n  async extractMultipleFiles(\n    fileBuffer: ArrayBuffer,\n    filePaths: string[],\n    password?: string,\n    onProgress?: (progress: ExtractionProgress) => void\n  ): Promise<Map<string, ArrayBuffer>> {\n    this.ensureInitialized()\n    \n    const result = await this.sendMessage('extract-multiple', {\n      fileBuffer,\n      filePaths,\n      password\n    }, onProgress)\n    \n    // 将对象转换回Map\n    const filesMap = new Map<string, ArrayBuffer>()\n    Object.entries(result.files).forEach(([path, data]) => {\n      filesMap.set(path, data as ArrayBuffer)\n    })\n    \n    return filesMap\n  }\n\n  /**\n   * 发送消息到Worker\n   */\n  private async sendMessage(\n    type: 'init' | 'parse' | 'extract-single' | 'extract-multiple' | 'detect-format', \n    payload: any, \n    onProgress?: (progress: ExtractionProgress) => void\n  ): Promise<any> {\n    if (!this.worker) {\n      throw new Error('Worker not available')\n    }\n\n    const id = this.generateTaskId()\n    \n    return new Promise((resolve, reject) => {\n      // 存储待处理任务\n      this.pendingTasks.set(id, {\n        id,\n        resolve,\n        reject,\n        onProgress\n      })\n\n      // 发送消息\n      const message: WorkerMessage = { id, type, payload }\n      this.worker!.postMessage(message)\n\n      // 设置超时\n      setTimeout(() => {\n        if (this.pendingTasks.has(id)) {\n          this.pendingTasks.delete(id)\n          reject(new Error(`Task ${id} timed out`))\n        }\n      }, 60000) // 60秒超时\n    })\n  }\n\n  /**\n   * 处理Worker消息\n   */\n  private handleWorkerMessage(event: MessageEvent<WorkerResponse>): void {\n    const { id, type, payload, error } = event.data\n    const task = this.pendingTasks.get(id)\n    \n    if (!task) {\n      console.warn(`Received message for unknown task: ${id}`)\n      return\n    }\n\n    switch (type) {\n      case 'success':\n        this.pendingTasks.delete(id)\n        task.resolve(payload)\n        break\n      \n      case 'error':\n        this.pendingTasks.delete(id)\n        task.reject(new Error(error || 'Unknown worker error'))\n        break\n      \n      case 'progress':\n        if (task.onProgress && payload) {\n          task.onProgress(payload as ExtractionProgress)\n        }\n        break\n      \n      default:\n        console.warn(`Unknown response type: ${type}`)\n    }\n  }\n\n  /**\n   * 处理Worker错误\n   */\n  private async handleWorkerError(event: ErrorEvent): Promise<void> {\n    console.error('Worker error:', event.error)\n    \n    // 拒绝所有待处理的任务\n    this.pendingTasks.forEach(task => {\n      task.reject(new Error('Worker crashed'))\n    })\n    this.pendingTasks.clear()\n    \n    // 尝试重新初始化Worker\n    if (this.retryCount < this.maxRetries) {\n      this.retryCount++\n      console.log(`Attempting to restart worker (${this.retryCount}/${this.maxRetries})`)\n      \n      try {\n        await this.restartWorker()\n      } catch (error) {\n        console.error('Failed to restart worker:', error)\n      }\n    } else {\n      console.error('Max retry attempts reached. Worker will not be restarted.')\n      this.isInitialized = false\n    }\n  }\n\n  /**\n   * 重启Worker\n   */\n  private async restartWorker(): Promise<void> {\n    // 终止现有Worker\n    if (this.worker) {\n      this.worker.terminate()\n      this.worker = null\n    }\n    \n    this.isInitialized = false\n    \n    // 重新初始化\n    await this.initializeWorker()\n  }\n\n  /**\n   * 生成任务ID\n   */\n  private generateTaskId(): string {\n    return `task_${++this.taskIdCounter}_${Date.now()}`\n  }\n\n  /**\n   * 确保Worker已初始化\n   */\n  private ensureInitialized(): void {\n    if (!this.isInitialized || !this.worker) {\n      throw new Error('Worker not initialized. Please wait for initialization to complete.')\n    }\n  }\n\n  /**\n   * 获取Worker状态\n   */\n  getStatus(): {\n    isInitialized: boolean\n    pendingTasks: number\n    retryCount: number\n  } {\n    return {\n      isInitialized: this.isInitialized,\n      pendingTasks: this.pendingTasks.size,\n      retryCount: this.retryCount\n    }\n  }\n\n  /**\n   * 清理资源\n   */\n  destroy(): void {\n    // 拒绝所有待处理的任务\n    this.pendingTasks.forEach(task => {\n      task.reject(new Error('Worker manager destroyed'))\n    })\n    this.pendingTasks.clear()\n\n    // 终止Worker\n    if (this.worker) {\n      this.worker.terminate()\n      this.worker = null\n    }\n\n    this.isInitialized = false\n    console.log('WebAssembly Worker Manager destroyed')\n  }\n}\n\n// 单例实例\nlet workerManagerInstance: WorkerManager | null = null\n\n/**\n * 获取Worker Manager单例\n */\nexport function getWorkerManager(): WorkerManager {\n  if (!workerManagerInstance) {\n    workerManagerInstance = new WorkerManager()\n  }\n  return workerManagerInstance\n}\n\n/**\n * 销毁Worker Manager单例\n */\nexport function destroyWorkerManager(): void {\n  if (workerManagerInstance) {\n    workerManagerInstance.destroy()\n    workerManagerInstance = null\n  }\n}","usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/src/services/wasm/worker.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":20,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":20,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[435,438],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[435,438],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":26,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":26,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[542,545],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[542,545],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":202,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":202,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4134,4137],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4134,4137],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * WebAssembly Worker\n * \n * 这个Worker在后台线程中处理压缩文件解析和提取，避免阻塞主线程\n */\n\nimport { \n  initializeLibArchive, \n  parseArchiveStructure, \n  extractSingleFile, \n  extractMultipleFiles,\n  detectArchiveFormat \n} from './libarchive-wrapper'\nimport { ExtractionProgress } from '@/types'\n\n// Worker消息类型定义\nexport interface WorkerMessage {\n  id: string\n  type: 'init' | 'parse' | 'extract-single' | 'extract-multiple' | 'detect-format'\n  payload?: any\n}\n\nexport interface WorkerResponse {\n  id: string\n  type: 'success' | 'error' | 'progress'\n  payload?: any\n  error?: string\n}\n\n// 初始化状态\nlet isInitialized = false\n\n// 处理来自主线程的消息\nself.addEventListener('message', async (event: MessageEvent<WorkerMessage>) => {\n  const { id, type, payload } = event.data\n\n  try {\n    switch (type) {\n      case 'init':\n        await handleInit(id)\n        break\n      \n      case 'parse':\n        await handleParseArchive(id, payload)\n        break\n      \n      case 'extract-single':\n        await handleExtractSingle(id, payload)\n        break\n      \n      case 'extract-multiple':\n        await handleExtractMultiple(id, payload)\n        break\n      \n      case 'detect-format':\n        await handleDetectFormat(id, payload)\n        break\n      \n      default:\n        sendError(id, `Unknown message type: ${type}`)\n    }\n  } catch (error) {\n    sendError(id, `Worker error: ${error}`)\n  }\n})\n\n/**\n * 初始化WebAssembly模块\n */\nasync function handleInit(id: string): Promise<void> {\n  if (isInitialized) {\n    sendSuccess(id, { initialized: true })\n    return\n  }\n\n  try {\n    await initializeLibArchive()\n    isInitialized = true\n    sendSuccess(id, { initialized: true })\n  } catch (error) {\n    sendError(id, `Initialization failed: ${error}`)\n  }\n}\n\n/**\n * 解析压缩文件结构\n */\nasync function handleParseArchive(id: string, payload: {\n  fileBuffer: ArrayBuffer\n  fileName: string\n  password?: string\n}): Promise<void> {\n  if (!isInitialized) {\n    sendError(id, 'Worker not initialized')\n    return\n  }\n\n  const { fileBuffer, fileName, password } = payload\n\n  try {\n    const archive = await parseArchiveStructure(\n      fileBuffer,\n      fileName,\n      password,\n      (progress) => sendProgress(id, progress)\n    )\n    \n    sendSuccess(id, { archive })\n  } catch (error) {\n    sendError(id, `Parse failed: ${error}`)\n  }\n}\n\n/**\n * 提取单个文件\n */\nasync function handleExtractSingle(id: string, payload: {\n  fileBuffer: ArrayBuffer\n  filePath: string\n  password?: string\n}): Promise<void> {\n  if (!isInitialized) {\n    sendError(id, 'Worker not initialized')\n    return\n  }\n\n  const { fileBuffer, filePath, password } = payload\n\n  try {\n    const extractedData = await extractSingleFile(\n      fileBuffer,\n      filePath,\n      password,\n      (progress) => sendProgress(id, progress)\n    )\n    \n    sendSuccess(id, { \n      filePath, \n      data: extractedData,\n      size: extractedData.byteLength \n    })\n  } catch (error) {\n    sendError(id, `Extract single file failed: ${error}`)\n  }\n}\n\n/**\n * 批量提取文件\n */\nasync function handleExtractMultiple(id: string, payload: {\n  fileBuffer: ArrayBuffer\n  filePaths: string[]\n  password?: string\n}): Promise<void> {\n  if (!isInitialized) {\n    sendError(id, 'Worker not initialized')\n    return\n  }\n\n  const { fileBuffer, filePaths, password } = payload\n\n  try {\n    const extractedFiles = await extractMultipleFiles(\n      fileBuffer,\n      filePaths,\n      password,\n      (progress) => sendProgress(id, progress)\n    )\n    \n    // 将Map转换为普通对象以便序列化\n    const filesObject: Record<string, ArrayBuffer> = {}\n    extractedFiles.forEach((data, path) => {\n      filesObject[path] = data\n    })\n    \n    sendSuccess(id, { \n      files: filesObject,\n      count: filePaths.length \n    })\n  } catch (error) {\n    sendError(id, `Extract multiple files failed: ${error}`)\n  }\n}\n\n/**\n * 检测文件格式\n */\nasync function handleDetectFormat(id: string, payload: {\n  fileBuffer: ArrayBuffer\n}): Promise<void> {\n  try {\n    const format = detectArchiveFormat(payload.fileBuffer)\n    sendSuccess(id, { format })\n  } catch (error) {\n    sendError(id, `Format detection failed: ${error}`)\n  }\n}\n\n/**\n * 发送成功响应\n */\nfunction sendSuccess(id: string, payload: any): void {\n  const response: WorkerResponse = {\n    id,\n    type: 'success',\n    payload\n  }\n  self.postMessage(response)\n}\n\n/**\n * 发送错误响应\n */\nfunction sendError(id: string, error: string): void {\n  const response: WorkerResponse = {\n    id,\n    type: 'error',\n    error\n  }\n  self.postMessage(response)\n}\n\n/**\n * 发送进度更新\n */\nfunction sendProgress(id: string, progress: ExtractionProgress): void {\n  const response: WorkerResponse = {\n    id,\n    type: 'progress',\n    payload: progress\n  }\n  self.postMessage(response)\n}\n\n// 处理未捕获的错误\nself.addEventListener('error', (event) => {\n  console.error('Worker error:', event.error)\n})\n\nself.addEventListener('unhandledrejection', (event) => {\n  console.error('Worker unhandled rejection:', event.reason)\n})\n\n// Types are already exported above","usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/src/types/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/src/types/libarchive.d.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":3,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":3,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[100,103],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[100,103],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"declare module 'libarchive.js/main.js' {\n  export interface LibArchiveReader {\n    getFilesArray(): any[]\n    extractSingleFile(path: string, password?: string): Promise<ArrayBuffer>\n    extractFiles(password?: string): Promise<Map<string, ArrayBuffer>>\n    hasPassword(): boolean\n    close(): void\n  }\n\n  export interface LibArchiveStatic {\n    init(options?: { locateFile?: (path: string) => string }): Promise<LibArchiveStatic>\n    open(data: ArrayBuffer, password?: string): Promise<LibArchiveReader>\n  }\n\n  export const Archive: LibArchiveStatic\n}","usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/src/utils/file-utils.ts","messages":[{"ruleId":"no-control-regex","severity":2,"message":"Unexpected control character(s) in regular expression: \\x00, \\x1f.","line":37,"column":52,"nodeType":"Literal","messageId":"unexpected","endLine":37,"endColumn":75},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\/.","line":547,"column":35,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":547,"endColumn":36,"suggestions":[{"messageId":"removeEscape","fix":{"range":[13512,13513],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[13512,13512],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * 文件处理工具\n * 提供文件操作、验证和处理的通用功能\n */\n\nexport interface FileInfo {\n  name: string;\n  size: number;\n  type: string;\n  lastModified: number;\n  path?: string;\n}\n\nexport interface FileValidationResult {\n  isValid: boolean;\n  errors: string[];\n  warnings: string[];\n}\n\nexport interface SecurityScanResult {\n  isSafe: boolean;\n  threats: string[];\n  riskLevel: 'low' | 'medium' | 'high';\n}\n\nexport class FileUtils {\n  // 危险文件扩展名列表\n  private static readonly DANGEROUS_EXTENSIONS = [\n    'exe', 'bat', 'cmd', 'com', 'pif', 'scr', 'vbs', 'js', 'jar',\n    'msi', 'dll', 'sys', 'app', 'deb', 'pkg', 'dmg', 'sh'\n  ];\n\n  // 最大文件名长度\n  private static readonly MAX_FILENAME_LENGTH = 255;\n\n  // 非法文件名字符\n  private static readonly ILLEGAL_FILENAME_CHARS = /[<>:\"/\\\\|?*\\x00-\\x1f]/;\n\n  /**\n   * 获取文件扩展名\n   * @param filename 文件名\n   * @returns 扩展名（小写，不含点）\n   */\n  static getFileExtension(filename: string): string {\n    const lastDot = filename.lastIndexOf('.');\n    if (lastDot === -1 || lastDot === filename.length - 1) {\n      return '';\n    }\n    return filename.substring(lastDot + 1).toLowerCase();\n  }\n\n  /**\n   * 获取不含扩展名的文件名\n   * @param filename 文件名\n   * @returns 基础文件名\n   */\n  static getBaseName(filename: string): string {\n    const lastDot = filename.lastIndexOf('.');\n    const lastSlash = Math.max(filename.lastIndexOf('/'), filename.lastIndexOf('\\\\'));\n    \n    const start = lastSlash + 1;\n    const end = lastDot === -1 ? filename.length : lastDot;\n    \n    return filename.substring(start, end);\n  }\n\n  /**\n   * 读取文件为Base64\n   * @param file 文件对象\n   * @returns Promise<string>\n   */\n  static readFileAsBase64(file: File): Promise<string> {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      \n      reader.onload = (event) => {\n        const result = event.target?.result;\n        if (typeof result === 'string') {\n          resolve(result);\n        } else {\n          reject(new Error('Failed to read file as Base64'));\n        }\n      };\n      \n      reader.onerror = () => {\n        reject(new Error('FileReader error'));\n      };\n      \n      reader.readAsDataURL(file);\n    });\n  }\n\n  /**\n   * 读取文件头部字节\n   * @param file 文件对象\n   * @param length 读取长度，默认16字节\n   * @returns Promise<Uint8Array>\n   */\n  static async readFileHeader(file: File, length: number = 16): Promise<Uint8Array> {\n    const slice = file.slice(0, length);\n    const buffer = await this.readFileAsArrayBuffer(slice as File);\n    return new Uint8Array(buffer);\n  }\n\n  /**\n   * 验证文件大小\n   * @param file 文件对象\n   * @param maxSize 最大大小（字节）\n   * @param minSize 最小大小（字节）\n   * @returns boolean\n   */\n  static validateFileSize(file: File, maxSize?: number, minSize?: number): boolean {\n    if (minSize !== undefined && file.size < minSize) {\n      return false;\n    }\n    if (maxSize !== undefined && file.size > maxSize) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * 验证文件类型\n   * @param file 文件对象\n   * @param allowedTypes 允许的MIME类型数组\n   * @returns boolean\n   */\n  static validateFileType(file: File, allowedTypes: string[]): boolean {\n    return allowedTypes.includes(file.type);\n  }\n\n  /**\n   * 验证文件扩展名\n   * @param filename 文件名\n   * @param allowedExtensions 允许的扩展名数组\n   * @returns boolean\n   */\n  static validateFileExtension(filename: string, allowedExtensions: string[]): boolean {\n    const ext = this.getFileExtension(filename);\n    return allowedExtensions.includes(ext);\n  }\n\n  /**\n   * 创建对象URL\n   * @param file 文件或Blob对象\n   * @returns string\n   */\n  static createObjectURL(file: File | Blob): string {\n    return URL.createObjectURL(file);\n  }\n\n  /**\n   * 从Base64创建Blob\n   * @param base64 Base64字符串\n   * @param mimeType MIME类型\n   * @returns Blob\n   */\n  static base64ToBlob(base64: string, mimeType: string = 'application/octet-stream'): Blob {\n    const base64Data = base64.includes(',') ? base64.split(',')[1] : base64;\n    const byteCharacters = atob(base64Data);\n    const byteNumbers = new Array(byteCharacters.length);\n    \n    for (let i = 0; i < byteCharacters.length; i++) {\n      byteNumbers[i] = byteCharacters.charCodeAt(i);\n    }\n    \n    const byteArray = new Uint8Array(byteNumbers);\n    return new Blob([byteArray], { type: mimeType });\n  }\n\n  /**\n   * 下载Blob为文件\n   * @param blob Blob对象\n   * @param filename 文件名\n   */\n  static downloadBlob(blob: Blob, filename: string): void {\n    const url = this.createObjectURL(blob);\n    const link = document.createElement('a');\n    link.href = url;\n    link.download = filename;\n    document.body.appendChild(link);\n    link.click();\n    document.body.removeChild(link);\n    URL.revokeObjectURL(url);\n  }\n\n  /**\n   * 清理文件名，移除非法字符\n   * @param filename 原始文件名\n   * @returns 清理后的文件名\n   */\n  static sanitizeFileName(filename: string): string {\n    return this.sanitizeFilename(filename);\n  }\n\n  /**\n   * 清理文件名，移除非法字符\n   * @param filename 原始文件名\n   * @returns 清理后的文件名\n   */\n  static sanitizeFilename(filename: string): string {\n    // 移除非法字符\n    let clean = filename.replace(this.ILLEGAL_FILENAME_CHARS, '_');\n    \n    // 移除首尾空格和点\n    clean = clean.trim().replace(/^\\.+|\\.+$/g, '');\n    \n    // 限制长度\n    if (clean.length > this.MAX_FILENAME_LENGTH) {\n      const ext = this.getFileExtension(filename);\n      const maxBaseName = this.MAX_FILENAME_LENGTH - ext.length - 1;\n      const baseName = this.getBaseName(clean).substring(0, maxBaseName);\n      clean = ext ? `${baseName}.${ext}` : baseName;\n    }\n    \n    // 确保不为空\n    if (!clean) {\n      clean = 'unnamed_file';\n    }\n    \n    return clean;\n  }\n\n  /**\n   * 验证文件名是否合法\n   * @param filename 文件名\n   * @returns 验证结果\n   */\n  static validateFilename(filename: string): FileValidationResult {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n\n    if (!filename || filename.trim().length === 0) {\n      errors.push('文件名不能为空');\n      return { isValid: false, errors, warnings };\n    }\n\n    // 检查长度\n    if (filename.length > this.MAX_FILENAME_LENGTH) {\n      errors.push(`文件名过长 (最大${this.MAX_FILENAME_LENGTH}字符)`);\n    }\n\n    // 检查非法字符\n    if (this.ILLEGAL_FILENAME_CHARS.test(filename)) {\n      errors.push('文件名包含非法字符');\n    }\n\n    // 检查是否以点开头或结尾\n    if (filename.startsWith('.') || filename.endsWith('.')) {\n      warnings.push('文件名不应以点开头或结尾');\n    }\n\n    // 检查危险扩展名\n    const ext = this.getFileExtension(filename);\n    if (this.DANGEROUS_EXTENSIONS.includes(ext)) {\n      warnings.push(`文件扩展名 \"${ext}\" 可能存在安全风险`);\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors,\n      warnings\n    };\n  }\n\n  /**\n   * 检查文件是否为压缩文件\n   * @param filename 文件名或file对象\n   * @returns 是否为压缩文件\n   */\n  static isArchiveFile(filename: string | File): boolean {\n    const name = typeof filename === 'string' ? filename : filename.name;\n    const ext = this.getFileExtension(name);\n    \n    const archiveExtensions = [\n      'zip', 'rar', '7z', 'tar', 'gz', 'bz2', 'xz', 'lzma',\n      'tgz', 'tbz2', 'txz', 'jar', 'war', 'ear'\n    ];\n    \n    return archiveExtensions.includes(ext);\n  }\n\n  /**\n   * 格式化文件大小\n   * @param bytes 字节数\n   * @param precision 精度，默认2位小数\n   * @returns 格式化的大小字符串\n   */\n  static formatFileSize(bytes: number, precision: number = 2): string {\n    if (bytes === 0) {return '0 B';}\n    \n    const units = ['B', 'KB', 'MB', 'GB', 'TB'];\n    const k = 1024;\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    \n    return `${(bytes / Math.pow(k, i)).toFixed(precision)} ${units[i]}`;\n  }\n\n  /**\n   * 读取文件为ArrayBuffer\n   * @param file 文件对象\n   * @returns Promise<ArrayBuffer>\n   */\n  static readFileAsArrayBuffer(file: File): Promise<ArrayBuffer> {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      \n      reader.onload = (event) => {\n        const result = event.target?.result;\n        if (result instanceof ArrayBuffer) {\n          resolve(result);\n        } else {\n          reject(new Error('Failed to read file as ArrayBuffer'));\n        }\n      };\n      \n      reader.onerror = () => {\n        reject(new Error('FileReader error'));\n      };\n      \n      reader.readAsArrayBuffer(file);\n    });\n  }\n\n  /**\n   * 读取文件为文本\n   * @param file 文件对象\n   * @param encoding 编码格式，默认UTF-8\n   * @returns Promise<string>\n   */\n  static readFileAsText(file: File, encoding: string = 'UTF-8'): Promise<string> {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      \n      reader.onload = (event) => {\n        const result = event.target?.result;\n        if (typeof result === 'string') {\n          resolve(result);\n        } else {\n          reject(new Error('Failed to read file as text'));\n        }\n      };\n      \n      reader.onerror = () => {\n        reject(new Error('FileReader error'));\n      };\n      \n      reader.readAsText(file, encoding);\n    });\n  }\n\n  /**\n   * 检查文件MIME类型\n   * @param file 文件对象\n   * @returns 实际MIME类型\n   */\n  static async detectMimeType(file: File): Promise<string> {\n    // 简单的MIME类型检测基于文件头\n    const buffer = await this.readFileAsArrayBuffer(file.slice(0, 16) as File);\n    const bytes = new Uint8Array(buffer);\n    \n    // ZIP文件\n    if (bytes[0] === 0x50 && bytes[1] === 0x4B) {\n      return 'application/zip';\n    }\n    \n    // RAR文件\n    if (bytes[0] === 0x52 && bytes[1] === 0x61 && bytes[2] === 0x72) {\n      return 'application/x-rar-compressed';\n    }\n    \n    // 7Z文件\n    if (bytes[0] === 0x37 && bytes[1] === 0x7A && bytes[2] === 0xBC && bytes[3] === 0xAF) {\n      return 'application/x-7z-compressed';\n    }\n    \n    // GZIP文件\n    if (bytes[0] === 0x1F && bytes[1] === 0x8B) {\n      return 'application/gzip';\n    }\n    \n    // 回退到文件声明的类型\n    return file.type || 'application/octet-stream';\n  }\n\n  /**\n   * 安全扫描文件\n   * @param file 文件对象\n   * @returns Promise<SecurityScanResult>\n   */\n  static async securityScan(file: File): Promise<SecurityScanResult> {\n    const threats: string[] = [];\n    let riskLevel: 'low' | 'medium' | 'high' = 'low';\n\n    // 检查文件扩展名\n    const ext = this.getFileExtension(file.name);\n    if (this.DANGEROUS_EXTENSIONS.includes(ext)) {\n      threats.push(`Dangerous file extension: ${ext}`);\n      riskLevel = 'high';\n    }\n\n    // 检查文件大小异常\n    if (file.size === 0) {\n      threats.push('Empty file');\n      riskLevel = 'medium';\n    } else if (file.size > 5 * 1024 * 1024 * 1024) { // 5GB\n      threats.push('Unusually large file size');\n      riskLevel = 'medium';\n    }\n\n    // 检查文件名异常\n    const filenameValidation = this.validateFilename(file.name);\n    if (!filenameValidation.isValid) {\n      threats.push('Invalid filename characters');\n      riskLevel = riskLevel === 'high' ? 'high' : 'medium';\n    }\n\n    // 检查MIME类型不匹配\n    try {\n      const detectedMime = await this.detectMimeType(file);\n      if (file.type && file.type !== detectedMime && file.type !== 'application/octet-stream') {\n        threats.push('MIME type mismatch');\n        riskLevel = riskLevel === 'high' ? 'high' : 'medium';\n      }\n    } catch (error) {\n      threats.push('Failed to verify file type');\n      riskLevel = 'medium';\n    }\n\n    // 检查文件名长度攻击\n    if (file.name.length > 200) {\n      threats.push('Filename too long (potential overflow attack)');\n      riskLevel = 'medium';\n    }\n\n    // 检查路径遍历攻击模式\n    if (file.name.includes('../') || file.name.includes('..\\\\')) {\n      threats.push('Path traversal attack pattern detected');\n      riskLevel = 'high';\n    }\n\n    return {\n      isSafe: threats.length === 0,\n      threats,\n      riskLevel\n    };\n  }\n\n  /**\n   * 计算文件哈希值（简单版本）\n   * @param file 文件对象\n   * @returns Promise<string> 哈希值\n   */\n  static async calculateSimpleHash(file: File): Promise<string> {\n    const buffer = await this.readFileAsArrayBuffer(file);\n    const bytes = new Uint8Array(buffer);\n    \n    let hash = 0;\n    for (let i = 0; i < bytes.length; i++) {\n      hash = ((hash << 5) - hash + bytes[i]) & 0xffffffff;\n    }\n    \n    return Math.abs(hash).toString(16);\n  }\n\n  /**\n   * 验证文件完整性\n   * @param file 文件对象\n   * @param expectedSize 期望大小（可选）\n   * @param expectedHash 期望哈希值（可选）\n   * @returns Promise<boolean>\n   */\n  static async validateFileIntegrity(\n    file: File, \n    expectedSize?: number, \n    expectedHash?: string\n  ): Promise<boolean> {\n    try {\n      if (expectedSize !== undefined && file.size !== expectedSize) {\n        return false;\n      }\n      \n      if (expectedHash !== undefined) {\n        const actualHash = await this.calculateSimpleHash(file);\n        if (actualHash !== expectedHash) {\n          return false;\n        }\n      }\n      \n      return true;\n    } catch (error) {\n      return false;\n    }\n  }\n\n  /**\n   * 创建文件信息对象\n   * @param file 文件对象\n   * @returns FileInfo\n   */\n  static createFileInfo(file: File): FileInfo {\n    return {\n      name: file.name,\n      size: file.size,\n      type: file.type,\n      lastModified: file.lastModified\n    };\n  }\n\n  /**\n   * 比较两个文件是否相同\n   * @param file1 文件1\n   * @param file2 文件2\n   * @returns Promise<boolean>\n   */\n  static async compareFiles(file1: File, file2: File): Promise<boolean> {\n    if (file1.size !== file2.size) {\n      return false;\n    }\n    \n    if (file1.name === file2.name && file1.lastModified === file2.lastModified) {\n      return true;\n    }\n    \n    try {\n      const [hash1, hash2] = await Promise.all([\n        this.calculateSimpleHash(file1),\n        this.calculateSimpleHash(file2)\n      ]);\n      \n      return hash1 === hash2;\n    } catch (error) {\n      return false;\n    }\n  }\n\n  // === 路径操作函数 ===\n\n  /**\n   * 拼接路径\n   * @param paths 路径片段\n   * @returns 拼接后的路径\n   */\n  static joinPath(...paths: string[]): string {\n    return paths\n      .filter(path => path && path.length > 0)\n      .map(path => path.replace(/[\\/\\\\]+/g, '/'))\n      .join('/')\n      .replace(/\\/+/g, '/')\n      .replace(/\\/$/, '') || '/';\n  }\n\n  /**\n   * 解析路径\n   * @param path 路径字符串\n   * @returns 解析后的路径信息\n   */\n  static parsePath(path: string): { dir: string; name: string; ext: string; base: string } {\n    const normalizedPath = path.replace(/[\\\\]/g, '/');\n    const lastSlash = normalizedPath.lastIndexOf('/');\n    \n    const dir = lastSlash > 0 ? normalizedPath.substring(0, lastSlash) : '';\n    const fullName = lastSlash >= 0 ? normalizedPath.substring(lastSlash + 1) : normalizedPath;\n    \n    const lastDot = fullName.lastIndexOf('.');\n    const name = lastDot > 0 ? fullName.substring(0, lastDot) : fullName;\n    const ext = lastDot > 0 ? fullName.substring(lastDot + 1) : '';\n    \n    return {\n      dir,\n      name,\n      ext,\n      base: fullName\n    };\n  }\n\n  // === 文件类型检测函数 ===\n\n  /**\n   * 检测是否为文本文件\n   * @param filename 文件名\n   * @returns boolean\n   */\n  static isTextFile(filename: string): boolean {\n    const textExtensions = [\n      'txt', 'md', 'json', 'xml', 'html', 'css', 'js', 'ts', 'jsx', 'tsx',\n      'py', 'java', 'cpp', 'c', 'h', 'cs', 'php', 'rb', 'go', 'rs', 'sh',\n      'yml', 'yaml', 'toml', 'ini', 'cfg', 'conf', 'log', 'sql', 'csv'\n    ];\n    const ext = this.getFileExtension(filename);\n    return textExtensions.includes(ext);\n  }\n\n  /**\n   * 检测是否为图片文件\n   * @param filename 文件名\n   * @returns boolean\n   */\n  static isImageFile(filename: string): boolean {\n    const imageExtensions = [\n      'jpg', 'jpeg', 'png', 'gif', 'bmp', 'webp', 'svg', 'ico',\n      'tiff', 'tif', 'psd', 'raw', 'heic', 'heif'\n    ];\n    const ext = this.getFileExtension(filename);\n    return imageExtensions.includes(ext);\n  }\n\n  /**\n   * 检测是否为视频文件\n   * @param filename 文件名\n   * @returns boolean\n   */\n  static isVideoFile(filename: string): boolean {\n    const videoExtensions = [\n      'mp4', 'avi', 'mkv', 'mov', 'wmv', 'flv', 'webm', 'm4v',\n      '3gp', 'ogv', 'ts', 'm2ts', 'mts', 'vob', 'rm', 'rmvb'\n    ];\n    const ext = this.getFileExtension(filename);\n    return videoExtensions.includes(ext);\n  }\n\n  /**\n   * 检测是否为音频文件\n   * @param filename 文件名\n   * @returns boolean\n   */\n  static isAudioFile(filename: string): boolean {\n    const audioExtensions = [\n      'mp3', 'wav', 'flac', 'aac', 'ogg', 'wma', 'm4a', 'opus',\n      'ape', 'ac3', 'dts', 'amr', 'au', 'ra', 'aiff'\n    ];\n    const ext = this.getFileExtension(filename);\n    return audioExtensions.includes(ext);\n  }\n}","usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/src/utils/format-detector.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/src/utils/memory-manager.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":111,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":111,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2431,2434],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2431,2434],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":112,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":112,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2507,2510],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2507,2510],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":140,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":140,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2952,2955],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2952,2955],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":141,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":141,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2996,2999],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2996,2999],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":367,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":367,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7644,7647],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7644,7647],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":370,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":370,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7730,7733],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7730,7733],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":372,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":372,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7815,7818],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7815,7818],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":374,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":374,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7894,7897],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7894,7897],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * 内存管理工具\n * 监控和管理应用程序的内存使用情况\n */\n\nexport interface MemoryInfo {\n  used: number;\n  total: number;\n  limit: number;\n  available: number;\n}\n\nexport interface MemoryAllocation {\n  id: string;\n  size: number;\n  timestamp: number;\n  description?: string;\n  priority?: string;\n}\n\nexport class MemoryManager {\n  private allocations = new Map<string, MemoryAllocation>();\n  private memoryLimit: number;\n  private gcThreshold: number;\n  private checkInterval: number = 5000; // 5秒检查一次\n  private intervalId?: NodeJS.Timeout;\n  private onMemoryWarning?: (info: MemoryInfo) => void;\n  private onMemoryError?: (error: Error) => void;\n\n  constructor(\n    memoryLimit: number = 2 * 1024 * 1024 * 1024, // 2GB默认限制\n    gcThreshold: number = 0.8 // 80%时触发GC\n  ) {\n    this.memoryLimit = memoryLimit;\n    this.gcThreshold = gcThreshold;\n    this.startMonitoring();\n  }\n\n  /**\n   * 分配内存块\n   * @param size 内存大小（字节）\n   * @param priority 优先级\n   * @param description 内存用途描述\n   * @returns 分配ID\n   */\n  async allocate(size: number, priority?: string, description?: string): Promise<string> {\n    const id = this.generateId();\n    \n    // 检查内存限制\n    const currentUsage = this.getCurrentUsage();\n    if (currentUsage + size > this.memoryLimit) {\n      // 尝试强制垃圾回收\n      await this.forceGC();\n      \n      const newUsage = this.getCurrentUsage();\n      if (newUsage + size > this.memoryLimit) {\n        throw new Error(`Memory allocation failed: would exceed limit (${this.formatBytes(size)} requested, ${this.formatBytes(this.memoryLimit - newUsage)} available)`);\n      }\n    }\n\n    const allocation: MemoryAllocation = {\n      id,\n      size,\n      timestamp: Date.now(),\n      description,\n      priority\n    };\n\n    this.allocations.set(id, allocation);\n    return id;\n  }\n\n  /**\n   * 释放内存块\n   * @param id 分配ID\n   */\n  free(id: string): void {\n    this.allocations.delete(id);\n  }\n\n  /**\n   * 释放所有内存块\n   */\n  freeAll(): void {\n    this.allocations.clear();\n  }\n\n  /**\n   * 获取当前内存使用情况\n   * @returns 内存使用字节数\n   */\n  getCurrentUsage(): number {\n    let total = 0;\n    for (const allocation of this.allocations.values()) {\n      total += allocation.size;\n    }\n    return total;\n  }\n\n  /**\n   * 获取详细内存信息\n   * @returns 内存信息对象\n   */\n  getMemoryInfo(): MemoryInfo {\n    const used = this.getCurrentUsage();\n    const limit = this.memoryLimit;\n    const available = limit - used;\n    \n    // 尝试获取实际系统内存信息\n    let total = limit;\n    if (typeof (performance as any)?.memory?.totalJSHeapSize === 'number') {\n      total = (performance as any).memory.totalJSHeapSize;\n    }\n\n    return {\n      used,\n      total,\n      limit,\n      available\n    };\n  }\n\n  /**\n   * 获取内存使用百分比\n   * @returns 使用百分比 (0-1)\n   */\n  getUsagePercentage(): number {\n    const used = this.getCurrentUsage();\n    return used / this.memoryLimit;\n  }\n\n  /**\n   * 强制垃圾回收\n   */\n  async forceGC(): Promise<void> {\n    // 清理过期的分配记录\n    this.cleanupExpiredAllocations();\n\n    // 如果环境支持，触发垃圾回收\n    if (typeof (global as any)?.gc === 'function') {\n      (global as any).gc();\n    }\n\n    // 等待一小段时间让GC完成\n    await new Promise(resolve => setTimeout(resolve, 100));\n  }\n\n  /**\n   * 清理过期的内存分配记录\n   * @param maxAge 最大存活时间（毫秒），默认1小时\n   */\n  cleanupExpiredAllocations(maxAge: number = 3600000): void {\n    const now = Date.now();\n    const expired: string[] = [];\n\n    for (const [id, allocation] of this.allocations.entries()) {\n      if (now - allocation.timestamp > maxAge) {\n        expired.push(id);\n      }\n    }\n\n    expired.forEach(id => this.free(id));\n  }\n\n  /**\n   * 获取所有内存分配记录\n   * @returns 分配记录数组\n   */\n  getAllocations(): MemoryAllocation[] {\n    return Array.from(this.allocations.values());\n  }\n\n  /**\n   * 获取按大小排序的分配记录\n   * @param descending 是否降序排列\n   * @returns 排序后的分配记录\n   */\n  getAllocationsBySize(descending: boolean = true): MemoryAllocation[] {\n    const allocations = this.getAllocations();\n    return allocations.sort((a, b) => \n      descending ? b.size - a.size : a.size - b.size\n    );\n  }\n\n  /**\n   * 设置内存警告回调\n   * @param callback 警告回调函数\n   */\n  onWarning(callback: (info: MemoryInfo) => void): void {\n    this.onMemoryWarning = callback;\n  }\n\n  /**\n   * 设置内存错误回调\n   * @param callback 错误回调函数\n   */\n  onError(callback: (error: Error) => void): void {\n    this.onMemoryError = callback;\n  }\n\n  /**\n   * 开始内存监控\n   */\n  private startMonitoring(): void {\n    if (this.intervalId) {return;}\n\n    this.intervalId = setInterval(() => {\n      this.checkMemoryUsage();\n    }, this.checkInterval);\n  }\n\n  /**\n   * 停止内存监控\n   */\n  stopMonitoring(): void {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n      this.intervalId = undefined;\n    }\n  }\n\n  /**\n   * 检查内存使用情况\n   */\n  private checkMemoryUsage(): void {\n    try {\n      const usage = this.getUsagePercentage();\n      const info = this.getMemoryInfo();\n\n      // 超过阈值时发出警告\n      if (usage > this.gcThreshold && this.onMemoryWarning) {\n        this.onMemoryWarning(info);\n      }\n\n      // 接近限制时自动清理\n      if (usage > 0.9) {\n        this.cleanupExpiredAllocations();\n      }\n    } catch (error) {\n      if (this.onMemoryError) {\n        this.onMemoryError(error instanceof Error ? error : new Error(String(error)));\n      }\n    }\n  }\n\n  /**\n   * 生成唯一ID\n   * @returns 唯一标识符\n   */\n  private generateId(): string {\n    return `mem_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  /**\n   * 格式化字节数为可读字符串\n   * @param bytes 字节数\n   * @returns 格式化字符串\n   */\n  private formatBytes(bytes: number): string {\n    const units = ['B', 'KB', 'MB', 'GB'];\n    let size = bytes;\n    let unitIndex = 0;\n\n    while (size >= 1024 && unitIndex < units.length - 1) {\n      size /= 1024;\n      unitIndex++;\n    }\n\n    return `${size.toFixed(2)} ${units[unitIndex]}`;\n  }\n\n  /**\n   * 销毁内存管理器\n   */\n  destroy(): void {\n    this.stopMonitoring();\n    this.freeAll();\n    this.onMemoryWarning = undefined;\n    this.onMemoryError = undefined;\n  }\n\n  /**\n   * 获取内存统计信息\n   * @returns 统计信息对象\n   */\n  getStats(): {\n    totalAllocations: number;\n    currentUsage: string;\n    memoryLimit: string;\n    usagePercentage: string;\n    largestAllocation: string;\n    oldestAllocation: number | null;\n  } {\n    const allocations = this.getAllocations();\n    const usage = this.getCurrentUsage();\n    const largest = allocations.length > 0 \n      ? Math.max(...allocations.map(a => a.size))\n      : 0;\n    const oldest = allocations.length > 0\n      ? Math.min(...allocations.map(a => a.timestamp))\n      : null;\n\n    return {\n      totalAllocations: allocations.length,\n      currentUsage: this.formatBytes(usage),\n      memoryLimit: this.formatBytes(this.memoryLimit),\n      usagePercentage: `${(this.getUsagePercentage() * 100).toFixed(2)}%`,\n      largestAllocation: this.formatBytes(largest),\n      oldestAllocation: oldest\n    };\n  }\n\n  /**\n   * 获取最大内存限制\n   * @returns 最大内存限制\n   */\n  getMaxMemory(): number {\n    return this.memoryLimit;\n  }\n\n  /**\n   * 获取内存使用统计\n   * @returns 统计信息\n   */\n  getUsageStats(): {\n    used: number;\n    total: number;\n    free: number;\n    usage: number;\n  } {\n    const used = this.getCurrentUsage();\n    const total = this.memoryLimit;\n    return {\n      used,\n      total,\n      free: total - used,\n      usage: used / total\n    };\n  }\n\n  /**\n   * 更新访问时间（用于LRU）\n   * @param id 分配ID\n   */\n  updateAccess(id: string): void {\n    const allocation = this.allocations.get(id);\n    if (allocation) {\n      allocation.timestamp = Date.now();\n    }\n  }\n\n  /**\n   * 批量释放内存\n   * @param ids 分配ID数组\n   */\n  freeMultiple(ids: string[]): void {\n    for (const id of ids) {\n      this.free(id);\n    }\n  }\n\n  /**\n   * 事件监听器（简化版EventEmitter）\n   * @param event 事件名\n   * @param callback 回调函数\n   */\n  on(event: string, callback: (...args: any[]) => void): void {\n    // 简化的事件系统\n    if (event === 'allocate') {\n      (this as any)._allocateCallback = callback;\n    } else if (event === 'free') {\n      (this as any)._freeCallback = callback;\n    } else if (event === 'gc') {\n      (this as any)._gcCallback = callback;\n    }\n  }\n}","usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/tests/e2e/complete-user-journey.spec.ts","messages":[{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":253,"column":30,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":253,"endColumn":43}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { test, expect, Page, BrowserContext } from '@playwright/test';\nimport path from 'path';\n\ntest.describe('ZhugeExtract - 完整用户旅程', () => {\n  let page: Page;\n  let context: BrowserContext;\n\n  test.beforeEach(async ({ browser }) => {\n    context = await browser.newContext({\n      // 启用权限\n      permissions: ['clipboard-read', 'clipboard-write'],\n      // 设置视口\n      viewport: { width: 1280, height: 720 }\n    });\n    page = await context.newPage();\n    \n    // 导航到应用\n    await page.goto('/');\n    await expect(page).toHaveTitle(/ZhugeExtract/);\n  });\n\n  test.afterEach(async () => {\n    await context.close();\n  });\n\n  test('用户完整解压和预览流程', async () => {\n    // 步骤1: 验证初始页面状态\n    await expect(page.getByTestId('file-upload-zone')).toBeVisible();\n    await expect(page.getByText('拖拽文件到此处')).toBeVisible();\n    await expect(page.getByText('支持格式')).toBeVisible();\n\n    // 步骤2: 上传ZIP文件\n    const zipFilePath = path.join(__dirname, '../fixtures/archives/sample.zip');\n    \n    await page.setInputFiles('input[type=\"file\"]', zipFilePath);\n    \n    // 验证上传成功提示\n    await expect(page.getByText('文件上传成功')).toBeVisible({ timeout: 5000 });\n\n    // 步骤3: 等待解压完成\n    await expect(page.getByTestId('file-tree')).toBeVisible({ timeout: 10000 });\n    await expect(page.getByTestId('loading-spinner')).not.toBeVisible();\n\n    // 验证解压结果\n    await expect(page.getByText('解压完成')).toBeVisible();\n    await expect(page.getByTestId('file-count')).toContainText('5 个文件');\n\n    // 步骤4: 验证文件树结构\n    const fileTree = page.getByTestId('file-tree');\n    await expect(fileTree.getByText('readme.txt')).toBeVisible();\n    await expect(fileTree.getByText('images')).toBeVisible();\n    await expect(fileTree.getByText('documents')).toBeVisible();\n\n    // 展开文件夹\n    await fileTree.getByText('images').click();\n    await expect(fileTree.getByText('photo1.jpg')).toBeVisible();\n    await expect(fileTree.getByText('photo2.png')).toBeVisible();\n\n    // 步骤5: 预览文本文件\n    await fileTree.getByText('readme.txt').click();\n    \n    await expect(page.getByTestId('preview-panel')).toBeVisible();\n    await expect(page.getByTestId('preview-content')).toBeVisible();\n    await expect(page.getByText('这是一个测试文件')).toBeVisible();\n    \n    // 验证预览元数据\n    const metadataPanel = page.getByTestId('file-metadata');\n    await expect(metadataPanel.getByText('文件大小: 48 B')).toBeVisible();\n    await expect(metadataPanel.getByText('类型: 文本文件')).toBeVisible();\n\n    // 步骤6: 预览图片文件\n    await fileTree.getByText('photo1.jpg').click();\n    \n    await expect(page.getByTestId('image-preview')).toBeVisible();\n    const image = page.getByTestId('preview-image');\n    await expect(image).toBeVisible();\n    await expect(image).toHaveAttribute('src', /^data:image/);\n\n    // 验证图片控制按钮\n    await expect(page.getByTestId('zoom-in-button')).toBeVisible();\n    await expect(page.getByTestId('zoom-out-button')).toBeVisible();\n    await expect(page.getByTestId('rotate-button')).toBeVisible();\n\n    // 步骤7: 测试图片缩放功能\n    await page.getByTestId('zoom-in-button').click();\n    await expect(image).toHaveClass(/zoomed-in/);\n    \n    await page.getByTestId('zoom-out-button').click();\n    await expect(image).not.toHaveClass(/zoomed-in/);\n\n    // 步骤8: 下载单个文件\n    const downloadPromise = page.waitForEvent('download');\n    await page.getByTestId('download-file-button').click();\n    \n    const download = await downloadPromise;\n    expect(download.suggestedFilename()).toBe('photo1.jpg');\n\n    // 步骤9: 批量选择和下载\n    await fileTree.getByTestId('select-checkbox-readme.txt').check();\n    await fileTree.getByTestId('select-checkbox-photo1.jpg').check();\n    \n    await expect(page.getByTestId('selected-count')).toContainText('已选择 2 个文件');\n    \n    const batchDownloadPromise = page.waitForEvent('download');\n    await page.getByTestId('download-selected-button').click();\n    \n    const batchDownload = await batchDownloadPromise;\n    expect(batchDownload.suggestedFilename()).toMatch(/selected_files.*\\.zip/);\n\n    // 步骤10: 搜索文件\n    const searchInput = page.getByTestId('file-search-input');\n    await searchInput.fill('photo');\n    \n    await expect(fileTree.getByText('photo1.jpg')).toBeVisible();\n    await expect(fileTree.getByText('photo2.png')).toBeVisible();\n    await expect(fileTree.getByText('readme.txt')).not.toBeVisible();\n\n    // 清除搜索\n    await searchInput.clear();\n    await expect(fileTree.getByText('readme.txt')).toBeVisible();\n\n    // 步骤11: 切换显示模式\n    await page.getByTestId('view-mode-list').click();\n    await expect(fileTree).toHaveClass(/list-view/);\n    \n    await page.getByTestId('view-mode-grid').click();\n    await expect(fileTree).toHaveClass(/grid-view/);\n\n    // 步骤12: 验证应用状态持久化\n    await page.reload();\n    \n    // 验证文件仍然加载\n    await expect(page.getByTestId('file-tree')).toBeVisible({ timeout: 5000 });\n    await expect(page.getByText('readme.txt')).toBeVisible();\n  });\n\n  test('RAR文件处理流程', async () => {\n    const rarFilePath = path.join(__dirname, '../fixtures/archives/sample.rar');\n    \n    await page.setInputFiles('input[type=\"file\"]', rarFilePath);\n    \n    // 等待RAR解压完成（可能需要更多时间）\n    await expect(page.getByTestId('file-tree')).toBeVisible({ timeout: 15000 });\n    \n    // 验证RAR特有的文件结构\n    const fileTree = page.getByTestId('file-tree');\n    await expect(fileTree.getByText('compressed_data.bin')).toBeVisible();\n    \n    // 验证压缩信息显示\n    const compressionInfo = page.getByTestId('compression-info');\n    await expect(compressionInfo.getByText('格式: RAR')).toBeVisible();\n    await expect(compressionInfo.getByText(/压缩比:/)).toBeVisible();\n  });\n\n  test('密码保护文件处理', async () => {\n    const protectedZipPath = path.join(__dirname, '../fixtures/archives/protected.zip');\n    \n    await page.setInputFiles('input[type=\"file\"]', protectedZipPath);\n    \n    // 应该出现密码输入对话框\n    await expect(page.getByTestId('password-dialog')).toBeVisible({ timeout: 5000 });\n    await expect(page.getByText('此文件需要密码')).toBeVisible();\n    \n    // 输入错误密码\n    await page.getByTestId('password-input').fill('wrongpassword');\n    await page.getByTestId('password-submit').click();\n    \n    // 验证错误提示\n    await expect(page.getByText('密码错误')).toBeVisible();\n    \n    // 输入正确密码\n    await page.getByTestId('password-input').clear();\n    await page.getByTestId('password-input').fill('test123');\n    await page.getByTestId('password-submit').click();\n    \n    // 验证解压成功\n    await expect(page.getByTestId('file-tree')).toBeVisible({ timeout: 10000 });\n    await expect(page.getByText('protected_file.txt')).toBeVisible();\n  });\n\n  test('错误处理和恢复', async () => {\n    // 测试无效文件上传\n    const invalidFilePath = path.join(__dirname, '../fixtures/files/invalid.txt');\n    \n    await page.setInputFiles('input[type=\"file\"]', invalidFilePath);\n    \n    // 验证错误信息\n    await expect(page.getByTestId('error-message')).toBeVisible();\n    await expect(page.getByText('不支持的文件格式')).toBeVisible();\n    \n    // 点击清除错误\n    await page.getByTestId('clear-error-button').click();\n    await expect(page.getByTestId('error-message')).not.toBeVisible();\n    \n    // 测试损坏的压缩文件\n    const corruptedZipPath = path.join(__dirname, '../fixtures/archives/corrupted.zip');\n    \n    await page.setInputFiles('input[type=\"file\"]', corruptedZipPath);\n    \n    // 验证错误处理\n    await expect(page.getByTestId('error-message')).toBeVisible({ timeout: 10000 });\n    await expect(page.getByText(/文件损坏/)).toBeVisible();\n    \n    // 验证重试按钮\n    await expect(page.getByTestId('retry-button')).toBeVisible();\n  });\n\n  test('大文件处理和性能', async () => {\n    const largeZipPath = path.join(__dirname, '../fixtures/archives/large_50mb.zip');\n    \n    await page.setInputFiles('input[type=\"file\"]', largeZipPath);\n    \n    // 验证进度指示器\n    await expect(page.getByTestId('progress-bar')).toBeVisible();\n    await expect(page.getByTestId('progress-text')).toBeVisible();\n    \n    // 监控进度更新\n    const progressValues: string[] = [];\n    page.on('console', msg => {\n      if (msg.text().includes('Progress:')) {\n        progressValues.push(msg.text());\n      }\n    });\n    \n    // 等待解压完成\n    await expect(page.getByTestId('file-tree')).toBeVisible({ timeout: 30000 });\n    \n    // 验证大量文件的虚拟滚动\n    const fileTree = page.getByTestId('file-tree');\n    await expect(fileTree).toHaveClass(/virtual-scroll/);\n    \n    // 验证文件数量\n    const fileCount = page.getByTestId('file-count');\n    await expect(fileCount).toContainText(/\\d+ 个文件/);\n    \n    // 测试虚拟滚动性能\n    const scrollContainer = page.getByTestId('virtual-scroll-container');\n    await scrollContainer.evaluate(element => {\n      element.scrollTop = element.scrollHeight / 2;\n    });\n    \n    // 验证滚动后的渲染性能\n    await expect(page.getByTestId('file-item').first()).toBeVisible();\n  });\n\n  test('拖拽上传功能', async () => {\n    const zipFilePath = path.join(__dirname, '../fixtures/archives/drag_test.zip');\n    \n    // 模拟文件拖拽\n    const dropZone = page.getByTestId('file-upload-zone');\n    \n    // 创建文件对象并拖拽\n    const fileBuffer = await require('fs').promises.readFile(zipFilePath);\n    const dataTransfer = await page.evaluateHandle((data) => {\n      const dt = new DataTransfer();\n      const file = new File([new Uint8Array(data)], 'drag_test.zip', {\n        type: 'application/zip'\n      });\n      dt.items.add(file);\n      return dt;\n    }, Array.from(fileBuffer));\n    \n    await dropZone.dispatchEvent('drop', { dataTransfer });\n    \n    // 验证拖拽上传成功\n    await expect(page.getByTestId('file-tree')).toBeVisible({ timeout: 10000 });\n    await expect(page.getByText('dragged_file.txt')).toBeVisible();\n  });\n\n  test('键盘导航和无障碍功能', async () => {\n    const zipFilePath = path.join(__dirname, '../fixtures/archives/sample.zip');\n    await page.setInputFiles('input[type=\"file\"]', zipFilePath);\n    await expect(page.getByTestId('file-tree')).toBeVisible({ timeout: 10000 });\n    \n    // 测试Tab键导航\n    await page.keyboard.press('Tab');\n    await expect(page.getByTestId('file-tree')).toBeFocused();\n    \n    // 使用方向键导航文件\n    await page.keyboard.press('ArrowDown');\n    await page.keyboard.press('ArrowDown');\n    await page.keyboard.press('Enter'); // 选择文件\n    \n    // 验证文件被选中和预览\n    await expect(page.getByTestId('preview-panel')).toBeVisible();\n    \n    // 测试快捷键\n    await page.keyboard.press('Control+A'); // 全选\n    await expect(page.getByTestId('selected-count')).toContainText('已选择');\n    \n    await page.keyboard.press('Escape'); // 取消选择\n    await expect(page.getByTestId('selected-count')).not.toBeVisible();\n    \n    // 验证ARIA标签\n    const fileTree = page.getByTestId('file-tree');\n    await expect(fileTree).toHaveAttribute('role', 'tree');\n    \n    const fileItems = page.getByTestId('file-item');\n    await expect(fileItems.first()).toHaveAttribute('role', 'treeitem');\n  });\n\n  test('响应式设计 - 移动端体验', async () => {\n    // 切换到移动端视口\n    await page.setViewportSize({ width: 375, height: 667 });\n    \n    const zipFilePath = path.join(__dirname, '../fixtures/archives/sample.zip');\n    await page.setInputFiles('input[type=\"file\"]', zipFilePath);\n    await expect(page.getByTestId('file-tree')).toBeVisible({ timeout: 10000 });\n    \n    // 验证移动端布局\n    const container = page.getByTestId('main-container');\n    await expect(container).toHaveClass(/mobile-layout/);\n    \n    // 验证Tab切换\n    const tabButtons = page.getByTestId('tab-button');\n    await expect(tabButtons).toHaveCount(2); // 文件列表和预览两个Tab\n    \n    // 切换到预览Tab\n    await tabButtons.last().click();\n    await expect(page.getByTestId('preview-panel')).toBeVisible();\n    \n    // 验证触摸手势（如果支持）\n    const fileTree = page.getByTestId('file-tree');\n    await fileTree.locator('text=readme.txt').tap();\n    await expect(page.getByTestId('preview-content')).toBeVisible();\n    \n    // 验证移动端菜单\n    const mobileMenu = page.getByTestId('mobile-menu-button');\n    await expect(mobileMenu).toBeVisible();\n    \n    await mobileMenu.click();\n    await expect(page.getByTestId('mobile-menu')).toBeVisible();\n  });\n\n  test('多语言支持', async () => {\n    // 切换到英文\n    await page.getByTestId('language-selector').click();\n    await page.getByText('English').click();\n    \n    // 验证界面语言切换\n    await expect(page.getByText('Drag files here')).toBeVisible();\n    await expect(page.getByText('Supported formats')).toBeVisible();\n    \n    // 上传文件并验证英文提示\n    const zipFilePath = path.join(__dirname, '../fixtures/archives/sample.zip');\n    await page.setInputFiles('input[type=\"file\"]', zipFilePath);\n    \n    await expect(page.getByText('File uploaded successfully')).toBeVisible();\n    await expect(page.getByText('Extraction complete')).toBeVisible({ timeout: 10000 });\n    \n    // 切换回中文\n    await page.getByTestId('language-selector').click();\n    await page.getByText('中文').click();\n    \n    await expect(page.getByText('拖拽文件到此处')).toBeVisible();\n  });\n\n  test('主题切换功能', async () => {\n    // 验证默认主题\n    const body = page.locator('body');\n    await expect(body).toHaveClass(/light-theme/);\n    \n    // 切换到暗色主题\n    await page.getByTestId('theme-toggle').click();\n    await expect(body).toHaveClass(/dark-theme/);\n    \n    // 验证主题持久化\n    await page.reload();\n    await expect(body).toHaveClass(/dark-theme/);\n    \n    // 切换回亮色主题\n    await page.getByTestId('theme-toggle').click();\n    await expect(body).toHaveClass(/light-theme/);\n  });\n\n  test('离线功能测试', async () => {\n    // 首先在线加载应用\n    const zipFilePath = path.join(__dirname, '../fixtures/archives/sample.zip');\n    await page.setInputFiles('input[type=\"file\"]', zipFilePath);\n    await expect(page.getByTestId('file-tree')).toBeVisible({ timeout: 10000 });\n    \n    // 模拟离线状态\n    await context.setOffline(true);\n    \n    // 刷新页面，验证离线缓存\n    await page.reload();\n    await expect(page.getByTestId('file-upload-zone')).toBeVisible({ timeout: 5000 });\n    \n    // 验证离线提示\n    await expect(page.getByTestId('offline-indicator')).toBeVisible();\n    await expect(page.getByText('离线模式')).toBeVisible();\n    \n    // 验证基础功能仍然可用\n    const offlineZipPath = path.join(__dirname, '../fixtures/archives/offline_test.zip');\n    await page.setInputFiles('input[type=\"file\"]', offlineZipPath);\n    await expect(page.getByTestId('file-tree')).toBeVisible({ timeout: 10000 });\n    \n    // 恢复在线状态\n    await context.setOffline(false);\n    await expect(page.getByTestId('offline-indicator')).not.toBeVisible();\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/tests/e2e/cross-browser-compatibility.spec.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Expression expected.","line":137,"column":26,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { test, expect, devices } from '@playwright/test';\nimport path from 'path';\n\n// 定义测试设备配置\nconst testDevices = [\n  { name: 'Desktop Chrome', ...devices['Desktop Chrome'] },\n  { name: 'Desktop Firefox', ...devices['Desktop Firefox'] },\n  { name: 'Desktop Safari', ...devices['Desktop Safari'] },\n  { name: 'Mobile Chrome', ...devices['Pixel 5'] },\n  { name: 'Mobile Safari', ...devices['iPhone 12'] },\n  { name: 'Tablet', ...devices['iPad Pro'] }\n];\n\nfor (const device of testDevices) {\n  test.describe(`${device.name} - 跨浏览器兼容性测试`, () => {\n    test.use(device);\n\n    test('基础功能兼容性', async ({ page, browserName }) => {\n      await page.goto('/');\n      \n      // 验证页面加载\n      await expect(page).toHaveTitle(/ZhugeExtract/);\n      await expect(page.getByTestId('file-upload-zone')).toBeVisible();\n      \n      // 检查WebAssembly支持\n      const wasmSupported = await page.evaluate(() => {\n        return typeof WebAssembly === 'object' && typeof WebAssembly.instantiate === 'function';\n      });\n      \n      if (!wasmSupported) {\n        console.warn(`WebAssembly not supported in ${browserName}`);\n        return; // 跳过后续测试\n      }\n      \n      // 上传测试文件\n      const zipFilePath = path.join(__dirname, '../fixtures/archives/compatibility_test.zip');\n      await page.setInputFiles('input[type=\"file\"]', zipFilePath);\n      \n      // 验证解压功能\n      await expect(page.getByTestId('file-tree')).toBeVisible({ timeout: 15000 });\n      await expect(page.getByText('test_file.txt')).toBeVisible();\n      \n      // 验证预览功能\n      await page.getByText('test_file.txt').click();\n      await expect(page.getByTestId('preview-content')).toBeVisible();\n    });\n\n    test('文件API兼容性', async ({ page, browserName }) => {\n      await page.goto('/');\n      \n      // 检查File API支持\n      const fileApiSupport = await page.evaluate(() => {\n        return {\n          fileReader: typeof FileReader !== 'undefined',\n          fileApi: typeof File !== 'undefined',\n          dragDrop: 'ondrop' in document.createElement('div'),\n          fileSystemAccess: 'showOpenFilePicker' in window\n        };\n      });\n      \n      console.log(`${browserName} API Support:`, fileApiSupport);\n      \n      // 验证基础文件操作\n      if (fileApiSupport.fileReader && fileApiSupport.fileApi) {\n        const zipFilePath = path.join(__dirname, '../fixtures/archives/api_test.zip');\n        await page.setInputFiles('input[type=\"file\"]', zipFilePath);\n        await expect(page.getByTestId('file-tree')).toBeVisible({ timeout: 10000 });\n      }\n      \n      // 测试拖拽功能（如果支持）\n      if (fileApiSupport.dragDrop) {\n        const dropZone = page.getByTestId('file-upload-zone');\n        await expect(dropZone).toHaveAttribute('ondrop');\n      }\n      \n      // 测试FileSystem Access API（Chrome专用）\n      if (fileApiSupport.fileSystemAccess) {\n        await expect(page.getByTestId('advanced-file-operations')).toBeVisible();\n      } else {\n        // 验证降级方案\n        await expect(page.getByTestId('fallback-file-operations')).toBeVisible();\n      }\n    });\n\n    test('CSS和布局兼容性', async ({ page, browserName, viewport }) => {\n      await page.goto('/');\n      \n      // 检查CSS Grid和Flexbox支持\n      const cssSupport = await page.evaluate(() => {\n        const testElement = document.createElement('div');\n        return {\n          grid: CSS.supports('display', 'grid'),\n          flexbox: CSS.supports('display', 'flex'),\n          customProperties: CSS.supports('color', 'var(--test)'),\n          aspectRatio: CSS.supports('aspect-ratio', '1/1')\n        };\n      });\n      \n      console.log(`${browserName} CSS Support:`, cssSupport);\n      \n      // 验证响应式布局\n      const container = page.getByTestId('main-container');\n      \n      if (viewport && viewport.width < 768) {\n        // 移动端布局\n        await expect(container).toHaveClass(/mobile-layout/);\n        await expect(page.getByTestId('mobile-menu-button')).toBeVisible();\n      } else {\n        // 桌面端布局\n        await expect(container).toHaveClass(/desktop-layout/);\n        await expect(page.getByTestId('sidebar')).toBeVisible();\n      }\n      \n      // 验证关键元素的可见性和位置\n      await expect(page.getByTestId('file-upload-zone')).toBeVisible();\n      \n      const uploadZone = page.getByTestId('file-upload-zone');\n      const boundingBox = await uploadZone.boundingBox();\n      \n      expect(boundingBox).not.toBeNull();\n      expect(boundingBox!.width).toBeGreaterThan(200);\n      expect(boundingBox!.height).toBeGreaterThan(100);\n    });\n\n    test('JavaScript兼容性', async ({ page, browserName }) => {\n      await page.goto('/');\n      \n      // 检查现代JavaScript特性支持\n      const jsSupport = await page.evaluate(() => {\n        const testArray = [1, 2, 3];\n        return {\n          arrowFunctions: (() => true)(),\n          asyncAwait: typeof (async () => {})().then === 'function',\n          destructuring: (() => { const [a] = testArray; return a === 1; })(),\n          spread: [...testArray].length === 3,\n          promises: typeof Promise !== 'undefined',\n          modules: typeof import !== 'undefined',\n          classes: (() => { class Test {} return typeof Test === 'function'; })(),\n          mapSet: typeof Map !== 'undefined' && typeof Set !== 'undefined',\n          symbolIterator: typeof Symbol !== 'undefined' && typeof Symbol.iterator !== 'undefined'\n        };\n      });\n      \n      console.log(`${browserName} JS Features:`, jsSupport);\n      \n      // 如果不支持某些特性，验证polyfill是否正常工作\n      if (!jsSupport.promises) {\n        // 验证Promise polyfill\n        const promiseWorks = await page.evaluate(() => {\n          return new Promise(resolve => resolve(true));\n        });\n        expect(promiseWorks).toBe(true);\n      }\n      \n      // 验证错误处理\n      const errorHandlerWorks = await page.evaluate(() => {\n        try {\n          throw new Error('Test error');\n        } catch (e) {\n          return e.message === 'Test error';\n        }\n      });\n      expect(errorHandlerWorks).toBe(true);\n    });\n\n    test('性能基准测试', async ({ page, browserName }) => {\n      await page.goto('/');\n      \n      // 测试页面加载性能\n      const navigationTiming = await page.evaluate(() => {\n        const timing = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming;\n        return {\n          domContentLoaded: timing.domContentLoadedEventEnd - timing.domContentLoadedEventStart,\n          loadComplete: timing.loadEventEnd - timing.loadEventStart,\n          firstPaint: performance.getEntriesByName('first-paint')[0]?.startTime || 0,\n          firstContentfulPaint: performance.getEntriesByName('first-contentful-paint')[0]?.startTime || 0\n        };\n      });\n      \n      console.log(`${browserName} Performance:`, navigationTiming);\n      \n      // 验证性能指标在合理范围内\n      expect(navigationTiming.domContentLoaded).toBeLessThan(3000); // 3秒内\n      expect(navigationTiming.loadComplete).toBeLessThan(5000); // 5秒内\n      \n      // 测试文件处理性能\n      const smallZipPath = path.join(__dirname, '../fixtures/archives/small_1mb.zip');\n      await page.setInputFiles('input[type=\"file\"]', smallZipPath);\n      \n      const startTime = Date.now();\n      await expect(page.getByTestId('file-tree')).toBeVisible({ timeout: 10000 });\n      const processingTime = Date.now() - startTime;\n      \n      console.log(`${browserName} File Processing Time: ${processingTime}ms`);\n      expect(processingTime).toBeLessThan(5000); // 5秒内处理1MB文件\n    });\n\n    test('内存使用监控', async ({ page, browserName }) => {\n      await page.goto('/');\n      \n      // 检查内存API支持\n      const memoryApiSupported = await page.evaluate(() => {\n        return 'memory' in performance;\n      });\n      \n      if (memoryApiSupported) {\n        const initialMemory = await page.evaluate(() => {\n          const memory = (performance as any).memory;\n          return {\n            used: memory.usedJSHeapSize,\n            total: memory.totalJSHeapSize,\n            limit: memory.jsHeapSizeLimit\n          };\n        });\n        \n        console.log(`${browserName} Initial Memory:`, initialMemory);\n        \n        // 处理文件并监控内存变化\n        const mediumZipPath = path.join(__dirname, '../fixtures/archives/medium_10mb.zip');\n        await page.setInputFiles('input[type=\"file\"]', mediumZipPath);\n        await expect(page.getByTestId('file-tree')).toBeVisible({ timeout: 15000 });\n        \n        const afterProcessingMemory = await page.evaluate(() => {\n          const memory = (performance as any).memory;\n          return {\n            used: memory.usedJSHeapSize,\n            total: memory.totalJSHeapSize,\n            limit: memory.jsHeapSizeLimit\n          };\n        });\n        \n        console.log(`${browserName} After Processing Memory:`, afterProcessingMemory);\n        \n        // 验证内存增长在合理范围内\n        const memoryIncrease = afterProcessingMemory.used - initialMemory.used;\n        expect(memoryIncrease).toBeLessThan(50 * 1024 * 1024); // 50MB内存增长限制\n      }\n    });\n\n    test('安全功能测试', async ({ page, browserName }) => {\n      await page.goto('/');\n      \n      // 测试内容安全策略 (CSP)\n      const cspViolations: string[] = [];\n      page.on('console', msg => {\n        if (msg.type() === 'error' && msg.text().includes('Content Security Policy')) {\n          cspViolations.push(msg.text());\n        }\n      });\n      \n      // 上传文件触发各种操作\n      const zipFilePath = path.join(__dirname, '../fixtures/archives/security_test.zip');\n      await page.setInputFiles('input[type=\"file\"]', zipFilePath);\n      await expect(page.getByTestId('file-tree')).toBeVisible({ timeout: 10000 });\n      \n      // 验证没有CSP违规\n      expect(cspViolations).toHaveLength(0);\n      \n      // 测试XSS防护\n      const fileTree = page.getByTestId('file-tree');\n      await expect(fileTree.getByText('<script>alert(\"xss\")</script>')).not.toBeVisible();\n      \n      // 验证安全的文件名处理\n      const suspiciousFile = '..\\\\..\\\\malicious.exe';\n      await expect(fileTree.getByText(suspiciousFile)).not.toBeVisible();\n    });\n\n    test('辅助功能 (A11y) 测试', async ({ page, browserName }) => {\n      await page.goto('/');\n      \n      // 注入axe-core进行辅助功能测试\n      await page.addScriptTag({\n        url: 'https://unpkg.com/axe-core@4.6.3/axe.min.js'\n      });\n      \n      // 运行辅助功能检查\n      const accessibilityResults = await page.evaluate(() => {\n        return (window as any).axe.run();\n      });\n      \n      // 验证没有严重的辅助功能问题\n      const violations = accessibilityResults.violations.filter(\n        (violation: any) => violation.impact === 'critical' || violation.impact === 'serious'\n      );\n      \n      if (violations.length > 0) {\n        console.warn(`${browserName} A11y Violations:`, violations);\n      }\n      \n      expect(violations.length).toBe(0);\n      \n      // 手动测试一些关键的辅助功能\n      const uploadZone = page.getByTestId('file-upload-zone');\n      await expect(uploadZone).toHaveAttribute('role');\n      await expect(uploadZone).toHaveAttribute('aria-label');\n      await expect(uploadZone).toHaveAttribute('tabindex');\n      \n      // 测试键盘导航\n      await page.keyboard.press('Tab');\n      await expect(uploadZone).toBeFocused();\n      \n      // 测试屏幕阅读器支持\n      const srOnly = page.locator('.sr-only').first();\n      if (await srOnly.isVisible()) {\n        await expect(srOnly).toHaveText(/可访问性信息/);\n      }\n    });\n\n    test('网络条件测试', async ({ page, browserName, context }) => {\n      // 模拟慢速网络\n      await context.route('**/*', route => {\n        setTimeout(() => route.continue(), 100); // 100ms延迟\n      });\n      \n      await page.goto('/');\n      await expect(page.getByTestId('file-upload-zone')).toBeVisible({ timeout: 10000 });\n      \n      // 在慢速网络下测试文件上传\n      const zipFilePath = path.join(__dirname, '../fixtures/archives/network_test.zip');\n      await page.setInputFiles('input[type=\"file\"]', zipFilePath);\n      \n      // 验证加载指示器\n      await expect(page.getByTestId('loading-spinner')).toBeVisible();\n      await expect(page.getByTestId('progress-bar')).toBeVisible();\n      \n      // 等待处理完成\n      await expect(page.getByTestId('file-tree')).toBeVisible({ timeout: 15000 });\n      \n      // 模拟网络中断\n      await context.setOffline(true);\n      \n      // 验证离线处理能力\n      const offlineFilePath = path.join(__dirname, '../fixtures/archives/offline.zip');\n      await page.setInputFiles('input[type=\"file\"]', offlineFilePath);\n      \n      // 即使离线也应该能处理本地文件\n      await expect(page.getByTestId('file-tree')).toBeVisible({ timeout: 10000 });\n      \n      // 恢复网络\n      await context.setOffline(false);\n    });\n\n    test('存储配额测试', async ({ page, browserName }) => {\n      await page.goto('/');\n      \n      // 检查存储API支持\n      const storageSupport = await page.evaluate(async () => {\n        const hasStorageManager = 'storage' in navigator && 'estimate' in navigator.storage;\n        let quota = { usage: 0, quota: 0 };\n        \n        if (hasStorageManager) {\n          quota = await navigator.storage.estimate();\n        }\n        \n        return {\n          hasStorageManager,\n          indexedDB: 'indexedDB' in window,\n          localStorage: 'localStorage' in window,\n          quota: quota\n        };\n      });\n      \n      console.log(`${browserName} Storage Support:`, storageSupport);\n      \n      if (storageSupport.hasStorageManager) {\n        // 测试大文件存储能力\n        const largeFilePath = path.join(__dirname, '../fixtures/archives/large_25mb.zip');\n        await page.setInputFiles('input[type=\"file\"]', largeFilePath);\n        await expect(page.getByTestId('file-tree')).toBeVisible({ timeout: 20000 });\n        \n        // 检查存储使用情况\n        const storageAfter = await page.evaluate(async () => {\n          return await navigator.storage.estimate();\n        });\n        \n        console.log(`${browserName} Storage After Large File:`, storageAfter);\n        \n        // 验证存储管理\n        const storageUsage = storageAfter.usage! / (1024 * 1024); // MB\n        expect(storageUsage).toBeLessThan(100); // 不应超过100MB\n      }\n    });\n  });\n}\n\n// 特殊的浏览器特定测试\ntest.describe('Chrome特定功能测试', () => {\n  test.use({ ...devices['Desktop Chrome'] });\n\n  test('FileSystem Access API', async ({ page }) => {\n    await page.goto('/');\n    \n    const hasFileSystemAccess = await page.evaluate(() => {\n      return 'showOpenFilePicker' in window;\n    });\n    \n    if (hasFileSystemAccess) {\n      // 验证高级文件操作按钮存在\n      await expect(page.getByTestId('advanced-file-picker')).toBeVisible();\n      \n      // 测试目录选择功能\n      await expect(page.getByTestId('directory-picker')).toBeVisible();\n    }\n  });\n\n  test('Origin Private File System (OPFS)', async ({ page }) => {\n    await page.goto('/');\n    \n    const hasOPFS = await page.evaluate(async () => {\n      try {\n        const opfsRoot = await navigator.storage.getDirectory();\n        return opfsRoot !== null;\n      } catch {\n        return false;\n      }\n    });\n    \n    if (hasOPFS) {\n      console.log('OPFS supported in Chrome');\n      \n      // 测试大文件的OPFS存储\n      const largeFilePath = path.join(__dirname, '../fixtures/archives/large_50mb.zip');\n      await page.setInputFiles('input[type=\"file\"]', largeFilePath);\n      \n      // 验证使用OPFS存储\n      await expect(page.getByTestId('opfs-storage-indicator')).toBeVisible();\n    }\n  });\n});\n\ntest.describe('Safari特定限制测试', () => {\n  test.use({ ...devices['Desktop Safari'] });\n\n  test('Safari限制处理', async ({ page }) => {\n    await page.goto('/');\n    \n    // Safari对某些API有限制，验证降级方案\n    const safariLimitations = await page.evaluate(() => {\n      return {\n        noFileSystemAccess: !('showOpenFilePicker' in window),\n        limitedWorkers: typeof SharedWorker === 'undefined',\n        restrictedStorage: false // 根据实际情况调整\n      };\n    });\n    \n    console.log('Safari Limitations:', safariLimitations);\n    \n    if (safariLimitations.noFileSystemAccess) {\n      // 验证传统文件选择降级方案\n      await expect(page.getByTestId('traditional-file-picker')).toBeVisible();\n      await expect(page.getByTestId('advanced-file-picker')).not.toBeVisible();\n    }\n    \n    // 测试基础功能仍然正常\n    const zipFilePath = path.join(__dirname, '../fixtures/archives/safari_test.zip');\n    await page.setInputFiles('input[type=\"file\"]', zipFilePath);\n    await expect(page.getByTestId('file-tree')).toBeVisible({ timeout: 15000 });\n  });\n});\n\ntest.describe('移动设备特定测试', () => {\n  test('iOS Safari触摸交互', async ({ page }) => {\n    test.use({ ...devices['iPhone 12'] });\n    \n    await page.goto('/');\n    \n    const zipFilePath = path.join(__dirname, '../fixtures/archives/mobile_test.zip');\n    await page.setInputFiles('input[type=\"file\"]', zipFilePath);\n    await expect(page.getByTestId('file-tree')).toBeVisible({ timeout: 15000 });\n    \n    // 测试触摸手势\n    const fileItem = page.getByText('mobile_file.txt').first();\n    \n    // 点击选择\n    await fileItem.tap();\n    await expect(page.getByTestId('preview-panel')).toBeVisible();\n    \n    // 测试长按菜单（如果支持）\n    await fileItem.tap({ delay: 500 });\n    // 验证上下文菜单或相关功能\n  });\n\n  test('Android Chrome性能', async ({ page }) => {\n    test.use({ ...devices['Pixel 5'] });\n    \n    await page.goto('/');\n    \n    // 在移动设备上测试性能\n    const mediumFilePath = path.join(__dirname, '../fixtures/archives/mobile_medium.zip');\n    \n    const startTime = Date.now();\n    await page.setInputFiles('input[type=\"file\"]', mediumFilePath);\n    await expect(page.getByTestId('file-tree')).toBeVisible({ timeout: 20000 });\n    const processingTime = Date.now() - startTime;\n    \n    console.log(`Mobile Processing Time: ${processingTime}ms`);\n    \n    // 移动设备性能要求相对宽松\n    expect(processingTime).toBeLessThan(15000); // 15秒内\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/tests/e2e/zip-rar-user-scenarios.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/tests/fixtures/file-generator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/tests/fixtures/zip-rar-test-data.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'TestFileGenerator' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":27},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":428,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":428,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12409,12412],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12409,12412],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { TestFileGenerator } from './file-generator';\n\n/**\n * ZIP和RAR格式专用测试数据生成器\n * 提供更真实和复杂的测试场景\n */\nexport class ZipRarTestData {\n  \n  // 生成标准ZIP文件数据\n  static generateStandardZip(): ArrayBuffer {\n    const zipData = new ArrayBuffer(1024);\n    const view = new Uint8Array(zipData);\n    \n    // ZIP文件头\n    const header = [\n      // Local file header signature\n      0x50, 0x4b, 0x03, 0x04,\n      // Version needed to extract\n      0x14, 0x00,\n      // General purpose bit flag\n      0x00, 0x00,\n      // Compression method (deflate)\n      0x08, 0x00,\n      // File last modification time\n      0x00, 0x00,\n      // File last modification date\n      0x00, 0x21,\n      // CRC-32\n      0x12, 0x34, 0x56, 0x78,\n      // Compressed size\n      0x16, 0x00, 0x00, 0x00,\n      // Uncompressed size\n      0x16, 0x00, 0x00, 0x00,\n      // File name length\n      0x08, 0x00,\n      // Extra field length\n      0x00, 0x00\n    ];\n    \n    header.forEach((byte, index) => {\n      view[index] = byte;\n    });\n    \n    // 文件名 \"test.txt\"\n    const fileName = new TextEncoder().encode('test.txt');\n    fileName.forEach((byte, index) => {\n      view[header.length + index] = byte;\n    });\n    \n    // 压缩数据 (简化)\n    const compressedData = [\n      0x2b, 0x49, 0x2d, 0x2e, 0x51, 0x48, 0x49, 0x2c,\n      0x49, 0x04, 0x00, 0x2d, 0x49, 0x2d, 0x2e, 0x51,\n      0x48, 0x49, 0x2c, 0x49, 0x04, 0x00\n    ];\n    \n    compressedData.forEach((byte, index) => {\n      view[header.length + fileName.length + index] = byte;\n    });\n    \n    return zipData;\n  }\n\n  // 生成密码保护的ZIP文件数据\n  static generatePasswordProtectedZip(): ArrayBuffer {\n    const zipData = new ArrayBuffer(2048);\n    const view = new Uint8Array(zipData);\n    \n    // 带加密标志的ZIP头\n    const encryptedHeader = [\n      0x50, 0x4b, 0x03, 0x04, // 签名\n      0x14, 0x00,             // 版本\n      0x01, 0x00,             // 加密标志 (bit 0 set)\n      0x08, 0x00,             // 压缩方法\n      0x00, 0x00, 0x00, 0x21, // 时间戳\n      0x00, 0x00, 0x00, 0x00, // CRC32 (0 for encrypted)\n      0x20, 0x00, 0x00, 0x00, // 压缩大小\n      0x16, 0x00, 0x00, 0x00, // 原始大小\n      0x0c, 0x00,             // 文件名长度\n      0x00, 0x00              // 额外字段长度\n    ];\n    \n    encryptedHeader.forEach((byte, index) => {\n      view[index] = byte;\n    });\n    \n    // 文件名 (加密文件)\n    const fileName = new TextEncoder().encode('secret.txt');\n    fileName.forEach((byte, index) => {\n      view[encryptedHeader.length + index] = byte;\n    });\n    \n    // 加密的数据 (模拟)\n    const encryptedData = new Uint8Array(32);\n    for (let i = 0; i < encryptedData.length; i++) {\n      encryptedData[i] = Math.floor(Math.random() * 256);\n    }\n    \n    encryptedData.forEach((byte, index) => {\n      view[encryptedHeader.length + fileName.length + index] = byte;\n    });\n    \n    return zipData.slice(0, encryptedHeader.length + fileName.length + encryptedData.length);\n  }\n\n  // 生成多文件ZIP测试数据\n  static generateMultiFileZip(): ArrayBuffer {\n    const files = [\n      { name: 'readme.txt', content: 'Welcome to ZhugeExtract!' },\n      { name: 'image.jpg', content: 'JPEG_MOCK_DATA' },\n      { name: 'document.pdf', content: 'PDF_MOCK_DATA' },\n      { name: 'folder/', content: '', isDirectory: true }\n    ];\n    \n    const zipData = new ArrayBuffer(8192);\n    const view = new Uint8Array(zipData);\n    let offset = 0;\n    \n    files.forEach(file => {\n      // Local file header\n      const header = [\n        0x50, 0x4b, 0x03, 0x04, // 签名\n        0x14, 0x00,             // 版本\n        0x00, 0x00,             // 标志\n        file.isDirectory ? 0x00 : 0x08, 0x00, // 压缩方法\n        0x00, 0x00, 0x00, 0x21, // 时间戳\n        0x12, 0x34, 0x56, 0x78, // CRC32\n        file.content.length, 0x00, 0x00, 0x00, // 压缩大小\n        file.content.length, 0x00, 0x00, 0x00, // 原始大小\n        file.name.length, 0x00, // 文件名长度\n        0x00, 0x00              // 额外字段长度\n      ];\n      \n      // 写入头部\n      header.forEach((byte, i) => {\n        view[offset + i] = byte;\n      });\n      offset += header.length;\n      \n      // 写入文件名\n      const nameBytes = new TextEncoder().encode(file.name);\n      nameBytes.forEach((byte, i) => {\n        view[offset + i] = byte;\n      });\n      offset += nameBytes.length;\n      \n      // 写入文件内容\n      if (!file.isDirectory) {\n        const contentBytes = new TextEncoder().encode(file.content);\n        contentBytes.forEach((byte, i) => {\n          view[offset + i] = byte;\n        });\n        offset += contentBytes.length;\n      }\n    });\n    \n    return zipData.slice(0, offset);\n  }\n\n  // 生成标准RAR文件数据\n  static generateStandardRar(): ArrayBuffer {\n    const rarData = new ArrayBuffer(2048);\n    const view = new Uint8Array(rarData);\n    \n    // RAR 5.x 签名和头部\n    const rar5Header = [\n      // RAR signature\n      0x52, 0x61, 0x72, 0x21, 0x1a, 0x07, 0x01, 0x00,\n      // Archive header\n      0x01, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      // File header starts here\n      0x02, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x08, 0x00, 0x00, 0x00, 0x74, 0x65, 0x73, 0x74,\n      0x2e, 0x74, 0x78, 0x74\n    ];\n    \n    rar5Header.forEach((byte, index) => {\n      view[index] = byte;\n    });\n    \n    // 文件数据\n    const fileData = new TextEncoder().encode('RAR test content');\n    fileData.forEach((byte, index) => {\n      view[rar5Header.length + index] = byte;\n    });\n    \n    return rarData.slice(0, rar5Header.length + fileData.length);\n  }\n\n  // 生成密码保护的RAR文件数据\n  static generatePasswordProtectedRar(): ArrayBuffer {\n    const rarData = new ArrayBuffer(3072);\n    const view = new Uint8Array(rarData);\n    \n    // RAR 5.x 加密头\n    const encryptedRarHeader = [\n      // RAR signature\n      0x52, 0x61, 0x72, 0x21, 0x1a, 0x07, 0x01, 0x00,\n      // Archive header with encryption\n      0x01, 0x00, 0x09, 0x00, 0x80, 0x00, 0x00, 0x00, // 0x80 = encrypted\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      // Encryption info\n      0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n      // Encrypted file header\n      0x02, 0x00, 0x15, 0x00, 0x80, 0x00, 0x00, 0x00\n    ];\n    \n    encryptedRarHeader.forEach((byte, index) => {\n      view[index] = byte;\n    });\n    \n    // 加密的文件数据\n    const encryptedData = new Uint8Array(256);\n    for (let i = 0; i < encryptedData.length; i++) {\n      encryptedData[i] = Math.floor(Math.random() * 256);\n    }\n    \n    encryptedData.forEach((byte, index) => {\n      view[encryptedRarHeader.length + index] = byte;\n    });\n    \n    return rarData.slice(0, encryptedRarHeader.length + encryptedData.length);\n  }\n\n  // 生成RAR分卷文件数据\n  static generateRarVolumes(): ArrayBuffer[] {\n    const volumes = [];\n    \n    // 第一卷 (part1.rar)\n    const volume1 = new ArrayBuffer(1024);\n    const view1 = new Uint8Array(volume1);\n    \n    const vol1Header = [\n      0x52, 0x61, 0x72, 0x21, 0x1a, 0x07, 0x01, 0x00, // RAR signature\n      0x01, 0x00, 0x09, 0x00, 0x01, 0x00, 0x00, 0x00, // Archive header (volume flag)\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n    ];\n    \n    vol1Header.forEach((byte, index) => {\n      view1[index] = byte;\n    });\n    volumes.push(volume1);\n    \n    // 第二卷 (part2.rar)\n    const volume2 = new ArrayBuffer(1024);\n    const view2 = new Uint8Array(volume2);\n    \n    const vol2Header = [\n      0x52, 0x61, 0x72, 0x21, 0x1a, 0x07, 0x01, 0x00, // RAR signature\n      0x01, 0x00, 0x09, 0x00, 0x02, 0x00, 0x00, 0x00, // Archive header (volume 2)\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n    ];\n    \n    vol2Header.forEach((byte, index) => {\n      view2[index] = byte;\n    });\n    volumes.push(volume2);\n    \n    // 最后一卷 (part3.rar)\n    const volume3 = new ArrayBuffer(1024);\n    const view3 = new Uint8Array(volume3);\n    \n    const vol3Header = [\n      0x52, 0x61, 0x72, 0x21, 0x1a, 0x07, 0x01, 0x00, // RAR signature\n      0x01, 0x00, 0x09, 0x00, 0x04, 0x00, 0x00, 0x00, // Archive header (last volume flag)\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n    ];\n    \n    vol3Header.forEach((byte, index) => {\n      view3[index] = byte;\n    });\n    volumes.push(volume3);\n    \n    return volumes;\n  }\n\n  // 生成损坏的ZIP文件\n  static generateCorruptedZip(): ArrayBuffer {\n    const corruptedZip = new ArrayBuffer(512);\n    const view = new Uint8Array(corruptedZip);\n    \n    // 部分ZIP签名\n    view[0] = 0x50;\n    view[1] = 0x4b;\n    view[2] = 0x03;\n    view[3] = 0x04;\n    \n    // 损坏的头部数据\n    for (let i = 4; i < 50; i++) {\n      view[i] = 0xFF; // 无效数据\n    }\n    \n    // 随机数据填充\n    for (let i = 50; i < 512; i++) {\n      view[i] = Math.floor(Math.random() * 256);\n    }\n    \n    return corruptedZip;\n  }\n\n  // 生成损坏的RAR文件\n  static generateCorruptedRar(): ArrayBuffer {\n    const corruptedRar = new ArrayBuffer(1024);\n    const view = new Uint8Array(corruptedRar);\n    \n    // RAR签名 (正确)\n    const signature = [0x52, 0x61, 0x72, 0x21, 0x1a, 0x07, 0x01, 0x00];\n    signature.forEach((byte, index) => {\n      view[index] = byte;\n    });\n    \n    // 损坏的头部\n    for (let i = 8; i < 64; i++) {\n      view[i] = 0x00; // 无效的头部数据\n    }\n    \n    // 随机损坏数据\n    for (let i = 64; i < 1024; i++) {\n      view[i] = Math.floor(Math.random() * 256);\n    }\n    \n    return corruptedRar;\n  }\n\n  // 生成带恢复记录的RAR文件\n  static generateRarWithRecovery(): ArrayBuffer {\n    const rarData = new ArrayBuffer(4096);\n    const view = new Uint8Array(rarData);\n    \n    // 标准RAR头\n    const rarHeader = [\n      0x52, 0x61, 0x72, 0x21, 0x1a, 0x07, 0x01, 0x00,\n      0x01, 0x00, 0x0d, 0x00, 0x20, 0x00, 0x00, 0x00, // 0x20 = recovery record flag\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n    ];\n    \n    rarHeader.forEach((byte, index) => {\n      view[index] = byte;\n    });\n    \n    // 恢复记录头\n    const recoveryHeader = [\n      0x78, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, // Recovery record header\n      0x01, 0x00, 0x00, 0x00 // Recovery sectors\n    ];\n    \n    recoveryHeader.forEach((byte, index) => {\n      view[rarHeader.length + index] = byte;\n    });\n    \n    // 恢复数据 (1KB)\n    const recoveryData = new Uint8Array(1024);\n    for (let i = 0; i < recoveryData.length; i++) {\n      recoveryData[i] = i % 256; // 模式数据\n    }\n    \n    recoveryData.forEach((byte, index) => {\n      view[rarHeader.length + recoveryHeader.length + index] = byte;\n    });\n    \n    return rarData.slice(0, rarHeader.length + recoveryHeader.length + recoveryData.length);\n  }\n\n  // 生成固实压缩RAR文件\n  static generateSolidRar(): ArrayBuffer {\n    const solidRar = new ArrayBuffer(3072);\n    const view = new Uint8Array(solidRar);\n    \n    // RAR签名\n    const signature = [0x52, 0x61, 0x72, 0x21, 0x1a, 0x07, 0x01, 0x00];\n    signature.forEach((byte, index) => {\n      view[index] = byte;\n    });\n    \n    // 档案头 (固实标志)\n    const archiveHeader = [\n      0x01, 0x00, 0x09, 0x00, 0x08, 0x00, 0x00, 0x00, // 0x08 = solid flag\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n    ];\n    \n    archiveHeader.forEach((byte, index) => {\n      view[signature.length + index] = byte;\n    });\n    \n    // 文件头1 (固实文件)\n    const file1Header = [\n      0x02, 0x00, 0x15, 0x00, 0x88, 0x00, 0x00, 0x00, // 0x88 = solid + compressed\n      0x0a, 0x00, 0x00, 0x00, // 文件大小\n      0x66, 0x69, 0x6c, 0x65, 0x31, 0x2e, 0x74, 0x78, 0x74, 0x00 // \"file1.txt\"\n    ];\n    \n    file1Header.forEach((byte, index) => {\n      view[signature.length + archiveHeader.length + index] = byte;\n    });\n    \n    return solidRar.slice(0, signature.length + archiveHeader.length + file1Header.length);\n  }\n\n  // 生成测试文件集合\n  static generateTestFileSet(): {\n    zipFiles: { name: string; data: ArrayBuffer }[];\n    rarFiles: { name: string; data: ArrayBuffer }[];\n  } {\n    return {\n      zipFiles: [\n        { name: 'standard.zip', data: this.generateStandardZip() },\n        { name: 'password-protected.zip', data: this.generatePasswordProtectedZip() },\n        { name: 'multi-file.zip', data: this.generateMultiFileZip() },\n        { name: 'corrupted.zip', data: this.generateCorruptedZip() }\n      ],\n      rarFiles: [\n        { name: 'standard.rar', data: this.generateStandardRar() },\n        { name: 'password-protected.rar', data: this.generatePasswordProtectedRar() },\n        { name: 'with-recovery.rar', data: this.generateRarWithRecovery() },\n        { name: 'solid.rar', data: this.generateSolidRar() },\n        { name: 'corrupted.rar', data: this.generateCorruptedRar() }\n      ]\n    };\n  }\n\n  // 创建压缩测试场景\n  static createCompressionScenarios(): Array<{\n    name: string;\n    format: 'zip' | 'rar';\n    data: ArrayBuffer;\n    expectedBehavior: string;\n    testParams: Record<string, any>;\n  }> {\n    return [\n      {\n        name: 'ZIP最佳压缩比测试',\n        format: 'zip',\n        data: this.generateStandardZip(),\n        expectedBehavior: 'high_compression_ratio',\n        testParams: { expectedRatio: 0.7, maxTime: 1000 }\n      },\n      {\n        name: 'RAR固实压缩性能测试',\n        format: 'rar',\n        data: this.generateSolidRar(),\n        expectedBehavior: 'solid_compression_efficiency',\n        testParams: { sequential: true, maxMemory: 50 * 1024 * 1024 }\n      },\n      {\n        name: 'ZIP密码破解防护测试',\n        format: 'zip',\n        data: this.generatePasswordProtectedZip(),\n        expectedBehavior: 'password_protection',\n        testParams: { attempts: 3, lockoutTime: 1000 }\n      },\n      {\n        name: 'RAR恢复记录功能测试',\n        format: 'rar',\n        data: this.generateRarWithRecovery(),\n        expectedBehavior: 'error_recovery',\n        testParams: { recoverySuccess: true, maxRecoveryTime: 5000 }\n      }\n    ];\n  }\n}\n\n// 导出便捷的测试数据访问器\nexport const zipTestData = {\n  standard: () => ZipRarTestData.generateStandardZip(),\n  passwordProtected: () => ZipRarTestData.generatePasswordProtectedZip(),\n  multiFile: () => ZipRarTestData.generateMultiFileZip(),\n  corrupted: () => ZipRarTestData.generateCorruptedZip()\n};\n\nexport const rarTestData = {\n  standard: () => ZipRarTestData.generateStandardRar(),\n  passwordProtected: () => ZipRarTestData.generatePasswordProtectedRar(),\n  volumes: () => ZipRarTestData.generateRarVolumes(),\n  withRecovery: () => ZipRarTestData.generateRarWithRecovery(),\n  solid: () => ZipRarTestData.generateSolidRar(),\n  corrupted: () => ZipRarTestData.generateCorruptedRar()\n};","usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/tests/integration/apis/libarchive-integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/tests/integration/workflows/archive-extraction-workflow.test.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: '>' expected.","line":79,"column":28,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport React from 'react';\nimport { ArchiveViewer } from '@/components/ArchiveViewer';\nimport { ArchiveService } from '@/services/archive-service';\nimport { PreviewService } from '@/services/preview-service';\nimport { StorageService } from '@/services/storage-service';\nimport { createTestArchive, createMockFile } from '../../utils/test-helpers';\n\n// Mock services\nvi.mock('@/services/archive-service');\nvi.mock('@/services/preview-service');\nvi.mock('@/services/storage-service');\n\ndescribe('Archive Extraction Workflow Integration', () => {\n  let mockArchiveService: any;\n  let mockPreviewService: any;\n  let mockStorageService: any;\n\n  beforeEach(() => {\n    mockArchiveService = vi.mocked(ArchiveService);\n    mockPreviewService = vi.mocked(PreviewService);\n    mockStorageService = vi.mocked(StorageService);\n\n    // Reset mocks\n    vi.clearAllMocks();\n  });\n\n  afterEach(() => {\n    vi.restoreAllMocks();\n  });\n\n  describe('完整解压流程', () => {\n    it('应该完成从上传到预览的完整流程', async () => {\n      // 准备测试数据\n      const mockArchiveData = {\n        id: 'archive-1',\n        name: 'test.zip',\n        format: 'zip',\n        size: 1024,\n        structure: [\n          {\n            name: 'readme.txt',\n            type: 'file',\n            size: 100,\n            path: 'readme.txt',\n            mimeType: 'text/plain'\n          },\n          {\n            name: 'images',\n            type: 'directory',\n            size: 0,\n            path: 'images/',\n            children: [\n              {\n                name: 'photo.jpg',\n                type: 'file',\n                size: 50000,\n                path: 'images/photo.jpg',\n                mimeType: 'image/jpeg'\n              }\n            ]\n          }\n        ]\n      };\n\n      // Mock服务返回\n      mockArchiveService.prototype.loadArchive.mockResolvedValue(mockArchiveData);\n      mockArchiveService.prototype.extractFile.mockResolvedValue(\n        new TextEncoder().encode('Hello World')\n      );\n      mockPreviewService.prototype.preview.mockResolvedValue({\n        type: 'text',\n        content: 'Hello World'\n      });\n      mockStorageService.prototype.store.mockResolvedValue('storage-id');\n\n      // 渲染组件\n      render(<ArchiveViewer />);\n\n      // 1. 上传文件\n      const fileInput = screen.getByTestId('file-input');\n      const zipFile = createMockFile('test.zip', 'application/zip', 1024);\n      \n      fireEvent.change(fileInput, { target: { files: [zipFile] } });\n\n      // 2. 等待解压完成\n      await waitFor(() => {\n        expect(screen.getByTestId('file-tree')).toBeInTheDocument();\n      }, { timeout: 5000 });\n\n      // 3. 验证文件树显示\n      expect(screen.getByText('readme.txt')).toBeInTheDocument();\n      expect(screen.getByText('images')).toBeInTheDocument();\n      expect(screen.getByText('photo.jpg')).toBeInTheDocument();\n\n      // 4. 点击文件进行预览\n      const readmeFile = screen.getByText('readme.txt');\n      fireEvent.click(readmeFile);\n\n      // 5. 等待预览加载\n      await waitFor(() => {\n        expect(screen.getByTestId('preview-content')).toBeInTheDocument();\n      });\n\n      // 6. 验证预览内容\n      expect(screen.getByText('Hello World')).toBeInTheDocument();\n\n      // 7. 验证服务调用\n      expect(mockArchiveService.prototype.loadArchive).toHaveBeenCalledWith(zipFile);\n      expect(mockArchiveService.prototype.extractFile).toHaveBeenCalledWith('readme.txt');\n      expect(mockPreviewService.prototype.preview).toHaveBeenCalled();\n      expect(mockStorageService.prototype.store).toHaveBeenCalled();\n    });\n\n    it('应该处理RAR文件的完整流程', async () => {\n      const mockRarData = {\n        id: 'archive-2',\n        name: 'test.rar',\n        format: 'rar',\n        size: 2048,\n        structure: [\n          {\n            name: 'document.pdf',\n            type: 'file',\n            size: 100000,\n            path: 'document.pdf',\n            mimeType: 'application/pdf'\n          }\n        ]\n      };\n\n      mockArchiveService.prototype.loadArchive.mockResolvedValue(mockRarData);\n      mockArchiveService.prototype.extractFile.mockResolvedValue(\n        new Uint8Array(1000) // Mock PDF data\n      );\n      mockPreviewService.prototype.preview.mockResolvedValue({\n        type: 'pdf',\n        content: 'data:application/pdf;base64,mock-pdf-data'\n      });\n\n      render(<ArchiveViewer />);\n\n      const fileInput = screen.getByTestId('file-input');\n      const rarFile = createMockFile('test.rar', 'application/x-rar-compressed', 2048);\n      \n      fireEvent.change(fileInput, { target: { files: [rarFile] } });\n\n      await waitFor(() => {\n        expect(screen.getByTestId('file-tree')).toBeInTheDocument();\n      });\n\n      expect(screen.getByText('document.pdf')).toBeInTheDocument();\n\n      const pdfFile = screen.getByText('document.pdf');\n      fireEvent.click(pdfFile);\n\n      await waitFor(() => {\n        expect(screen.getByTestId('pdf-preview')).toBeInTheDocument();\n      });\n\n      expect(mockArchiveService.prototype.loadArchive).toHaveBeenCalledWith(rarFile);\n    });\n\n    it('应该处理大文件的分步加载', async () => {\n      const largeMockData = {\n        id: 'large-archive',\n        name: 'large.zip',\n        format: 'zip',\n        size: 100 * 1024 * 1024, // 100MB\n        structure: Array.from({ length: 1000 }, (_, i) => ({\n          name: `file${i}.txt`,\n          type: 'file',\n          size: 1000,\n          path: `file${i}.txt`,\n          mimeType: 'text/plain'\n        }))\n      };\n\n      let loadProgress = 0;\n      mockArchiveService.prototype.loadArchive.mockImplementation(async (file) => {\n        // 模拟分步加载\n        return new Promise((resolve) => {\n          const interval = setInterval(() => {\n            loadProgress += 20;\n            // 模拟进度事件\n            if (loadProgress >= 100) {\n              clearInterval(interval);\n              resolve(largeMockData);\n            }\n          }, 100);\n        });\n      });\n\n      render(<ArchiveViewer />);\n\n      const fileInput = screen.getByTestId('file-input');\n      const largeFile = createMockFile('large.zip', 'application/zip', 100 * 1024 * 1024);\n      \n      fireEvent.change(fileInput, { target: { files: [largeFile] } });\n\n      // 验证加载状态\n      expect(screen.getByTestId('loading-spinner')).toBeInTheDocument();\n\n      // 等待加载完成\n      await waitFor(() => {\n        expect(screen.getByTestId('file-tree')).toBeInTheDocument();\n      }, { timeout: 10000 });\n\n      // 验证文件数量\n      const fileItems = screen.getAllByTestId('file-item');\n      expect(fileItems).toHaveLength(1000);\n    });\n  });\n\n  describe('错误处理集成', () => {\n    it('应该处理文件解压失败', async () => {\n      mockArchiveService.prototype.loadArchive.mockRejectedValue(\n        new Error('Archive is corrupted')\n      );\n\n      render(<ArchiveViewer />);\n\n      const fileInput = screen.getByTestId('file-input');\n      const corruptedFile = createMockFile('corrupted.zip', 'application/zip', 1024);\n      \n      fireEvent.change(fileInput, { target: { files: [corruptedFile] } });\n\n      await waitFor(() => {\n        expect(screen.getByTestId('error-message')).toBeInTheDocument();\n      });\n\n      expect(screen.getByText(/Archive is corrupted/)).toBeInTheDocument();\n      expect(screen.getByTestId('retry-button')).toBeInTheDocument();\n    });\n\n    it('应该处理预览失败并提供降级方案', async () => {\n      const mockArchiveData = {\n        id: 'archive-3',\n        name: 'test.zip',\n        format: 'zip',\n        structure: [\n          {\n            name: 'binary.exe',\n            type: 'file',\n            size: 1000,\n            path: 'binary.exe',\n            mimeType: 'application/octet-stream'\n          }\n        ]\n      };\n\n      mockArchiveService.prototype.loadArchive.mockResolvedValue(mockArchiveData);\n      mockArchiveService.prototype.extractFile.mockResolvedValue(\n        new Uint8Array([0x4D, 0x5A]) // PE header\n      );\n      mockPreviewService.prototype.preview.mockRejectedValue(\n        new Error('Cannot preview binary file')\n      );\n\n      render(<ArchiveViewer />);\n\n      const fileInput = screen.getByTestId('file-input');\n      const zipFile = createMockFile('test.zip', 'application/zip', 1024);\n      \n      fireEvent.change(fileInput, { target: { files: [zipFile] } });\n\n      await waitFor(() => {\n        expect(screen.getByText('binary.exe')).toBeInTheDocument();\n      });\n\n      const binaryFile = screen.getByText('binary.exe');\n      fireEvent.click(binaryFile);\n\n      await waitFor(() => {\n        expect(screen.getByTestId('binary-preview')).toBeInTheDocument();\n      });\n\n      // 应该显示十六进制预览\n      expect(screen.getByText(/4D 5A/)).toBeInTheDocument();\n      expect(screen.getByTestId('download-button')).toBeInTheDocument();\n    });\n\n    it('应该处理网络中断后的重试', async () => {\n      let attemptCount = 0;\n      mockArchiveService.prototype.loadArchive.mockImplementation(async () => {\n        attemptCount++;\n        if (attemptCount < 3) {\n          throw new Error('Network error');\n        }\n        return {\n          id: 'archive-retry',\n          name: 'test.zip',\n          format: 'zip',\n          structure: [{ name: 'file.txt', type: 'file', size: 100, path: 'file.txt' }]\n        };\n      });\n\n      render(<ArchiveViewer />);\n\n      const fileInput = screen.getByTestId('file-input');\n      const zipFile = createMockFile('test.zip', 'application/zip', 1024);\n      \n      fireEvent.change(fileInput, { target: { files: [zipFile] } });\n\n      // 第一次失败\n      await waitFor(() => {\n        expect(screen.getByText(/Network error/)).toBeInTheDocument();\n      });\n\n      // 点击重试\n      const retryButton = screen.getByTestId('retry-button');\n      fireEvent.click(retryButton);\n\n      // 第二次失败\n      await waitFor(() => {\n        expect(screen.getByText(/Network error/)).toBeInTheDocument();\n      });\n\n      // 再次重试\n      fireEvent.click(retryButton);\n\n      // 第三次成功\n      await waitFor(() => {\n        expect(screen.getByTestId('file-tree')).toBeInTheDocument();\n      });\n\n      expect(screen.getByText('file.txt')).toBeInTheDocument();\n      expect(attemptCount).toBe(3);\n    });\n  });\n\n  describe('性能优化集成', () => {\n    it('应该实现虚拟滚动处理大量文件', async () => {\n      const manyFilesMockData = {\n        id: 'many-files',\n        name: 'many-files.zip',\n        format: 'zip',\n        structure: Array.from({ length: 10000 }, (_, i) => ({\n          name: `file${i.toString().padStart(5, '0')}.txt`,\n          type: 'file',\n          size: 100,\n          path: `file${i.toString().padStart(5, '0')}.txt`,\n          mimeType: 'text/plain'\n        }))\n      };\n\n      mockArchiveService.prototype.loadArchive.mockResolvedValue(manyFilesMockData);\n\n      render(<ArchiveViewer />);\n\n      const fileInput = screen.getByTestId('file-input');\n      const zipFile = createMockFile('many-files.zip', 'application/zip', 1024);\n      \n      const startTime = performance.now();\n      \n      fireEvent.change(fileInput, { target: { files: [zipFile] } });\n\n      await waitFor(() => {\n        expect(screen.getByTestId('virtual-file-tree')).toBeInTheDocument();\n      });\n\n      const endTime = performance.now();\n      const renderTime = endTime - startTime;\n\n      // 虚拟滚动应该在合理时间内渲染\n      expect(renderTime).toBeLessThan(2000);\n\n      // 应该只渲染可视区域的文件\n      const visibleItems = screen.getAllByTestId('file-item');\n      expect(visibleItems.length).toBeLessThan(100); // 远少于10000个\n    });\n\n    it('应该实现预览内容的缓存', async () => {\n      const mockArchiveData = {\n        id: 'cache-test',\n        name: 'test.zip',\n        format: 'zip',\n        structure: [\n          {\n            name: 'cached.txt',\n            type: 'file',\n            size: 1000,\n            path: 'cached.txt',\n            mimeType: 'text/plain'\n          }\n        ]\n      };\n\n      mockArchiveService.prototype.loadArchive.mockResolvedValue(mockArchiveData);\n      mockArchiveService.prototype.extractFile.mockResolvedValue(\n        new TextEncoder().encode('Cached content')\n      );\n      mockPreviewService.prototype.preview.mockResolvedValue({\n        type: 'text',\n        content: 'Cached content'\n      });\n\n      render(<ArchiveViewer />);\n\n      const fileInput = screen.getByTestId('file-input');\n      const zipFile = createMockFile('test.zip', 'application/zip', 1024);\n      \n      fireEvent.change(fileInput, { target: { files: [zipFile] } });\n\n      await waitFor(() => {\n        expect(screen.getByText('cached.txt')).toBeInTheDocument();\n      });\n\n      // 第一次点击\n      const cachedFile = screen.getByText('cached.txt');\n      fireEvent.click(cachedFile);\n\n      await waitFor(() => {\n        expect(screen.getByText('Cached content')).toBeInTheDocument();\n      });\n\n      // 点击其他地方然后再回来\n      fireEvent.click(screen.getByTestId('file-tree'));\n      fireEvent.click(cachedFile);\n\n      // 第二次应该更快（使用缓存）\n      await waitFor(() => {\n        expect(screen.getByText('Cached content')).toBeInTheDocument();\n      });\n\n      // 预览服务应该只被调用一次（第二次使用缓存）\n      expect(mockPreviewService.prototype.preview).toHaveBeenCalledTimes(1);\n    });\n  });\n\n  describe('状态管理集成', () => {\n    it('应该正确管理多个压缩包的状态', async () => {\n      const archive1Data = {\n        id: 'archive-1',\n        name: 'first.zip',\n        format: 'zip',\n        structure: [{ name: 'file1.txt', type: 'file', size: 100, path: 'file1.txt' }]\n      };\n\n      const archive2Data = {\n        id: 'archive-2',\n        name: 'second.zip',\n        format: 'zip',\n        structure: [{ name: 'file2.txt', type: 'file', size: 200, path: 'file2.txt' }]\n      };\n\n      mockArchiveService.prototype.loadArchive\n        .mockResolvedValueOnce(archive1Data)\n        .mockResolvedValueOnce(archive2Data);\n\n      render(<ArchiveViewer />);\n\n      const fileInput = screen.getByTestId('file-input');\n\n      // 上传第一个文件\n      const firstZip = createMockFile('first.zip', 'application/zip', 1024);\n      fireEvent.change(fileInput, { target: { files: [firstZip] } });\n\n      await waitFor(() => {\n        expect(screen.getByText('file1.txt')).toBeInTheDocument();\n      });\n\n      // 上传第二个文件\n      const secondZip = createMockFile('second.zip', 'application/zip', 2048);\n      fireEvent.change(fileInput, { target: { files: [secondZip] } });\n\n      await waitFor(() => {\n        expect(screen.getByText('file2.txt')).toBeInTheDocument();\n      });\n\n      // 验证可以在两个压缩包之间切换\n      const archiveTabs = screen.getAllByTestId('archive-tab');\n      expect(archiveTabs).toHaveLength(2);\n\n      fireEvent.click(archiveTabs[0]);\n      expect(screen.getByText('file1.txt')).toBeInTheDocument();\n\n      fireEvent.click(archiveTabs[1]);\n      expect(screen.getByText('file2.txt')).toBeInTheDocument();\n    });\n\n    it('应该持久化用户偏好设置', async () => {\n      mockStorageService.prototype.getPreferences.mockResolvedValue({\n        theme: 'dark',\n        defaultPreviewMode: 'hex',\n        autoExtract: false\n      });\n\n      render(<ArchiveViewer />);\n\n      // 验证偏好设置被应用\n      const container = screen.getByTestId('archive-viewer');\n      expect(container).toHaveClass('dark-theme');\n\n      // 修改设置\n      const settingsButton = screen.getByTestId('settings-button');\n      fireEvent.click(settingsButton);\n\n      const themeToggle = screen.getByTestId('theme-toggle');\n      fireEvent.click(themeToggle);\n\n      // 验证设置被保存\n      await waitFor(() => {\n        expect(mockStorageService.prototype.savePreferences).toHaveBeenCalledWith({\n          theme: 'light',\n          defaultPreviewMode: 'hex',\n          autoExtract: false\n        });\n      });\n    });\n  });\n\n  describe('内存管理集成', () => {\n    it('应该在组件卸载时清理资源', async () => {\n      const mockArchiveData = {\n        id: 'cleanup-test',\n        name: 'test.zip',\n        format: 'zip',\n        structure: [{ name: 'file.txt', type: 'file', size: 100, path: 'file.txt' }]\n      };\n\n      mockArchiveService.prototype.loadArchive.mockResolvedValue(mockArchiveData);\n      mockArchiveService.prototype.destroy = vi.fn();\n\n      const { unmount } = render(<ArchiveViewer />);\n\n      const fileInput = screen.getByTestId('file-input');\n      const zipFile = createMockFile('test.zip', 'application/zip', 1024);\n      \n      fireEvent.change(fileInput, { target: { files: [zipFile] } });\n\n      await waitFor(() => {\n        expect(screen.getByText('file.txt')).toBeInTheDocument();\n      });\n\n      // 卸载组件\n      unmount();\n\n      // 验证资源被清理\n      expect(mockArchiveService.prototype.destroy).toHaveBeenCalled();\n    });\n\n    it('应该在内存压力下自动清理缓存', async () => {\n      const mockArchiveData = {\n        id: 'memory-test',\n        name: 'test.zip',\n        format: 'zip',\n        structure: [{ name: 'large.txt', type: 'file', size: 50 * 1024 * 1024, path: 'large.txt' }]\n      };\n\n      mockArchiveService.prototype.loadArchive.mockResolvedValue(mockArchiveData);\n      \n      // 模拟内存不足\n      const originalMemory = (performance as any).memory;\n      Object.defineProperty(performance, 'memory', {\n        value: {\n          usedJSHeapSize: 500 * 1024 * 1024, // 500MB used\n          totalJSHeapSize: 512 * 1024 * 1024, // 512MB total\n          jsHeapSizeLimit: 512 * 1024 * 1024\n        },\n        configurable: true\n      });\n\n      render(<ArchiveViewer />);\n\n      const fileInput = screen.getByTestId('file-input');\n      const zipFile = createMockFile('test.zip', 'application/zip', 1024);\n      \n      fireEvent.change(fileInput, { target: { files: [zipFile] } });\n\n      await waitFor(() => {\n        expect(screen.getByTestId('memory-warning')).toBeInTheDocument();\n      });\n\n      // 恢复原始memory对象\n      Object.defineProperty(performance, 'memory', { value: originalMemory });\n    });\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/tests/integration/zip-rar-integration.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'TestDataGenerator' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":40},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'file' is defined but never used. Allowed unused args must match /^_/u.","line":228,"column":63,"nodeType":null,"messageId":"unusedVar","endLine":228,"endColumn":67},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'file' is defined but never used. Allowed unused args must match /^_/u.","line":258,"column":63,"nodeType":null,"messageId":"unusedVar","endLine":258,"endColumn":67},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'file' is defined but never used. Allowed unused args must match /^_/u.","line":289,"column":63,"nodeType":null,"messageId":"unusedVar","endLine":289,"endColumn":67},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'options' is defined but never used. Allowed unused args must match /^_/u.","line":289,"column":69,"nodeType":null,"messageId":"unusedVar","endLine":289,"endColumn":76},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'lastError' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":315,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":315,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'file' is defined but never used. Allowed unused args must match /^_/u.","line":377,"column":65,"nodeType":null,"messageId":"unusedVar","endLine":377,"endColumn":69},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'i' is defined but never used. Allowed unused args must match /^_/u.","line":438,"column":56,"nodeType":null,"messageId":"unusedVar","endLine":438,"endColumn":57}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';\nimport { TestHelpers, TestDataGenerator } from '@tests/utils/test-helpers';\nimport { PerformanceHelpers } from '@tests/utils/performance-helpers';\n\n/**\n * ZIP和RAR格式集成测试\n * 测试真实场景下的格式处理和用户工作流\n */\ndescribe('ZIP/RAR 集成测试', () => {\n  let archiveService: any;\n  let fileUploadService: any;\n  let previewService: any;\n\n  beforeEach(() => {\n    // 模拟集成服务\n    archiveService = {\n      processArchive: vi.fn(),\n      extractAll: vi.fn(),\n      extractSelected: vi.fn(),\n      validateFormat: vi.fn()\n    };\n\n    fileUploadService = {\n      uploadFile: vi.fn(),\n      validateFile: vi.fn(),\n      getUploadProgress: vi.fn()\n    };\n\n    previewService = {\n      generatePreview: vi.fn(),\n      previewFile: vi.fn(),\n      getThumbnail: vi.fn()\n    };\n  });\n\n  afterEach(() => {\n    vi.clearAllMocks();\n  });\n\n  describe('用户完整工作流测试', () => {\n    it('应该完成ZIP文件的完整处理流程', async () => {\n      // 准备测试数据\n      const zipFile = TestHelpers.createMockArchiveFile('zip', 2 * 1024 * 1024); // 2MB\n      const mockFileStructure = [\n        { name: 'document.pdf', size: 500 * 1024, type: 'application/pdf' },\n        { name: 'image.jpg', size: 200 * 1024, type: 'image/jpeg' },\n        { name: 'text.txt', size: 10 * 1024, type: 'text/plain' },\n        { name: 'folder/', size: 0, isDirectory: true }\n      ];\n\n      // 1. 文件上传\n      fileUploadService.uploadFile.mockResolvedValue({\n        fileId: 'zip-123',\n        status: 'uploaded',\n        format: 'zip'\n      });\n\n      // 2. 格式验证\n      archiveService.validateFormat.mockResolvedValue({\n        isValid: true,\n        format: 'zip',\n        version: '2.0',\n        fileCount: 4\n      });\n\n      // 3. 文件结构解析\n      archiveService.processArchive.mockResolvedValue({\n        structure: mockFileStructure,\n        totalSize: 710 * 1024,\n        compressionRatio: 0.65\n      });\n\n      // 4. 预览生成\n      previewService.generatePreview.mockResolvedValue({\n        previews: [\n          { name: 'document.pdf', thumbnail: 'data:image/png;base64,...' },\n          { name: 'image.jpg', thumbnail: 'data:image/jpeg;base64,...' },\n          { name: 'text.txt', preview: 'Text file content preview...' }\n        ]\n      });\n\n      // 执行完整流程\n      const uploadResult = await fileUploadService.uploadFile(zipFile);\n      expect(uploadResult.format).toBe('zip');\n\n      const validationResult = await archiveService.validateFormat(zipFile);\n      expect(validationResult.isValid).toBe(true);\n\n      const processResult = await archiveService.processArchive(zipFile);\n      expect(processResult.structure).toHaveLength(4);\n\n      const previewResult = await previewService.generatePreview(processResult.structure);\n      expect(previewResult.previews).toHaveLength(3); // 不包括目录\n    });\n\n    it('应该完成RAR文件的完整处理流程', async () => {\n      // 准备RAR测试数据\n      const rarFile = TestHelpers.createMockArchiveFile('rar', 5 * 1024 * 1024); // 5MB\n      const mockRarStructure = [\n        { name: 'video.mp4', size: 4 * 1024 * 1024, type: 'video/mp4', isSolid: true },\n        { name: 'subtitle.srt', size: 50 * 1024, type: 'text/plain', isSolid: true },\n        { name: 'readme.txt', size: 5 * 1024, type: 'text/plain', isSolid: true }\n      ];\n\n      // RAR特定的处理流程\n      fileUploadService.uploadFile.mockResolvedValue({\n        fileId: 'rar-456',\n        status: 'uploaded',\n        format: 'rar'\n      });\n\n      archiveService.validateFormat.mockResolvedValue({\n        isValid: true,\n        format: 'rar',\n        version: '5.0',\n        isSolid: true,\n        hasRecoveryRecord: true\n      });\n\n      archiveService.processArchive.mockResolvedValue({\n        structure: mockRarStructure,\n        totalSize: 4 * 1024 * 1024 + 55 * 1024,\n        compressionRatio: 0.85,\n        solidCompression: true\n      });\n\n      // 执行RAR流程\n      const uploadResult = await fileUploadService.uploadFile(rarFile);\n      expect(uploadResult.format).toBe('rar');\n\n      const validationResult = await archiveService.validateFormat(rarFile);\n      expect(validationResult.isSolid).toBe(true);\n      expect(validationResult.hasRecoveryRecord).toBe(true);\n\n      const processResult = await archiveService.processArchive(rarFile);\n      expect(processResult.solidCompression).toBe(true);\n      expect(processResult.structure.every(file => file.isSolid)).toBe(true);\n    });\n  });\n\n  describe('密码保护文件处理', () => {\n    it('应该正确处理密码保护的ZIP文件', async () => {\n      const passwordZip = TestHelpers.createMockArchiveFile('zip', 1024 * 1024);\n      const correctPassword = 'test123!';\n\n      // 模拟密码检测\n      archiveService.validateFormat.mockResolvedValue({\n        isValid: true,\n        format: 'zip',\n        isPasswordProtected: true,\n        encryptedFileNames: false\n      });\n\n      // 模拟密码验证流程\n      archiveService.processArchive.mockImplementation(async (file, options) => {\n        if (options?.password === correctPassword) {\n          return {\n            structure: [\n              { name: 'secret.txt', size: 1024, isEncrypted: true }\n            ],\n            passwordVerified: true\n          };\n        }\n        throw new Error('Wrong password');\n      });\n\n      // 错误密码测试\n      await expect(\n        archiveService.processArchive(passwordZip, { password: 'wrong' })\n      ).rejects.toThrow('Wrong password');\n\n      // 正确密码测试\n      const result = await archiveService.processArchive(passwordZip, { \n        password: correctPassword \n      });\n      expect(result.passwordVerified).toBe(true);\n      expect(result.structure[0].isEncrypted).toBe(true);\n    });\n\n    it('应该正确处理RAR文件名加密', async () => {\n      const encryptedRar = TestHelpers.createMockArchiveFile('rar', 2 * 1024 * 1024);\n      const password = 'secure456';\n\n      archiveService.validateFormat.mockResolvedValue({\n        isValid: true,\n        format: 'rar',\n        isPasswordProtected: true,\n        encryptedFileNames: true // RAR特有功能\n      });\n\n      archiveService.processArchive.mockImplementation(async (file, options) => {\n        if (options?.password === password) {\n          return {\n            structure: [\n              { name: 'confidential.doc', size: 500 * 1024, isEncrypted: true },\n              { name: 'private/', size: 0, isDirectory: true, isEncrypted: true }\n            ],\n            fileNamesDecrypted: true\n          };\n        }\n        // 文件名加密时无法获取文件列表\n        return {\n          structure: [],\n          fileNamesEncrypted: true,\n          needsPassword: true\n        };\n      });\n\n      // 没有密码时无法获取文件列表\n      const noPasswordResult = await archiveService.processArchive(encryptedRar);\n      expect(noPasswordResult.fileNamesEncrypted).toBe(true);\n      expect(noPasswordResult.structure).toHaveLength(0);\n\n      // 有密码时可以获取完整结构\n      const withPasswordResult = await archiveService.processArchive(encryptedRar, { \n        password \n      });\n      expect(withPasswordResult.fileNamesDecrypted).toBe(true);\n      expect(withPasswordResult.structure).toHaveLength(2);\n    });\n  });\n\n  describe('大文件处理性能测试', () => {\n    it('应该高效处理大型ZIP文件', async () => {\n      const largeZip = TestHelpers.createMockArchiveFile('zip', 100 * 1024 * 1024); // 100MB\n      \n      // 模拟大文件处理\n      archiveService.processArchive.mockImplementation(async (file) => {\n        // 模拟处理时间\n        await TestHelpers.waitForAsync(500);\n        \n        return {\n          structure: Array.from({ length: 1000 }, (_, i) => ({\n            name: `file-${i}.txt`,\n            size: 100 * 1024, // 100KB each\n            path: `folder-${Math.floor(i / 100)}/file-${i}.txt`\n          })),\n          totalSize: 100 * 1024 * 1024,\n          processingTime: 500\n        };\n      });\n\n      const performanceTest = PerformanceHelpers.expectPerformance(\n        () => archiveService.processArchive(largeZip),\n        {\n          maxDuration: 2000, // 2秒内完成\n          maxMemory: 50 * 1024 * 1024 // 最多使用50MB内存\n        }\n      );\n\n      const result = await performanceTest();\n      expect(result.duration).toBeLessThan(2000);\n    });\n\n    it('应该高效处理RAR固实压缩', async () => {\n      const solidRar = TestHelpers.createMockArchiveFile('rar', 200 * 1024 * 1024); // 200MB\n      \n      archiveService.processArchive.mockImplementation(async (file) => {\n        // 固实压缩需要按顺序处理，模拟较长处理时间\n        await TestHelpers.waitForAsync(1000);\n        \n        return {\n          structure: Array.from({ length: 500 }, (_, i) => ({\n            name: `solid-file-${i}.bin`,\n            size: 400 * 1024, // 400KB each\n            isSolid: true,\n            solidGroup: 1\n          })),\n          isSolidArchive: true,\n          processingTime: 1000\n        };\n      });\n\n      const startTime = performance.now();\n      const result = await archiveService.processArchive(solidRar);\n      const duration = performance.now() - startTime;\n\n      expect(result.isSolidArchive).toBe(true);\n      expect(result.structure.every(file => file.isSolid)).toBe(true);\n      expect(duration).toBeLessThan(3000); // 固实压缩允许较长时间\n    });\n  });\n\n  describe('错误恢复和重试机制', () => {\n    it('应该支持ZIP文件的错误恢复', async () => {\n      const corruptedZip = TestHelpers.createMockArchiveFile('zip', 1024 * 1024);\n      let attemptCount = 0;\n\n      archiveService.processArchive.mockImplementation(async (file, options) => {\n        attemptCount++;\n        \n        if (attemptCount <= 2) {\n          throw new Error('CRC error in central directory');\n        }\n        \n        // 第三次尝试成功\n        return {\n          structure: [\n            { name: 'recovered.txt', size: 1024, isPartiallyRecovered: true }\n          ],\n          recoveryAttempts: attemptCount,\n          partialRecovery: true\n        };\n      });\n\n      // 实现重试逻辑\n      let lastError;\n      let result;\n      \n      for (let i = 0; i < 3; i++) {\n        try {\n          result = await archiveService.processArchive(corruptedZip);\n          break;\n        } catch (error) {\n          lastError = error;\n          await TestHelpers.waitForAsync(100); // 重试延迟\n        }\n      }\n\n      expect(result).toBeDefined();\n      expect(result.partialRecovery).toBe(true);\n      expect(result.recoveryAttempts).toBe(3);\n    });\n\n    it('应该支持RAR恢复记录功能', async () => {\n      const damagedRar = TestHelpers.createMockArchiveFile('rar', 2 * 1024 * 1024);\n\n      archiveService.validateFormat.mockResolvedValue({\n        isValid: false,\n        format: 'rar',\n        hasRecoveryRecord: true,\n        isDamaged: true\n      });\n\n      archiveService.processArchive.mockImplementation(async (file, options) => {\n        if (options?.useRecoveryRecord) {\n          return {\n            structure: [\n              { name: 'recovered-file.txt', size: 1024, isRecovered: true }\n            ],\n            usedRecoveryRecord: true,\n            recoverySuccess: true\n          };\n        }\n        throw new Error('Archive is damaged');\n      });\n\n      // 普通处理失败\n      await expect(\n        archiveService.processArchive(damagedRar)\n      ).rejects.toThrow('Archive is damaged');\n\n      // 使用恢复记录成功\n      const result = await archiveService.processArchive(damagedRar, { \n        useRecoveryRecord: true \n      });\n      \n      expect(result.usedRecoveryRecord).toBe(true);\n      expect(result.recoverySuccess).toBe(true);\n      expect(result.structure[0].isRecovered).toBe(true);\n    });\n  });\n\n  describe('多格式同时处理', () => {\n    it('应该能同时处理多个不同格式的文件', async () => {\n      const files = [\n        TestHelpers.createMockArchiveFile('zip', 1024 * 1024),\n        TestHelpers.createMockArchiveFile('rar', 2 * 1024 * 1024),\n        TestHelpers.createMockArchiveFile('zip', 512 * 1024)\n      ];\n\n      const processResults = [];\n\n      for (const [index, file] of files.entries()) {\n        const format = file.name.includes('zip') ? 'zip' : 'rar';\n        \n        archiveService.processArchive.mockImplementation(async (file) => {\n          await TestHelpers.waitForAsync(100 + index * 50); // 模拟不同处理时间\n          \n          return {\n            fileId: `file-${index}`,\n            format,\n            structure: [\n              { name: `${format}-file-${index}.txt`, size: 1024 }\n            ],\n            processingOrder: index\n          };\n        });\n\n        const result = await archiveService.processArchive(file);\n        processResults.push(result);\n      }\n\n      expect(processResults).toHaveLength(3);\n      expect(processResults[0].format).toBe('zip');\n      expect(processResults[1].format).toBe('rar');\n      expect(processResults[2].format).toBe('zip');\n    });\n\n    it('应该支持批量文件的并行处理', async () => {\n      const batchFiles = Array.from({ length: 5 }, (_, i) => \n        TestHelpers.createMockArchiveFile(i % 2 === 0 ? 'zip' : 'rar', 1024 * 1024)\n      );\n\n      archiveService.processArchive.mockImplementation(async (file, options) => {\n        const format = file.name.includes('zip') ? 'zip' : 'rar';\n        await TestHelpers.waitForAsync(200); // 每个文件200ms处理时间\n        \n        return {\n          format,\n          processedAt: Date.now(),\n          batchId: options?.batchId\n        };\n      });\n\n      // 并行处理\n      const startTime = Date.now();\n      const promises = batchFiles.map((file, index) => \n        archiveService.processArchive(file, { batchId: `batch-${index}` })\n      );\n      \n      const results = await Promise.all(promises);\n      const totalTime = Date.now() - startTime;\n\n      expect(results).toHaveLength(5);\n      expect(totalTime).toBeLessThan(500); // 并行处理应该远快于顺序处理 (5 * 200ms)\n      \n      // 验证不同格式都被正确处理\n      const zipCount = results.filter(r => r.format === 'zip').length;\n      const rarCount = results.filter(r => r.format === 'rar').length;\n      expect(zipCount).toBe(3); // 索引 0, 2, 4\n      expect(rarCount).toBe(2); // 索引 1, 3\n    });\n  });\n\n  describe('内存管理和清理', () => {\n    it('应该在处理完成后正确清理内存', async () => {\n      const largeFiles = Array.from({ length: 3 }, (_, i) => \n        TestHelpers.createMockArchiveFile('zip', 50 * 1024 * 1024) // 50MB each\n      );\n\n      const initialMemory = performance.memory?.usedJSHeapSize || 0;\n      \n      for (const file of largeFiles) {\n        archiveService.processArchive.mockImplementation(async () => {\n          // 模拟内存使用\n          const tempBuffer = new ArrayBuffer(20 * 1024 * 1024); // 临时使用20MB\n          \n          return {\n            structure: [{ name: 'test.txt', size: 1024 }],\n            tempBuffer // 这会被清理\n          };\n        });\n\n        const result = await archiveService.processArchive(file);\n        \n        // 模拟清理逻辑\n        delete result.tempBuffer;\n        \n        // 强制垃圾回收 (测试环境)\n        if (global.gc) {\n          global.gc();\n        }\n      }\n\n      await TestHelpers.waitForAsync(100); // 等待异步清理完成\n      \n      const finalMemory = performance.memory?.usedJSHeapSize || 0;\n      const memoryIncrease = finalMemory - initialMemory;\n      \n      // 内存增长应该很小，说明清理有效\n      expect(memoryIncrease).toBeLessThan(10 * 1024 * 1024); // 小于10MB\n    });\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/tests/setup.ts","messages":[{"ruleId":"@typescript-eslint/no-namespace","severity":2,"message":"ES2015 module syntax is preferred over namespaces.","line":10,"column":3,"nodeType":"TSModuleDeclaration","messageId":"moduleSyntaxIsPreferred","endLine":15,"endColumn":4},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":31,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":31,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[630,633],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[630,633],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":37,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":37,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[774,777],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[774,777],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":37,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":37,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[804,807],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[804,807],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":69,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":69,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1698,1701],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1698,1701],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":73,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":73,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1795,1798],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1795,1798],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":73,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":73,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1816,1819],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1816,1819],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":103,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":103,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2640,2643],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2640,2643],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":105,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":105,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2721,2724],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2721,2724],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":106,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":106,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2746,2749],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2746,2749],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":108,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":108,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2788,2791],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2788,2791],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":109,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":109,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2841,2844],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2841,2844],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":110,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":110,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2898,2901],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2898,2901],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":111,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":111,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2953,2956],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2953,2956],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":112,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":112,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3009,3012],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3009,3012],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":113,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":113,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3062,3065],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3062,3065],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'file' is defined but never used. Allowed unused args must match /^_/u.","line":115,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":115,"endColumn":22},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":115,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":115,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3121,3124],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3121,3124],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'file' is defined but never used. Allowed unused args must match /^_/u.","line":123,"column":25,"nodeType":null,"messageId":"unusedVar","endLine":123,"endColumn":29},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":123,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":123,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3334,3337],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3334,3337],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'file' is defined but never used. Allowed unused args must match /^_/u.","line":131,"column":21,"nodeType":null,"messageId":"unusedVar","endLine":131,"endColumn":25},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":131,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":131,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3542,3545],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3542,3545],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":148,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":148,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3965,3968],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3965,3968],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":156,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":156,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4155,4158],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4155,4158],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":157,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":157,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4210,4213],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4210,4213],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":158,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":158,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4263,4266],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4263,4266],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'scriptURL' is defined but never used. Allowed unused args must match /^_/u.","line":160,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":160,"endColumn":28},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'data' is defined but never used. Allowed unused args must match /^_/u.","line":166,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":166,"endColumn":23},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":166,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":166,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4476,4479],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4476,4479],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":180,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":180,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4811,4814],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4811,4814],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":185,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":185,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4934,4937],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4934,4937],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":186,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":186,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4979,4982],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4979,4982],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":198,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":198,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5310,5313],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5310,5313],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":212,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":212,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5689,5692],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5689,5692],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'callback' is defined but never used. Allowed unused args must match /^_/u.","line":213,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":213,"endColumn":27},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":213,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":213,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5762,5765],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5762,5765],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":222,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":222,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5948,5951],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5948,5951],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'callback' is defined but never used. Allowed unused args must match /^_/u.","line":223,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":223,"endColumn":27},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":223,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":223,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6033,6036],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6033,6036],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'options' is defined but never used. Allowed unused args must match /^_/u.","line":223,"column":34,"nodeType":null,"messageId":"unusedVar","endLine":223,"endColumn":41},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":223,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":223,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6048,6051],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6048,6051],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":232,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":232,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6226,6229],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6226,6229],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'callback' is defined but never used. Allowed unused args must match /^_/u.","line":233,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":233,"endColumn":27},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":233,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":233,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6303,6306],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6303,6306],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":242,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":242,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6485,6488],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6485,6488],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":257,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":257,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6889,6892],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6889,6892],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":291,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":291,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7904,7907],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7904,7907],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":296,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":296,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8039,8042],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8039,8042],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":301,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":301,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8169,8172],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8169,8172],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":329,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":329,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8752,8755],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8752,8755],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":366,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":366,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9529,9532],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9529,9532],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":367,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":367,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9560,9563],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9560,9563],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":368,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":368,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9591,9594],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9591,9594],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":369,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":369,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9628,9631],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9628,9631],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":383,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":383,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9932,9935],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9932,9935],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":417,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":417,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10800,10803],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10800,10803],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":435,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":435,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11352,11355],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11352,11355],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":10,"fatalErrorCount":0,"warningCount":47,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import '@testing-library/jest-dom';\nimport { vi, beforeAll, afterAll, beforeEach, afterEach } from 'vitest';\n\n// 扩展全局对象\ndeclare global {\n  interface Window {\n    __TEST__: boolean;\n  }\n  \n  namespace NodeJS {\n    interface Global {\n      TextEncoder: typeof TextEncoder;\n      TextDecoder: typeof TextDecoder;\n    }\n  }\n}\n\n// 设置测试环境标识\nwindow.__TEST__ = true;\n\n// 模拟浏览器API\nbeforeAll(() => {\n  // 模拟 TextEncoder/TextDecoder\n  if (typeof global.TextEncoder === 'undefined') {\n    global.TextEncoder = TextEncoder;\n    global.TextDecoder = TextDecoder;\n  }\n\n  // 模拟 File API\n  if (typeof window.File === 'undefined') {\n    (global as any).File = class File {\n      name: string;\n      size: number;\n      type: string;\n      lastModified: number;\n      \n      constructor(bits: any[], name: string, options: any = {}) {\n        this.name = name;\n        this.type = options.type || '';\n        this.lastModified = options.lastModified || Date.now();\n        this.size = bits.reduce((size, bit) => {\n          if (typeof bit === 'string') {return size + bit.length;}\n          if (bit instanceof ArrayBuffer) {return size + bit.byteLength;}\n          if (ArrayBuffer.isView(bit)) {return size + bit.byteLength;}\n          return size;\n        }, 0);\n      }\n      \n      slice(start?: number, end?: number, contentType?: string) {\n        return new Blob([], { type: contentType });\n      }\n      \n      stream() {\n        return new ReadableStream();\n      }\n      \n      text() {\n        return Promise.resolve('');\n      }\n      \n      arrayBuffer() {\n        return Promise.resolve(new ArrayBuffer(0));\n      }\n    };\n  }\n\n  // 模拟 Blob API\n  if (typeof window.Blob === 'undefined') {\n    (global as any).Blob = class Blob {\n      size: number;\n      type: string;\n      \n      constructor(parts: any[] = [], options: any = {}) {\n        this.type = options.type || '';\n        this.size = parts.reduce((size, part) => {\n          if (typeof part === 'string') {return size + part.length;}\n          if (part instanceof ArrayBuffer) {return size + part.byteLength;}\n          if (ArrayBuffer.isView(part)) {return size + part.byteLength;}\n          return size;\n        }, 0);\n      }\n      \n      slice(start?: number, end?: number, contentType?: string) {\n        return new Blob([], { type: contentType });\n      }\n      \n      stream() {\n        return new ReadableStream();\n      }\n      \n      text() {\n        return Promise.resolve('');\n      }\n      \n      arrayBuffer() {\n        return Promise.resolve(new ArrayBuffer(0));\n      }\n    };\n  }\n\n  // 模拟 FileReader API\n  if (typeof window.FileReader === 'undefined') {\n    (global as any).FileReader = class FileReader {\n      readyState: number = 0;\n      result: any = null;\n      error: any = null;\n      \n      onload: ((event: any) => void) | null = null;\n      onerror: ((event: any) => void) | null = null;\n      onloadstart: ((event: any) => void) | null = null;\n      onloadend: ((event: any) => void) | null = null;\n      onprogress: ((event: any) => void) | null = null;\n      onabort: ((event: any) => void) | null = null;\n      \n      readAsText(file: any) {\n        setTimeout(() => {\n          this.result = 'mock file content';\n          this.readyState = 2;\n          this.onload?.({ target: this });\n        }, 0);\n      }\n      \n      readAsArrayBuffer(file: any) {\n        setTimeout(() => {\n          this.result = new ArrayBuffer(0);\n          this.readyState = 2;\n          this.onload?.({ target: this });\n        }, 0);\n      }\n      \n      readAsDataURL(file: any) {\n        setTimeout(() => {\n          this.result = 'data:text/plain;base64,';\n          this.readyState = 2;\n          this.onload?.({ target: this });\n        }, 0);\n      }\n      \n      abort() {\n        this.readyState = 2;\n        this.onabort?.({ target: this });\n      }\n    };\n  }\n\n  // 模拟 URL API\n  if (typeof window.URL === 'undefined' || typeof window.URL.createObjectURL === 'undefined') {\n    (global as any).URL = {\n      createObjectURL: vi.fn(() => 'blob:mock-url'),\n      revokeObjectURL: vi.fn()\n    };\n  }\n\n  // 模拟 Web Workers\n  if (typeof window.Worker === 'undefined') {\n    (global as any).Worker = class Worker {\n      onmessage: ((event: any) => void) | null = null;\n      onerror: ((event: any) => void) | null = null;\n      \n      constructor(scriptURL: string) {\n        setTimeout(() => {\n          this.onmessage?.({ data: { type: 'ready' } });\n        }, 0);\n      }\n      \n      postMessage(data: any) {\n        setTimeout(() => {\n          this.onmessage?.({ data: { type: 'response', result: 'mock result' } });\n        }, 10);\n      }\n      \n      terminate() {\n        // Mock implementation\n      }\n    };\n  }\n\n  // 模拟 SharedArrayBuffer (用于WebAssembly测试)\n  if (typeof window.SharedArrayBuffer === 'undefined') {\n    (global as any).SharedArrayBuffer = ArrayBuffer;\n  }\n\n  // 模拟 crypto API\n  if (typeof window.crypto === 'undefined') {\n    (global as any).crypto = {\n      getRandomValues: (arr: any) => {\n        for (let i = 0; i < arr.length; i++) {\n          arr[i] = Math.floor(Math.random() * 256);\n        }\n        return arr;\n      },\n      randomUUID: () => `mock-uuid-${  Math.random().toString(36).substr(2, 9)}`\n    };\n  }\n\n  // 模拟 performance API\n  if (typeof window.performance === 'undefined') {\n    (global as any).performance = {\n      now: () => Date.now(),\n      memory: {\n        usedJSHeapSize: 10 * 1024 * 1024,\n        totalJSHeapSize: 50 * 1024 * 1024,\n        jsHeapSizeLimit: 2 * 1024 * 1024 * 1024\n      },\n      getEntriesByType: () => [],\n      getEntriesByName: () => []\n    };\n  }\n\n  // 模拟 ResizeObserver\n  if (typeof window.ResizeObserver === 'undefined') {\n    (global as any).ResizeObserver = class ResizeObserver {\n      constructor(callback: any) {}\n      observe() {}\n      unobserve() {}\n      disconnect() {}\n    };\n  }\n\n  // 模拟 IntersectionObserver\n  if (typeof window.IntersectionObserver === 'undefined') {\n    (global as any).IntersectionObserver = class IntersectionObserver {\n      constructor(callback: any, options?: any) {}\n      observe() {}\n      unobserve() {}\n      disconnect() {}\n    };\n  }\n\n  // 模拟 MutationObserver\n  if (typeof window.MutationObserver === 'undefined') {\n    (global as any).MutationObserver = class MutationObserver {\n      constructor(callback: any) {}\n      observe() {}\n      disconnect() {}\n      takeRecords() { return []; }\n    };\n  }\n\n  // 模拟 navigator API\n  if (typeof window.navigator === 'undefined') {\n    (global as any).navigator = {\n      userAgent: 'Mozilla/5.0 (Test Environment)',\n      language: 'zh-CN',\n      languages: ['zh-CN', 'en'],\n      onLine: true,\n      hardwareConcurrency: 4,\n      deviceMemory: 8,\n      storage: {\n        estimate: () => Promise.resolve({ quota: 1024 * 1024 * 1024, usage: 0 })\n      }\n    };\n  }\n\n  // 模拟 matchMedia\n  if (typeof window.matchMedia === 'undefined') {\n    (global as any).matchMedia = vi.fn((query: string) => ({\n      matches: false,\n      media: query,\n      onchange: null,\n      addListener: vi.fn(),\n      removeListener: vi.fn(),\n      addEventListener: vi.fn(),\n      removeEventListener: vi.fn(),\n      dispatchEvent: vi.fn()\n    }));\n  }\n\n  // 模拟 localStorage\n  if (typeof window.localStorage === 'undefined') {\n    const localStorageMock = {\n      store: {} as Record<string, string>,\n      getItem: vi.fn((key: string) => localStorageMock.store[key] || null),\n      setItem: vi.fn((key: string, value: string) => {\n        localStorageMock.store[key] = value;\n      }),\n      removeItem: vi.fn((key: string) => {\n        delete localStorageMock.store[key];\n      }),\n      clear: vi.fn(() => {\n        localStorageMock.store = {};\n      }),\n      get length() {\n        return Object.keys(localStorageMock.store).length;\n      },\n      key: vi.fn((index: number) => {\n        return Object.keys(localStorageMock.store)[index] || null;\n      })\n    };\n    \n    (global as any).localStorage = localStorageMock;\n  }\n\n  // 模拟 sessionStorage\n  if (typeof window.sessionStorage === 'undefined') {\n    (global as any).sessionStorage = global.localStorage;\n  }\n\n  // 模拟 IndexedDB\n  if (typeof window.indexedDB === 'undefined') {\n    (global as any).indexedDB = {\n      open: vi.fn(() => ({\n        onsuccess: null,\n        onerror: null,\n        result: {\n          createObjectStore: vi.fn(),\n          transaction: vi.fn(() => ({\n            objectStore: vi.fn(() => ({\n              add: vi.fn(),\n              get: vi.fn(),\n              put: vi.fn(),\n              delete: vi.fn(),\n              clear: vi.fn()\n            }))\n          }))\n        }\n      }))\n    };\n  }\n});\n\n// 每个测试前的设置\nbeforeEach(() => {\n  // 清理所有模拟\n  vi.clearAllMocks();\n  \n  // 重置localStorage\n  if (global.localStorage) {\n    (global.localStorage as any).store = {};\n  }\n  \n  // 重置performance.memory\n  if (global.performance && global.performance.memory) {\n    global.performance.memory.usedJSHeapSize = 10 * 1024 * 1024;\n  }\n  \n  // 清理控制台输出 (在测试中)\n  if (process.env.NODE_ENV === 'test') {\n    vi.spyOn(console, 'log').mockImplementation(() => {});\n    vi.spyOn(console, 'warn').mockImplementation(() => {});\n    vi.spyOn(console, 'error').mockImplementation(() => {});\n  }\n});\n\n// 每个测试后的清理\nafterEach(() => {\n  // 恢复所有模拟\n  vi.restoreAllMocks();\n  \n  // 清理DOM\n  document.body.innerHTML = '';\n  \n  // 清理全局状态\n  if (window.__TEST__) {\n    // 清理可能的事件监听器\n    window.removeEventListener = window.removeEventListener || (() => {});\n  }\n});\n\n// 全局清理\nafterAll(() => {\n  // 清理全局模拟\n  vi.clearAllMocks();\n  \n  // 重置全局对象\n  delete (global as any).File;\n  delete (global as any).Blob;\n  delete (global as any).FileReader;\n  delete (global as any).Worker;\n});\n\n// 错误处理\nprocess.on('unhandledRejection', (reason) => {\n  console.error('Unhandled Rejection:', reason);\n});\n\nprocess.on('uncaughtException', (error) => {\n  console.error('Uncaught Exception:', error);\n});\n\n// WebAssembly 模拟 (用于测试)\nif (typeof WebAssembly === 'undefined') {\n  (global as any).WebAssembly = {\n    compile: vi.fn(() => Promise.resolve({})),\n    instantiate: vi.fn(() => Promise.resolve({ \n      instance: { exports: {} },\n      module: {}\n    })),\n    validate: vi.fn(() => true),\n    Module: vi.fn(),\n    Instance: vi.fn(),\n    Memory: vi.fn(),\n    Table: vi.fn(),\n    CompileError: Error,\n    RuntimeError: Error,\n    LinkError: Error\n  };\n}\n\n// 自定义匹配器\nexpect.extend({\n  toBeWithinRange(received: number, floor: number, ceiling: number) {\n    const pass = received >= floor && received <= ceiling;\n    if (pass) {\n      return {\n        message: () => `expected ${received} not to be within range ${floor} - ${ceiling}`,\n        pass: true,\n      };\n    } else {\n      return {\n        message: () => `expected ${received} to be within range ${floor} - ${ceiling}`,\n        pass: false,\n      };\n    }\n  },\n  \n  toBeValidArchive(received: any) {\n    const pass = received && \n                 typeof received.id === 'string' &&\n                 typeof received.name === 'string' &&\n                 typeof received.format === 'string' &&\n                 Array.isArray(received.structure);\n    \n    return {\n      message: () => pass \n        ? `expected ${received} not to be a valid archive object`\n        : `expected ${received} to be a valid archive object with id, name, format, and structure`,\n      pass,\n    };\n  }\n});\n\n// 类型声明扩展\ndeclare module 'vitest' {\n  interface Assertion<T = any>\n    extends jest.Matchers<void, T> {\n    toBeWithinRange(floor: number, ceiling: number): T;\n    toBeValidArchive(): T;\n  }\n}\n\nexport {};","usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/tests/unit/components/FileUpload.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/tests/unit/formats/rar-format.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'TestDataGenerator' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":40},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'data' is defined but never used. Allowed unused args must match /^_/u.","line":57,"column":55,"nodeType":null,"messageId":"unusedVar","endLine":57,"endColumn":59},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'mockFile' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":144,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":144,"endColumn":23}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';\nimport { TestHelpers, TestDataGenerator } from '@tests/utils/test-helpers';\n\n/**\n * RAR格式专项测试\n * 覆盖RAR格式的各种特性和边界情况\n */\ndescribe('RAR格式处理', () => {\n  let mockRarService: any;\n  let testFile: File;\n\n  beforeEach(() => {\n    // 创建基础RAR测试文件\n    testFile = TestHelpers.createMockArchiveFile('rar', 2048);\n    \n    // 模拟RAR服务\n    mockRarService = {\n      detectFormat: vi.fn(),\n      extractFiles: vi.fn(),\n      getFileList: vi.fn(),\n      extractSingleFile: vi.fn(),\n      validateArchive: vi.fn(),\n      checkPassword: vi.fn(),\n      getRarVersion: vi.fn(),\n      checkRecoveryRecord: vi.fn()\n    };\n  });\n\n  afterEach(() => {\n    vi.clearAllMocks();\n  });\n\n  describe('RAR文件格式检测', () => {\n    it('应该正确识别RAR 4.x格式', () => {\n      const rar4Signature = new Uint8Array([\n        0x52, 0x61, 0x72, 0x21, 0x1a, 0x07, 0x00\n      ]);\n      const format = detectRarFormat(rar4Signature);\n      expect(format).toBe('rar4');\n    });\n\n    it('应该正确识别RAR 5.x格式', () => {\n      const rar5Signature = new Uint8Array([\n        0x52, 0x61, 0x72, 0x21, 0x1a, 0x07, 0x01, 0x00\n      ]);\n      const format = detectRarFormat(rar5Signature);\n      expect(format).toBe('rar5');\n    });\n\n    it('应该识别自解压RAR文件', () => {\n      // 自解压RAR文件以PE/ELF头开始，但包含RAR签名\n      const sfxSignature = new Uint8Array([\n        0x4d, 0x5a, 0x90, 0x00, // PE头开始\n        // ... 后面会有RAR签名\n      ]);\n      \n      mockRarService.detectFormat.mockImplementation((data) => {\n        // 模拟在文件中搜索RAR签名\n        const rarSignaturePosition = 1024; // 假设在1KB位置找到\n        return rarSignaturePosition > 0 ? 'rar-sfx' : 'unknown';\n      });\n\n      const format = mockRarService.detectFormat(sfxSignature);\n      expect(format).toBe('rar-sfx');\n    });\n\n    it('应该处理RAR分卷文件', () => {\n      const volumeExtensions = ['.part1.rar', '.part2.rar', '.r01', '.r02'];\n      \n      volumeExtensions.forEach(ext => {\n        const fileName = `archive${ext}`;\n        const isVolume = isRarVolume(fileName);\n        expect(isVolume).toBe(true);\n      });\n    });\n\n    it('应该拒绝损坏的RAR签名', () => {\n      const corruptedSignature = new Uint8Array([\n        0x52, 0x61, 0x72, 0xFF, 0xFF, 0xFF, 0xFF\n      ]);\n      const format = detectRarFormat(corruptedSignature);\n      expect(format).toBe('unknown');\n    });\n  });\n\n  describe('RAR版本兼容性', () => {\n    it('应该支持RAR 1.x格式', async () => {\n      mockRarService.getRarVersion.mockResolvedValue('1.5');\n      \n      const version = await mockRarService.getRarVersion(testFile);\n      expect(version).toBe('1.5');\n    });\n\n    it('应该支持RAR 2.x格式', async () => {\n      mockRarService.getRarVersion.mockResolvedValue('2.9');\n      \n      const version = await mockRarService.getRarVersion(testFile);\n      expect(version).toBe('2.9');\n    });\n\n    it('应该支持RAR 3.x格式', async () => {\n      mockRarService.getRarVersion.mockResolvedValue('3.93');\n      \n      const version = await mockRarService.getRarVersion(testFile);\n      expect(version).toBe('3.93');\n    });\n\n    it('应该支持RAR 4.x格式', async () => {\n      mockRarService.getRarVersion.mockResolvedValue('4.20');\n      \n      const version = await mockRarService.getRarVersion(testFile);\n      expect(version).toBe('4.20');\n    });\n\n    it('应该支持RAR 5.x格式', async () => {\n      mockRarService.getRarVersion.mockResolvedValue('5.91');\n      \n      const version = await mockRarService.getRarVersion(testFile);\n      expect(version).toBe('5.91');\n    });\n\n    it('应该处理未知RAR版本', async () => {\n      mockRarService.getRarVersion.mockRejectedValue(\n        new Error('Unknown RAR version')\n      );\n\n      await expect(mockRarService.getRarVersion(testFile))\n        .rejects.toThrow('Unknown RAR version');\n    });\n  });\n\n  describe('RAR压缩方法支持', () => {\n    const rarCompressionMethods = [\n      { id: 0x30, name: 'Store (不压缩)' },\n      { id: 0x31, name: 'Fastest' },\n      { id: 0x32, name: 'Fast' },\n      { id: 0x33, name: 'Normal' },\n      { id: 0x34, name: 'Good' },\n      { id: 0x35, name: 'Best' }\n    ];\n\n    rarCompressionMethods.forEach(method => {\n      it(`应该支持${method.name}压缩方法`, async () => {\n        const mockFile = {\n          name: 'test.txt',\n          compressionMethod: method.id,\n          size: 1024,\n          compressedSize: method.id === 0x30 ? 1024 : 512\n        };\n\n        mockRarService.extractSingleFile.mockResolvedValue({\n          content: new Uint8Array(1024),\n          compressionMethod: method.id\n        });\n\n        const result = await mockRarService.extractSingleFile('test.txt');\n        expect(result.compressionMethod).toBe(method.id);\n      });\n    });\n\n    it('应该支持RAR 5.x的新压缩算法', async () => {\n      const rar5Methods = [\n        { id: 0x40, name: 'RAR5 Normal' },\n        { id: 0x41, name: 'RAR5 Fast' },\n        { id: 0x42, name: 'RAR5 Best' }\n      ];\n\n      for (const method of rar5Methods) {\n        mockRarService.extractSingleFile.mockResolvedValue({\n          content: new Uint8Array(1024),\n          compressionMethod: method.id,\n          rarVersion: 5\n        });\n\n        const result = await mockRarService.extractSingleFile('test.txt');\n        expect(result.compressionMethod).toBe(method.id);\n        expect(result.rarVersion).toBe(5);\n      }\n    });\n  });\n\n  describe('RAR密码保护处理', () => {\n    it('应该检测密码保护的RAR文件', async () => {\n      mockRarService.checkPassword.mockResolvedValue(true);\n\n      const hasPassword = await mockRarService.checkPassword(testFile);\n      expect(hasPassword).toBe(true);\n    });\n\n    it('应该检测文件名加密', async () => {\n      mockRarService.checkPassword.mockResolvedValue({\n        hasPassword: true,\n        isHeaderEncrypted: true,\n        encryptionType: 'aes256'\n      });\n\n      const result = await mockRarService.checkPassword(testFile);\n      expect(result.isHeaderEncrypted).toBe(true);\n      expect(result.encryptionType).toBe('aes256');\n    });\n\n    it('应该使用正确密码解压文件', async () => {\n      const correctPassword = 'secret123';\n      const mockContent = new Uint8Array([82, 65, 82, 32, 84, 101, 115, 116]); // \"RAR Test\"\n\n      mockRarService.extractSingleFile.mockImplementation((filename, password) => {\n        if (password === correctPassword) {\n          return Promise.resolve({ content: mockContent });\n        }\n        return Promise.reject(new Error('Wrong password'));\n      });\n\n      const result = await mockRarService.extractSingleFile('test.txt', correctPassword);\n      expect(result.content).toEqual(mockContent);\n    });\n\n    it('应该支持不同的加密强度', async () => {\n      const encryptionLevels = [\n        { level: 128, name: 'AES-128' },\n        { level: 256, name: 'AES-256' }\n      ];\n\n      for (const encryption of encryptionLevels) {\n        mockRarService.extractSingleFile.mockResolvedValue({\n          content: new Uint8Array(100),\n          encryptionLevel: encryption.level\n        });\n\n        const result = await mockRarService.extractSingleFile('test.txt', 'password');\n        expect(result.encryptionLevel).toBe(encryption.level);\n      }\n    });\n\n    it('应该处理RAR5的密码验证', async () => {\n      // RAR5使用不同的密码验证机制\n      mockRarService.extractSingleFile.mockImplementation((filename, password) => {\n        // 模拟RAR5的PBKDF2密码验证\n        const isValidPassword = password && password.length >= 1;\n        if (isValidPassword) {\n          return Promise.resolve({\n            content: new Uint8Array(100),\n            rarVersion: 5,\n            passwordVerified: true\n          });\n        }\n        return Promise.reject(new Error('RAR5: Password verification failed'));\n      });\n\n      const result = await mockRarService.extractSingleFile('test.txt', 'validpass');\n      expect(result.rarVersion).toBe(5);\n      expect(result.passwordVerified).toBe(true);\n    });\n  });\n\n  describe('RAR分卷处理', () => {\n    it('应该检测分卷RAR文件', () => {\n      const volumeFiles = [\n        'archive.part1.rar',\n        'archive.part2.rar',\n        'archive.part3.rar'\n      ];\n\n      volumeFiles.forEach(filename => {\n        const isVolume = isRarVolume(filename);\n        expect(isVolume).toBe(true);\n      });\n    });\n\n    it('应该处理老式分卷命名', () => {\n      const oldVolumeFiles = [\n        'archive.rar',  // 第一卷\n        'archive.r00',  // 第二卷\n        'archive.r01',  // 第三卷\n        'archive.r02'   // 第四卷\n      ];\n\n      oldVolumeFiles.forEach(filename => {\n        const isVolume = isRarVolume(filename);\n        expect(isVolume).toBe(true);\n      });\n    });\n\n    it('应该按顺序处理分卷', async () => {\n      const volumes = [\n        'archive.part1.rar',\n        'archive.part2.rar',\n        'archive.part3.rar'\n      ];\n\n      mockRarService.extractFiles.mockImplementation((volumeList) => {\n        // 验证分卷顺序\n        const sortedVolumes = volumeList.sort();\n        expect(sortedVolumes).toEqual(volumes);\n        \n        return Promise.resolve([\n          { name: 'file1.txt', content: new Uint8Array(1000) },\n          { name: 'file2.txt', content: new Uint8Array(2000) }\n        ]);\n      });\n\n      const result = await mockRarService.extractFiles(volumes);\n      expect(result).toHaveLength(2);\n    });\n\n    it('应该处理缺失的分卷', async () => {\n      const incompleteVolumes = [\n        'archive.part1.rar',\n        // 缺少 part2\n        'archive.part3.rar'\n      ];\n\n      mockRarService.extractFiles.mockRejectedValue(\n        new Error('Missing volume: archive.part2.rar')\n      );\n\n      await expect(mockRarService.extractFiles(incompleteVolumes))\n        .rejects.toThrow('Missing volume: archive.part2.rar');\n    });\n  });\n\n  describe('RAR特殊功能', () => {\n    it('应该支持恢复记录', async () => {\n      mockRarService.checkRecoveryRecord.mockResolvedValue({\n        hasRecoveryRecord: true,\n        recoverySize: 1024,\n        canRecover: true\n      });\n\n      const recoveryInfo = await mockRarService.checkRecoveryRecord(testFile);\n      expect(recoveryInfo.hasRecoveryRecord).toBe(true);\n      expect(recoveryInfo.canRecover).toBe(true);\n    });\n\n    it('应该支持固实压缩检测', async () => {\n      mockRarService.getFileList.mockResolvedValue([\n        {\n          name: 'file1.txt',\n          isSolid: true,\n          solidGroup: 1\n        },\n        {\n          name: 'file2.txt',\n          isSolid: true,\n          solidGroup: 1\n        }\n      ]);\n\n      const files = await mockRarService.getFileList(testFile);\n      expect(files.every(file => file.isSolid)).toBe(true);\n      expect(files.every(file => file.solidGroup === 1)).toBe(true);\n    });\n\n    it('应该支持文件注释', async () => {\n      mockRarService.getFileList.mockResolvedValue([\n        {\n          name: 'document.txt',\n          comment: '这是一个重要文档',\n          hasComment: true\n        }\n      ]);\n\n      const files = await mockRarService.getFileList(testFile);\n      expect(files[0].hasComment).toBe(true);\n      expect(files[0].comment).toBe('这是一个重要文档');\n    });\n\n    it('应该支持压缩包注释', async () => {\n      mockRarService.validateArchive.mockResolvedValue({\n        isValid: true,\n        archiveComment: 'Created with ZhugeExtract Test Suite',\n        hasComment: true\n      });\n\n      const result = await mockRarService.validateArchive(testFile);\n      expect(result.hasComment).toBe(true);\n      expect(result.archiveComment).toBe('Created with ZhugeExtract Test Suite');\n    });\n\n    it('应该支持压缩字典大小检测', async () => {\n      const dictionarySizes = [64, 128, 256, 512, 1024, 2048, 4096];\n\n      for (const dictSize of dictionarySizes) {\n        mockRarService.getFileList.mockResolvedValue([\n          {\n            name: 'test.txt',\n            dictionarySize: dictSize * 1024 // KB to bytes\n          }\n        ]);\n\n        const files = await mockRarService.getFileList(testFile);\n        expect(files[0].dictionarySize).toBe(dictSize * 1024);\n      }\n    });\n  });\n\n  describe('RAR性能测试', () => {\n    it('应该高效处理大型RAR文件', async () => {\n      const largeFile = TestHelpers.createMockArchiveFile('rar', 500 * 1024 * 1024); // 500MB\n      const startTime = performance.now();\n\n      mockRarService.getFileList.mockImplementation(async () => {\n        // 模拟大文件处理时间\n        await new Promise(resolve => setTimeout(resolve, 200));\n        return Array.from({ length: 1000 }, (_, i) => ({\n          name: `file-${i}.txt`,\n          size: 500 * 1024 // 500KB each\n        }));\n      });\n\n      const result = await mockRarService.getFileList(largeFile);\n      const duration = performance.now() - startTime;\n\n      expect(result).toHaveLength(1000);\n      expect(duration).toBeLessThan(1000); // 应该在1秒内完成\n    });\n\n    it('应该优化固实压缩的解压顺序', async () => {\n      // 固实압缩需要按顺序解压\n      const solidFiles = Array.from({ length: 100 }, (_, i) => `file-${i}.txt`);\n      \n      mockRarService.extractFiles.mockImplementation(async (fileList) => {\n        // 模拟固실压缩的顺序处理\n        const extractedFiles = [];\n        for (let i = 0; i < fileList.length; i++) {\n          extractedFiles.push({\n            name: fileList[i],\n            content: new Uint8Array(1024),\n            extractionOrder: i\n          });\n        }\n        return extractedFiles;\n      });\n\n      const result = await mockRarService.extractFiles(solidFiles);\n      \n      // 验证解压顺序\n      for (let i = 0; i < result.length; i++) {\n        expect(result[i].extractionOrder).toBe(i);\n      }\n    });\n\n    it('应该控制内存使用量', async () => {\n      const initialMemory = performance.memory?.usedJSHeapSize || 0;\n\n      mockRarService.extractFiles.mockImplementation(async () => {\n        // 模拟内存控制机制\n        const maxMemoryPerFile = 10 * 1024 * 1024; // 10MB per file\n        return [\n          { name: 'large.txt', content: new Uint8Array(maxMemoryPerFile) }\n        ];\n      });\n\n      await mockRarService.extractFiles([testFile]);\n      \n      const finalMemory = performance.memory?.usedJSHeapSize || 0;\n      const memoryIncrease = finalMemory - initialMemory;\n      \n      // 内存增长应该可控\n      expect(memoryIncrease).toBeLessThan(50 * 1024 * 1024); // 小于50MB\n    });\n  });\n\n  describe('RAR错误处理', () => {\n    it('应该处理损坏的RAR头', async () => {\n      mockRarService.validateArchive.mockRejectedValue(\n        new Error('RAR header is corrupted')\n      );\n\n      await expect(mockRarService.validateArchive(testFile))\n        .rejects.toThrow('RAR header is corrupted');\n    });\n\n    it('应该处理CRC错误', async () => {\n      mockRarService.extractSingleFile.mockRejectedValue(\n        new Error('CRC error in file: test.txt')\n      );\n\n      await expect(mockRarService.extractSingleFile('test.txt'))\n        .rejects.toThrow('CRC error in file: test.txt');\n    });\n\n    it('应该处理不支持的RAR版本', async () => {\n      mockRarService.getRarVersion.mockRejectedValue(\n        new Error('Unsupported RAR version: 6.0')\n      );\n\n      await expect(mockRarService.getRarVersion(testFile))\n        .rejects.toThrow('Unsupported RAR version: 6.0');\n    });\n\n    it('应该处理分卷读取错误', async () => {\n      mockRarService.extractFiles.mockRejectedValue(\n        new Error('Cannot read volume 2 of 3')\n      );\n\n      await expect(mockRarService.extractFiles([testFile]))\n        .rejects.toThrow('Cannot read volume 2 of 3');\n    });\n\n    it('应该处理固实压缩中断', async () => {\n      mockRarService.extractFiles.mockRejectedValue(\n        new Error('Solid archive extraction interrupted')\n      );\n\n      await expect(mockRarService.extractFiles([testFile]))\n        .rejects.toThrow('Solid archive extraction interrupted');\n    });\n  });\n\n  describe('RAR兼容性测试', () => {\n    it('应该兼容WinRAR创建的文件', async () => {\n      mockRarService.validateArchive.mockResolvedValue({\n        isValid: true,\n        createdBy: 'WinRAR 6.11',\n        platform: 'Windows'\n      });\n\n      const result = await mockRarService.validateArchive(testFile);\n      expect(result.createdBy).toContain('WinRAR');\n      expect(result.platform).toBe('Windows');\n    });\n\n    it('应该兼容7-Zip创建的RAR文件', async () => {\n      mockRarService.validateArchive.mockResolvedValue({\n        isValid: true,\n        createdBy: '7-Zip 21.07',\n        platform: 'Multi-platform'\n      });\n\n      const result = await mockRarService.validateArchive(testFile);\n      expect(result.createdBy).toContain('7-Zip');\n    });\n\n    it('应该兼容命令行RAR创建的文件', async () => {\n      mockRarService.validateArchive.mockResolvedValue({\n        isValid: true,\n        createdBy: 'RAR 6.11 Command Line',\n        platform: 'Linux'\n      });\n\n      const result = await mockRarService.validateArchive(testFile);\n      expect(result.createdBy).toContain('Command Line');\n      expect(result.platform).toBe('Linux');\n    });\n\n    it('应该处理不同字符编码', async () => {\n      const encodingTests = [\n        { name: '测试文件.txt', encoding: 'utf-8' },\n        { name: 'тест.txt', encoding: 'utf-8' },\n        { name: 'テスト.txt', encoding: 'utf-8' },\n        { name: 'test.txt', encoding: 'cp1252' }\n      ];\n\n      for (const test of encodingTests) {\n        mockRarService.getFileList.mockResolvedValue([\n          {\n            name: test.name,\n            encoding: test.encoding,\n            isDirectory: false\n          }\n        ]);\n\n        const result = await mockRarService.getFileList(testFile);\n        expect(result[0].name).toBe(test.name);\n        expect(result[0].encoding).toBe(test.encoding);\n      }\n    });\n  });\n});\n\n// 辅助函数\nfunction detectRarFormat(signature: Uint8Array): string {\n  if (signature.length < 7) {return 'unknown';}\n  \n  // 检查RAR签名 \"Rar!\"\n  if (signature[0] === 0x52 && signature[1] === 0x61 && \n      signature[2] === 0x72 && signature[3] === 0x21) {\n    \n    // 检查版本标识\n    if (signature[6] === 0x00) {return 'rar4';}\n    if (signature[6] === 0x01 && signature[7] === 0x00) {return 'rar5';}\n  }\n  \n  return 'unknown';\n}\n\nfunction isRarVolume(filename: string): boolean {\n  const volumePatterns = [\n    /\\.part\\d+\\.rar$/i,  // archive.part1.rar\n    /\\.r\\d{2}$/i,        // archive.r01\n    /\\.rar$/i            // archive.rar (第一卷)\n  ];\n  \n  return volumePatterns.some(pattern => pattern.test(filename));\n}","usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/tests/unit/formats/zip-format.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'TestDataGenerator' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":40},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'mockFile' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":181,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":181,"endColumn":23}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';\nimport { TestHelpers, TestDataGenerator } from '@tests/utils/test-helpers';\n\n/**\n * ZIP格式专项测试\n * 覆盖ZIP格式的各种特性和边界情况\n */\ndescribe('ZIP格式处理', () => {\n  let mockZipService: any;\n  let testFile: File;\n\n  beforeEach(() => {\n    // 创建基础ZIP测试文件\n    testFile = TestHelpers.createMockArchiveFile('zip', 1024);\n    \n    // 模拟ZIP服务\n    mockZipService = {\n      detectFormat: vi.fn(),\n      extractFiles: vi.fn(),\n      getFileList: vi.fn(),\n      extractSingleFile: vi.fn(),\n      validateArchive: vi.fn(),\n      checkPassword: vi.fn()\n    };\n  });\n\n  afterEach(() => {\n    vi.clearAllMocks();\n  });\n\n  describe('ZIP文件格式检测', () => {\n    it('应该正确识别标准ZIP文件', () => {\n      const zipSignature = new Uint8Array([0x50, 0x4b, 0x03, 0x04]);\n      const format = detectZipFormat(zipSignature);\n      expect(format).toBe('zip');\n    });\n\n    it('应该识别空ZIP文件', () => {\n      const emptyZipSignature = new Uint8Array([0x50, 0x4b, 0x05, 0x06]);\n      const format = detectZipFormat(emptyZipSignature);\n      expect(format).toBe('zip');\n    });\n\n    it('应该识别跨卷ZIP文件', () => {\n      const multiVolumeSignature = new Uint8Array([0x50, 0x4b, 0x07, 0x08]);\n      const format = detectZipFormat(multiVolumeSignature);\n      expect(format).toBe('zip');\n    });\n\n    it('应该识别ZIP64格式', () => {\n      const zip64Signature = new Uint8Array([0x50, 0x4b, 0x06, 0x06]);\n      const format = detectZipFormat(zip64Signature);\n      expect(format).toBe('zip64');\n    });\n\n    it('应该拒绝损坏的ZIP签名', () => {\n      const corruptedSignature = new Uint8Array([0x50, 0x4b, 0xFF, 0xFF]);\n      const format = detectZipFormat(corruptedSignature);\n      expect(format).toBe('unknown');\n    });\n\n    it('应该处理文件太小的情况', () => {\n      const tooSmall = new Uint8Array([0x50]);\n      const format = detectZipFormat(tooSmall);\n      expect(format).toBe('unknown');\n    });\n  });\n\n  describe('ZIP文件结构解析', () => {\n    it('应该正确解析基本ZIP文件结构', async () => {\n      const mockStructure = [\n        {\n          name: 'document.txt',\n          path: 'document.txt',\n          size: 1024,\n          compressedSize: 512,\n          compressionMethod: 8, // deflate\n          crc32: 0x12345678,\n          lastModified: new Date('2024-01-01'),\n          isDirectory: false,\n          isEncrypted: false\n        },\n        {\n          name: 'images',\n          path: 'images/',\n          size: 0,\n          compressedSize: 0,\n          compressionMethod: 0,\n          crc32: 0,\n          lastModified: new Date('2024-01-01'),\n          isDirectory: true,\n          isEncrypted: false\n        }\n      ];\n\n      mockZipService.getFileList.mockResolvedValue(mockStructure);\n      const result = await mockZipService.getFileList(testFile);\n\n      expect(result).toHaveLength(2);\n      expect(result[0]).toMatchObject({\n        name: 'document.txt',\n        isDirectory: false,\n        compressionMethod: 8\n      });\n      expect(result[1]).toMatchObject({\n        name: 'images',\n        isDirectory: true\n      });\n    });\n\n    it('应该处理深层嵌套目录结构', async () => {\n      const mockNestedStructure = Array.from({ length: 100 }, (_, i) => ({\n        name: `file-${i}.txt`,\n        path: `level1/level2/level3/level4/file-${i}.txt`,\n        size: Math.random() * 10000,\n        isDirectory: false,\n        lastModified: new Date()\n      }));\n\n      mockZipService.getFileList.mockResolvedValue(mockNestedStructure);\n      const result = await mockZipService.getFileList(testFile);\n\n      expect(result).toHaveLength(100);\n      expect(result.every(item => item.path.split('/').length === 5)).toBe(true);\n    });\n\n    it('应该正确处理中文文件名', async () => {\n      const chineseFiles = [\n        {\n          name: '测试文档.txt',\n          path: '文件夹/测试文档.txt',\n          size: 1024,\n          isDirectory: false,\n          encoding: 'utf-8'\n        },\n        {\n          name: '图片文件夹',\n          path: '图片文件夹/',\n          size: 0,\n          isDirectory: true,\n          encoding: 'utf-8'\n        }\n      ];\n\n      mockZipService.getFileList.mockResolvedValue(chineseFiles);\n      const result = await mockZipService.getFileList(testFile);\n\n      expect(result[0].name).toBe('测试文档.txt');\n      expect(result[1].name).toBe('图片文件夹');\n    });\n\n    it('应该处理特殊字符文件名', async () => {\n      const specialCharFiles = [\n        { name: 'file with spaces.txt', isDirectory: false },\n        { name: 'file@#$%^&*().txt', isDirectory: false },\n        { name: 'file[brackets].txt', isDirectory: false },\n        { name: 'file{braces}.txt', isDirectory: false }\n      ];\n\n      mockZipService.getFileList.mockResolvedValue(specialCharFiles);\n      const result = await mockZipService.getFileList(testFile);\n\n      expect(result).toHaveLength(4);\n      expect(result.every(item => item.name.length > 0)).toBe(true);\n    });\n  });\n\n  describe('ZIP压缩方法支持', () => {\n    const compressionMethods = [\n      { id: 0, name: 'Store (不压缩)' },\n      { id: 8, name: 'Deflate' },\n      { id: 9, name: 'Deflate64' },\n      { id: 12, name: 'BZIP2' },\n      { id: 14, name: 'LZMA' },\n      { id: 95, name: 'XZ' },\n      { id: 98, name: 'PPMd' }\n    ];\n\n    compressionMethods.forEach(method => {\n      it(`应该支持${method.name}压缩方法`, async () => {\n        const mockFile = {\n          name: 'test.txt',\n          compressionMethod: method.id,\n          size: 1024,\n          compressedSize: method.id === 0 ? 1024 : 512\n        };\n\n        mockZipService.extractSingleFile.mockResolvedValue({\n          content: new Uint8Array(1024),\n          compressionMethod: method.id\n        });\n\n        const result = await mockZipService.extractSingleFile('test.txt');\n        expect(result.compressionMethod).toBe(method.id);\n      });\n    });\n\n    it('应该处理不支持的压缩方法', async () => {\n      const unsupportedMethod = 999;\n      mockZipService.extractSingleFile.mockRejectedValue(\n        new Error(`Unsupported compression method: ${unsupportedMethod}`)\n      );\n\n      await expect(mockZipService.extractSingleFile('test.txt'))\n        .rejects.toThrow('Unsupported compression method');\n    });\n  });\n\n  describe('ZIP密码保护处理', () => {\n    it('应该检测密码保护的ZIP文件', async () => {\n      const passwordProtectedFile = TestHelpers.createMockArchiveFile('zip', 2048);\n      mockZipService.checkPassword.mockResolvedValue(true);\n\n      const hasPassword = await mockZipService.checkPassword(passwordProtectedFile);\n      expect(hasPassword).toBe(true);\n    });\n\n    it('应该使用正确密码解压文件', async () => {\n      const correctPassword = 'test123';\n      const mockContent = new Uint8Array([72, 101, 108, 108, 111]); // \"Hello\"\n\n      mockZipService.extractSingleFile.mockImplementation((filename, password) => {\n        if (password === correctPassword) {\n          return Promise.resolve({ content: mockContent });\n        }\n        return Promise.reject(new Error('Wrong password'));\n      });\n\n      const result = await mockZipService.extractSingleFile('test.txt', correctPassword);\n      expect(result.content).toEqual(mockContent);\n    });\n\n    it('应该拒绝错误密码', async () => {\n      const wrongPassword = 'wrong123';\n\n      mockZipService.extractSingleFile.mockImplementation((filename, password) => {\n        if (password === 'correct123') {\n          return Promise.resolve({ content: new Uint8Array() });\n        }\n        return Promise.reject(new Error('Wrong password'));\n      });\n\n      await expect(mockZipService.extractSingleFile('test.txt', wrongPassword))\n        .rejects.toThrow('Wrong password');\n    });\n\n    it('应该处理空密码', async () => {\n      mockZipService.extractSingleFile.mockImplementation((filename, password) => {\n        if (password === '' || password === null || password === undefined) {\n          return Promise.reject(new Error('Password required'));\n        }\n        return Promise.resolve({ content: new Uint8Array() });\n      });\n\n      await expect(mockZipService.extractSingleFile('test.txt', ''))\n        .rejects.toThrow('Password required');\n      \n      await expect(mockZipService.extractSingleFile('test.txt', null))\n        .rejects.toThrow('Password required');\n    });\n\n    it('应该支持不同的加密方法', async () => {\n      const encryptionMethods = [\n        { id: 1, name: 'Traditional PKWARE' },\n        { id: 2, name: 'AES-128' },\n        { id: 3, name: 'AES-192' },\n        { id: 4, name: 'AES-256' }\n      ];\n\n      for (const method of encryptionMethods) {\n        mockZipService.extractSingleFile.mockResolvedValue({\n          content: new Uint8Array(100),\n          encryptionMethod: method.id\n        });\n\n        const result = await mockZipService.extractSingleFile('test.txt', 'password');\n        expect(result.encryptionMethod).toBe(method.id);\n      }\n    });\n  });\n\n  describe('ZIP文件大小处理', () => {\n    it('应该处理小文件 (< 1KB)', async () => {\n      const smallFile = TestHelpers.createMockArchiveFile('zip', 512);\n      mockZipService.validateArchive.mockResolvedValue(true);\n      \n      const isValid = await mockZipService.validateArchive(smallFile);\n      expect(isValid).toBe(true);\n    });\n\n    it('应该处理中等文件 (1MB - 100MB)', async () => {\n      const mediumFile = TestHelpers.createMockArchiveFile('zip', 50 * 1024 * 1024);\n      mockZipService.validateArchive.mockResolvedValue(true);\n      \n      const isValid = await mockZipService.validateArchive(mediumFile);\n      expect(isValid).toBe(true);\n    });\n\n    it('应该处理大文件 (> 100MB)', async () => {\n      const largeFile = TestHelpers.createMockArchiveFile('zip', 200 * 1024 * 1024);\n      \n      // 模拟分块处理\n      mockZipService.extractFiles.mockImplementation(async (file, options) => {\n        const chunkSize = options?.chunkSize || 1024 * 1024;\n        const totalChunks = Math.ceil(file.size / chunkSize);\n        \n        const results = [];\n        for (let i = 0; i < Math.min(totalChunks, 10); i++) {\n          results.push({\n            name: `chunk-${i}.txt`,\n            content: new Uint8Array(chunkSize)\n          });\n        }\n        \n        return results;\n      });\n\n      const result = await mockZipService.extractFiles(largeFile, { chunkSize: 1024 * 1024 });\n      expect(result).toHaveLength(10);\n    });\n\n    it('应该处理ZIP64格式的超大文件', async () => {\n      const zip64File = TestHelpers.createMockArchiveFile('zip', 5 * 1024 * 1024 * 1024); // 5GB模拟\n      \n      mockZipService.validateArchive.mockImplementation(async (file) => {\n        // 检查是否需要ZIP64\n        return file.size > 4 * 1024 * 1024 * 1024; // 4GB\n      });\n\n      const needsZip64 = await mockZipService.validateArchive(zip64File);\n      expect(needsZip64).toBe(true);\n    });\n  });\n\n  describe('ZIP性能测试', () => {\n    it('应该在合理时间内完成小文件解压', async () => {\n      const startTime = performance.now();\n      \n      mockZipService.extractFiles.mockImplementation(async () => {\n        await new Promise(resolve => setTimeout(resolve, 50)); // 模拟50ms处理时间\n        return [{ name: 'test.txt', content: new Uint8Array(1024) }];\n      });\n\n      await mockZipService.extractFiles(testFile);\n      \n      const duration = performance.now() - startTime;\n      expect(duration).toBeLessThan(200); // 应该在200ms内完成\n    });\n\n    it('应该高效处理大量小文件', async () => {\n      const fileCount = 1000;\n      const startTime = performance.now();\n\n      mockZipService.extractFiles.mockImplementation(async () => {\n        return Array.from({ length: fileCount }, (_, i) => ({\n          name: `file-${i}.txt`,\n          content: new Uint8Array(100)\n        }));\n      });\n\n      const result = await mockZipService.extractFiles(testFile);\n      const duration = performance.now() - startTime;\n\n      expect(result).toHaveLength(fileCount);\n      expect(duration).toBeLessThan(1000); // 1000个文件应该在1秒内处理完成\n    });\n\n    it('应该控制内存使用', async () => {\n      const initialMemory = TestHelpers.getMemoryUsage?.() || 0;\n\n      mockZipService.extractFiles.mockImplementation(async () => {\n        // 模拟内存使用\n        const tempBuffer = new ArrayBuffer(10 * 1024 * 1024); // 10MB\n        return [{ name: 'large.txt', content: new Uint8Array(tempBuffer) }];\n      });\n\n      await mockZipService.extractFiles(testFile);\n      \n      const finalMemory = TestHelpers.getMemoryUsage?.() || 0;\n      const memoryIncrease = finalMemory - initialMemory;\n      \n      // 内存增长应该合理 (小于20MB)\n      expect(memoryIncrease).toBeLessThan(20 * 1024 * 1024);\n    });\n  });\n\n  describe('ZIP错误处理', () => {\n    it('应该处理损坏的ZIP文件', async () => {\n      const corruptedFile = TestHelpers.createErrorScenarios().corruptedFile;\n      \n      mockZipService.validateArchive.mockRejectedValue(\n        new Error('Archive is corrupted or invalid')\n      );\n\n      await expect(mockZipService.validateArchive(corruptedFile))\n        .rejects.toThrow('Archive is corrupted or invalid');\n    });\n\n    it('应该处理截断的ZIP文件', async () => {\n      mockZipService.extractFiles.mockRejectedValue(\n        new Error('Unexpected end of archive')\n      );\n\n      await expect(mockZipService.extractFiles(testFile))\n        .rejects.toThrow('Unexpected end of archive');\n    });\n\n    it('应该处理CRC校验失败', async () => {\n      mockZipService.extractSingleFile.mockRejectedValue(\n        new Error('CRC check failed for file: test.txt')\n      );\n\n      await expect(mockZipService.extractSingleFile('test.txt'))\n        .rejects.toThrow('CRC check failed');\n    });\n\n    it('应该处理网络中断', async () => {\n      mockZipService.extractFiles.mockRejectedValue(\n        new Error('Network connection interrupted')\n      );\n\n      await expect(mockZipService.extractFiles(testFile))\n        .rejects.toThrow('Network connection interrupted');\n    });\n\n    it('应该优雅处理内存不足', async () => {\n      mockZipService.extractFiles.mockRejectedValue(\n        new Error('Out of memory')\n      );\n\n      await expect(mockZipService.extractFiles(testFile))\n        .rejects.toThrow('Out of memory');\n    });\n  });\n\n  describe('ZIP兼容性测试', () => {\n    it('应该兼容Windows创建的ZIP文件', async () => {\n      // 模拟Windows路径分隔符\n      const windowsFiles = [\n        { name: 'folder\\\\file.txt', path: 'folder\\\\file.txt', isDirectory: false },\n        { name: 'folder\\\\', path: 'folder\\\\', isDirectory: true }\n      ];\n\n      mockZipService.getFileList.mockResolvedValue(windowsFiles);\n      const result = await mockZipService.getFileList(testFile);\n\n      expect(result).toHaveLength(2);\n      expect(result[0].path).toContain('\\\\');\n    });\n\n    it('应该兼容macOS创建的ZIP文件', async () => {\n      // 模拟macOS特殊文件\n      const macFiles = [\n        { name: '.DS_Store', isDirectory: false, hidden: true },\n        { name: '__MACOSX/', isDirectory: true, hidden: true },\n        { name: 'normal-file.txt', isDirectory: false, hidden: false }\n      ];\n\n      mockZipService.getFileList.mockResolvedValue(macFiles);\n      const result = await mockZipService.getFileList(testFile);\n\n      expect(result).toHaveLength(3);\n      expect(result.some(file => file.name === '.DS_Store')).toBe(true);\n    });\n\n    it('应该兼容Linux创建的ZIP文件', async () => {\n      // 模拟Linux权限和符号链接\n      const linuxFiles = [\n        { \n          name: 'script.sh', \n          isDirectory: false, \n          permissions: 0o755,\n          isExecutable: true \n        },\n        { \n          name: 'link-to-file', \n          isDirectory: false, \n          isSymlink: true,\n          linkTarget: 'script.sh'\n        }\n      ];\n\n      mockZipService.getFileList.mockResolvedValue(linuxFiles);\n      const result = await mockZipService.getFileList(testFile);\n\n      expect(result).toHaveLength(2);\n      expect(result[0].isExecutable).toBe(true);\n      expect(result[1].isSymlink).toBe(true);\n    });\n  });\n});\n\n// 辅助函数\nfunction detectZipFormat(signature: Uint8Array): string {\n  if (signature.length < 4) {return 'unknown';}\n  \n  const first4 = Array.from(signature.slice(0, 4));\n  \n  // 标准ZIP签名\n  if (first4[0] === 0x50 && first4[1] === 0x4b) {\n    if (first4[2] === 0x03 && first4[3] === 0x04) {return 'zip';} // 本地文件头\n    if (first4[2] === 0x05 && first4[3] === 0x06) {return 'zip';} // 中央目录结束\n    if (first4[2] === 0x07 && first4[3] === 0x08) {return 'zip';} // 跨卷\n    if (first4[2] === 0x06 && first4[3] === 0x06) {return 'zip64';} // ZIP64\n  }\n  \n  return 'unknown';\n}","usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/tests/unit/services/archive-service.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/tests/unit/utils/file-utils.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'beforeEach' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":32,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":42}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, beforeEach, vi } from 'vitest';\nimport { FileUtils } from '@/utils/file-utils';\n\ndescribe('FileUtils', () => {\n  describe('文件大小格式化', () => {\n    const testCases = [\n      { bytes: 0, expected: '0 B' },\n      { bytes: 1023, expected: '1023 B' },\n      { bytes: 1024, expected: '1.0 KB' },\n      { bytes: 1536, expected: '1.5 KB' },\n      { bytes: 1024 * 1024, expected: '1.0 MB' },\n      { bytes: 1.5 * 1024 * 1024, expected: '1.5 MB' },\n      { bytes: 1024 * 1024 * 1024, expected: '1.0 GB' },\n      { bytes: 2.5 * 1024 * 1024 * 1024, expected: '2.5 GB' },\n      { bytes: 1024 * 1024 * 1024 * 1024, expected: '1.0 TB' },\n    ];\n\n    testCases.forEach(({ bytes, expected }) => {\n      it(`应该格式化 ${bytes} 字节为 ${expected}`, () => {\n        expect(FileUtils.formatFileSize(bytes)).toBe(expected);\n      });\n    });\n\n    it('应该处理负数', () => {\n      expect(FileUtils.formatFileSize(-1024)).toBe('0 B');\n    });\n\n    it('应该处理NaN', () => {\n      expect(FileUtils.formatFileSize(NaN)).toBe('0 B');\n    });\n\n    it('应该处理Infinity', () => {\n      expect(FileUtils.formatFileSize(Infinity)).toBe('∞');\n    });\n  });\n\n  describe('文件扩展名提取', () => {\n    const testCases = [\n      { filename: 'test.txt', expected: 'txt' },\n      { filename: 'archive.tar.gz', expected: 'gz' },\n      { filename: 'document.pdf', expected: 'pdf' },\n      { filename: 'image.jpeg', expected: 'jpeg' },\n      { filename: 'noextension', expected: '' },\n      { filename: '.hidden', expected: '' },\n      { filename: '.hidden.txt', expected: 'txt' },\n      { filename: 'file.with.dots.zip', expected: 'zip' },\n      { filename: '', expected: '' },\n    ];\n\n    testCases.forEach(({ filename, expected }) => {\n      it(`应该从 \"${filename}\" 提取扩展名 \"${expected}\"`, () => {\n        expect(FileUtils.getFileExtension(filename)).toBe(expected);\n      });\n    });\n  });\n\n  describe('文件名清理', () => {\n    const testCases = [\n      { input: 'normal-file.txt', expected: 'normal-file.txt' },\n      { input: 'file with spaces.txt', expected: 'file with spaces.txt' },\n      { input: 'file<with>invalid:chars.txt', expected: 'file_with_invalid_chars.txt' },\n      { input: 'file|with\"quotes.txt', expected: 'file_with_quotes.txt' },\n      { input: 'file*with?wildcards.txt', expected: 'file_with_wildcards.txt' },\n      { input: '../../../dangerous.txt', expected: '______dangerous.txt' },\n      { input: 'file\\nwith\\nnewlines.txt', expected: 'file_with_newlines.txt' },\n      { input: 'very-long-filename-that-exceeds-normal-limits-and-should-be-truncated-to-reasonable-length.txt', expected: 'very-long-filename-that-exceeds-normal-limits-and-should-be-truncated-to-reason.txt' },\n    ];\n\n    testCases.forEach(({ input, expected }) => {\n      it(`应该清理文件名 \"${input}\" 为 \"${expected}\"`, () => {\n        expect(FileUtils.sanitizeFileName(input)).toBe(expected);\n      });\n    });\n\n    it('应该处理空文件名', () => {\n      expect(FileUtils.sanitizeFileName('')).toBe('untitled');\n    });\n\n    it('应该处理只有非法字符的文件名', () => {\n      expect(FileUtils.sanitizeFileName('<>:\"/?*')).toBe('untitled');\n    });\n  });\n\n  describe('路径操作', () => {\n    describe('路径拼接', () => {\n      const testCases = [\n        { parts: ['folder', 'file.txt'], expected: 'folder/file.txt' },\n        { parts: ['folder/', 'file.txt'], expected: 'folder/file.txt' },\n        { parts: ['folder', '/file.txt'], expected: 'folder/file.txt' },\n        { parts: ['folder/', '/file.txt'], expected: 'folder/file.txt' },\n        { parts: ['', 'file.txt'], expected: 'file.txt' },\n        { parts: ['folder', ''], expected: 'folder/' },\n        { parts: ['a', 'b', 'c', 'd.txt'], expected: 'a/b/c/d.txt' },\n      ];\n\n      testCases.forEach(({ parts, expected }) => {\n        it(`应该拼接路径 [${parts.join(', ')}] 为 \"${expected}\"`, () => {\n          expect(FileUtils.joinPath(...parts)).toBe(expected);\n        });\n      });\n    });\n\n    describe('路径解析', () => {\n      const testCases = [\n        { \n          path: 'folder/subfolder/file.txt', \n          expected: { dir: 'folder/subfolder', name: 'file.txt', ext: 'txt' }\n        },\n        { \n          path: 'file.txt', \n          expected: { dir: '', name: 'file.txt', ext: 'txt' }\n        },\n        { \n          path: 'folder/file', \n          expected: { dir: 'folder', name: 'file', ext: '' }\n        },\n        { \n          path: 'folder/', \n          expected: { dir: 'folder', name: '', ext: '' }\n        },\n      ];\n\n      testCases.forEach(({ path, expected }) => {\n        it(`应该解析路径 \"${path}\"`, () => {\n          expect(FileUtils.parsePath(path)).toEqual(expected);\n        });\n      });\n    });\n  });\n\n  describe('文件类型检测', () => {\n    it('应该检测文本文件', () => {\n      const textExtensions = ['txt', 'md', 'json', 'xml', 'html', 'css', 'js', 'ts'];\n      textExtensions.forEach(ext => {\n        expect(FileUtils.isTextFile(`file.${ext}`)).toBe(true);\n      });\n    });\n\n    it('应该检测图片文件', () => {\n      const imageExtensions = ['jpg', 'jpeg', 'png', 'gif', 'svg', 'webp', 'bmp'];\n      imageExtensions.forEach(ext => {\n        expect(FileUtils.isImageFile(`image.${ext}`)).toBe(true);\n      });\n    });\n\n    it('应该检测视频文件', () => {\n      const videoExtensions = ['mp4', 'avi', 'mkv', 'mov', 'wmv', 'flv', 'webm'];\n      videoExtensions.forEach(ext => {\n        expect(FileUtils.isVideoFile(`video.${ext}`)).toBe(true);\n      });\n    });\n\n    it('应该检测音频文件', () => {\n      const audioExtensions = ['mp3', 'wav', 'flac', 'aac', 'ogg', 'm4a'];\n      audioExtensions.forEach(ext => {\n        expect(FileUtils.isAudioFile(`audio.${ext}`)).toBe(true);\n      });\n    });\n\n    it('应该检测压缩文件', () => {\n      const archiveExtensions = ['zip', 'rar', '7z', 'tar', 'gz', 'bz2'];\n      archiveExtensions.forEach(ext => {\n        expect(FileUtils.isArchiveFile(`archive.${ext}`)).toBe(true);\n      });\n    });\n  });\n\n  describe('文件读取', () => {\n    it('应该读取文件为ArrayBuffer', async () => {\n      const mockFile = new File(['Hello World'], 'test.txt', { type: 'text/plain' });\n      const buffer = await FileUtils.readFileAsArrayBuffer(mockFile);\n      \n      expect(buffer).toBeInstanceOf(ArrayBuffer);\n      expect(buffer.byteLength).toBe(11);\n    });\n\n    it('应该读取文件为文本', async () => {\n      const mockFile = new File(['Hello World'], 'test.txt', { type: 'text/plain' });\n      const text = await FileUtils.readFileAsText(mockFile);\n      \n      expect(text).toBe('Hello World');\n    });\n\n    it('应该读取文件为Base64', async () => {\n      const mockFile = new File(['Hello'], 'test.txt', { type: 'text/plain' });\n      const base64 = await FileUtils.readFileAsBase64(mockFile);\n      \n      expect(base64).toMatch(/^data:text\\/plain;base64,/);\n    });\n\n    it('应该读取文件头部', async () => {\n      const content = new Uint8Array([0x50, 0x4B, 0x03, 0x04, 0x00, 0x01, 0x02, 0x03]);\n      const mockFile = new File([content], 'test.zip');\n      \n      const header = await FileUtils.readFileHeader(mockFile, 4);\n      \n      expect(header).toEqual(new Uint8Array([0x50, 0x4B, 0x03, 0x04]));\n    });\n\n    it('应该处理文件读取错误', async () => {\n      const invalidFile = null as any;\n      \n      await expect(FileUtils.readFileAsText(invalidFile)).rejects.toThrow();\n    });\n  });\n\n  describe('文件验证', () => {\n    it('应该验证文件大小', () => {\n      const smallFile = new File(['content'], 'small.txt');\n      const maxSize = 1024 * 1024; // 1MB\n      \n      expect(FileUtils.validateFileSize(smallFile, maxSize)).toBe(true);\n    });\n\n    it('应该拒绝过大文件', () => {\n      const largeContent = new Array(1024 * 1024 + 1).fill('a').join('');\n      const largeFile = new File([largeContent], 'large.txt');\n      const maxSize = 1024 * 1024; // 1MB\n      \n      expect(FileUtils.validateFileSize(largeFile, maxSize)).toBe(false);\n    });\n\n    it('应该验证文件类型', () => {\n      const allowedTypes = ['text/plain', 'application/json'];\n      const validFile = new File(['content'], 'test.txt', { type: 'text/plain' });\n      const invalidFile = new File(['content'], 'test.exe', { type: 'application/octet-stream' });\n      \n      expect(FileUtils.validateFileType(validFile, allowedTypes)).toBe(true);\n      expect(FileUtils.validateFileType(invalidFile, allowedTypes)).toBe(false);\n    });\n\n    it('应该验证文件扩展名', () => {\n      const allowedExtensions = ['txt', 'json', 'md'];\n      \n      expect(FileUtils.validateFileExtension('test.txt', allowedExtensions)).toBe(true);\n      expect(FileUtils.validateFileExtension('test.exe', allowedExtensions)).toBe(false);\n    });\n  });\n\n  describe('URL和Blob操作', () => {\n    it('应该创建和撤销对象URL', () => {\n      const mockFile = new File(['content'], 'test.txt');\n      const url = FileUtils.createObjectURL(mockFile);\n      \n      expect(url).toMatch(/^blob:/);\n      \n      // 撤销URL（不会抛出错误）\n      expect(() => FileUtils.revokeObjectURL(url)).not.toThrow();\n    });\n\n    it('应该从Base64创建Blob', () => {\n      const base64 = 'SGVsbG8gV29ybGQ='; // \"Hello World\"\n      const blob = FileUtils.base64ToBlob(base64, 'text/plain');\n      \n      expect(blob.size).toBe(11);\n      expect(blob.type).toBe('text/plain');\n    });\n\n    it('应该下载Blob为文件', () => {\n      const mockBlob = new Blob(['content'], { type: 'text/plain' });\n      const filename = 'test.txt';\n      \n      // 模拟DOM元素\n      const mockA = {\n        href: '',\n        download: '',\n        click: vi.fn(),\n        style: { display: '' }\n      };\n      \n      const createElementSpy = vi.spyOn(document, 'createElement').mockReturnValue(mockA as any);\n      const appendChildSpy = vi.spyOn(document.body, 'appendChild').mockImplementation(() => mockA as any);\n      const removeChildSpy = vi.spyOn(document.body, 'removeChild').mockImplementation(() => mockA as any);\n      \n      FileUtils.downloadBlob(mockBlob, filename);\n      \n      expect(createElementSpy).toHaveBeenCalledWith('a');\n      expect(mockA.download).toBe(filename);\n      expect(mockA.click).toHaveBeenCalled();\n      expect(appendChildSpy).toHaveBeenCalledWith(mockA);\n      expect(removeChildSpy).toHaveBeenCalledWith(mockA);\n      \n      createElementSpy.mockRestore();\n      appendChildSpy.mockRestore();\n      removeChildSpy.mockRestore();\n    });\n  });\n\n  describe('性能测试', () => {\n    it('应该快速处理文件大小格式化', () => {\n      const startTime = performance.now();\n      \n      // 执行1000次格式化\n      for (let i = 0; i < 1000; i++) {\n        FileUtils.formatFileSize(Math.random() * 1024 * 1024 * 1024);\n      }\n      \n      const endTime = performance.now();\n      const totalTime = endTime - startTime;\n      \n      expect(totalTime).toBeLessThan(50); // 应该在50ms内完成\n    });\n\n    it('应该快速处理文件名清理', () => {\n      const dirtyFilenames = [\n        'file<with>invalid:chars.txt',\n        'file|with\"quotes.txt',\n        '../../../dangerous.txt',\n        'file*with?wildcards.txt'\n      ];\n      \n      const startTime = performance.now();\n      \n      // 执行1000次清理\n      for (let i = 0; i < 1000; i++) {\n        const filename = dirtyFilenames[i % dirtyFilenames.length];\n        FileUtils.sanitizeFileName(filename);\n      }\n      \n      const endTime = performance.now();\n      const totalTime = endTime - startTime;\n      \n      expect(totalTime).toBeLessThan(100); // 应该在100ms内完成\n    });\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/tests/unit/utils/format-detector.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/tests/unit/utils/memory-manager.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/tests/utils/benchmark-runner.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token. A constructor, method, accessor, or property was expected.","line":14,"column":2,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { performance } from 'perf_hooks';\nimport { writeFileSync } from 'fs';\nimport { join } from 'path';\n\n/**\n * 基准测试运行器\n * 用于执行性能基准测试并生成报告\n */\nexport class BenchmarkRunner {\n  private results: BenchmarkResult[] = [];\n  private startTime: number = 0;\n\n  // 基准测试结果接口\n  interface BenchmarkResult {\n    name: string;\n    iterations: number;\n    totalTime: number;\n    averageTime: number;\n    minTime: number;\n    maxTime: number;\n    medianTime: number;\n    operationsPerSecond: number;\n    memoryUsage: {\n      initial: number;\n      peak: number;\n      final: number;\n      delta: number;\n    };\n    metadata?: Record<string, any>;\n  }\n\n  // 运行基准测试\n  async runBenchmark(\n    name: string,\n    testFunction: () => Promise<void> | void,\n    options: {\n      iterations?: number;\n      warmupIterations?: number;\n      measureMemory?: boolean;\n      metadata?: Record<string, any>;\n    } = {}\n  ): Promise<BenchmarkResult> {\n    const {\n      iterations = 1000,\n      warmupIterations = 10,\n      measureMemory = true,\n      metadata = {}\n    } = options;\n\n    console.log(`🏃‍♂️ 运行基准测试: ${name}`);\n    console.log(`   迭代次数: ${iterations}`);\n    console.log(`   预热次数: ${warmupIterations}`);\n\n    // 预热阶段\n    console.log('🔥 预热中...');\n    for (let i = 0; i < warmupIterations; i++) {\n      await testFunction();\n    }\n\n    // 等待垃圾回收\n    if (global.gc) {\n      global.gc();\n    }\n    await this.sleep(100);\n\n    // 记录初始内存\n    const initialMemory = measureMemory ? this.getMemoryUsage() : 0;\n    let peakMemory = initialMemory;\n\n    // 正式测试\n    console.log('⚡ 开始基准测试...');\n    const times: number[] = [];\n    \n    for (let i = 0; i < iterations; i++) {\n      const startTime = performance.now();\n      await testFunction();\n      const endTime = performance.now();\n      \n      times.push(endTime - startTime);\n      \n      // 更新内存峰值\n      if (measureMemory) {\n        const currentMemory = this.getMemoryUsage();\n        if (currentMemory > peakMemory) {\n          peakMemory = currentMemory;\n        }\n      }\n\n      // 进度报告\n      if ((i + 1) % Math.max(1, Math.floor(iterations / 10)) === 0) {\n        const progress = ((i + 1) / iterations * 100).toFixed(1);\n        console.log(`   进度: ${progress}%`);\n      }\n    }\n\n    // 记录最终内存\n    const finalMemory = measureMemory ? this.getMemoryUsage() : 0;\n\n    // 计算统计数据\n    const totalTime = times.reduce((sum, time) => sum + time, 0);\n    const averageTime = totalTime / times.length;\n    const minTime = Math.min(...times);\n    const maxTime = Math.max(...times);\n    const sortedTimes = times.sort((a, b) => a - b);\n    const medianTime = sortedTimes[Math.floor(sortedTimes.length / 2)];\n    const operationsPerSecond = 1000 / averageTime;\n\n    const result: BenchmarkResult = {\n      name,\n      iterations,\n      totalTime,\n      averageTime,\n      minTime,\n      maxTime,\n      medianTime,\n      operationsPerSecond,\n      memoryUsage: {\n        initial: initialMemory,\n        peak: peakMemory,\n        final: finalMemory,\n        delta: finalMemory - initialMemory\n      },\n      metadata\n    };\n\n    this.results.push(result);\n    this.printResult(result);\n    \n    return result;\n  }\n\n  // 运行压缩解压基准测试\n  async runCompressionBenchmark(\n    archiveData: ArrayBuffer,\n    archiveFormat: string\n  ) {\n    const testCases = [\n      {\n        name: `${archiveFormat.toUpperCase()} - 格式检测`,\n        test: async () => {\n          // 模拟格式检测\n          const view = new Uint8Array(archiveData.slice(0, 16));\n          return this.detectFormat(view);\n        }\n      },\n      {\n        name: `${archiveFormat.toUpperCase()} - 文件列表获取`,\n        test: async () => {\n          // 模拟获取文件列表\n          await this.sleep(Math.random() * 10);\n          return Array.from({ length: 10 }, (_, i) => `file-${i}.txt`);\n        }\n      },\n      {\n        name: `${archiveFormat.toUpperCase()} - 单文件解压`,\n        test: async () => {\n          // 模拟单文件解压\n          await this.sleep(Math.random() * 20);\n          return new Uint8Array(1024);\n        }\n      },\n      {\n        name: `${archiveFormat.toUpperCase()} - 全部解压`,\n        test: async () => {\n          // 模拟全部文件解压\n          await this.sleep(Math.random() * 50);\n          return Array.from({ length: 10 }, () => new Uint8Array(1024));\n        }\n      }\n    ];\n\n    const results = [];\n    for (const testCase of testCases) {\n      const result = await this.runBenchmark(\n        testCase.name, \n        testCase.test,\n        {\n          iterations: 100,\n          metadata: {\n            archiveSize: archiveData.byteLength,\n            format: archiveFormat\n          }\n        }\n      );\n      results.push(result);\n    }\n\n    return results;\n  }\n\n  // 运行内存压力测试\n  async runMemoryStressTest(maxMemoryMB: number = 100) {\n    const chunkSize = 1024 * 1024; // 1MB\n    const chunks: ArrayBuffer[] = [];\n\n    return await this.runBenchmark(\n      `内存压力测试 (${maxMemoryMB}MB)`,\n      async () => {\n        // 分配内存\n        if (chunks.length < maxMemoryMB) {\n          const chunk = new ArrayBuffer(chunkSize);\n          const view = new Uint8Array(chunk);\n          // 写入数据确保内存被占用\n          for (let i = 0; i < chunkSize; i += 1024) {\n            view[i] = Math.floor(Math.random() * 256);\n          }\n          chunks.push(chunk);\n        }\n\n        // 随机访问已分配的内存\n        if (chunks.length > 0) {\n          const randomChunk = chunks[Math.floor(Math.random() * chunks.length)];\n          const view = new Uint8Array(randomChunk);\n          const sum = Array.from(view.slice(0, 1024)).reduce((a, b) => a + b, 0);\n        }\n\n        // 定期清理一些内存\n        if (chunks.length > maxMemoryMB * 0.8 && Math.random() < 0.1) {\n          chunks.splice(0, Math.floor(chunks.length * 0.1));\n        }\n      },\n      {\n        iterations: 1000,\n        measureMemory: true,\n        metadata: {\n          maxMemoryMB,\n          testType: 'memory-stress'\n        }\n      }\n    );\n  }\n\n  // 生成性能报告\n  generateReport(): string {\n    const report: string[] = [];\n    \n    report.push('# ZhugeExtract 性能基准测试报告');\n    report.push('');\n    report.push(`生成时间: ${new Date().toISOString()}`);\n    report.push(`总测试数: ${this.results.length}`);\n    report.push('');\n\n    // 汇总统计\n    report.push('## 测试汇总');\n    report.push('');\n    report.push('| 测试名称 | 迭代次数 | 平均耗时(ms) | 最小耗时(ms) | 最大耗时(ms) | OPS | 内存变化(MB) |');\n    report.push('|---------|---------|-------------|-------------|-------------|-----|-------------|');\n\n    for (const result of this.results) {\n      const memoryDeltaMB = (result.memoryUsage.delta / 1024 / 1024).toFixed(2);\n      report.push(\n        `| ${result.name} | ${result.iterations} | ${result.averageTime.toFixed(2)} | ${result.minTime.toFixed(2)} | ${result.maxTime.toFixed(2)} | ${result.operationsPerSecond.toFixed(0)} | ${memoryDeltaMB} |`\n      );\n    }\n\n    report.push('');\n\n    // 详细结果\n    report.push('## 详细测试结果');\n    report.push('');\n\n    for (const result of this.results) {\n      report.push(`### ${result.name}`);\n      report.push('');\n      report.push(`- **迭代次数**: ${result.iterations}`);\n      report.push(`- **总耗时**: ${result.totalTime.toFixed(2)}ms`);\n      report.push(`- **平均耗时**: ${result.averageTime.toFixed(2)}ms`);\n      report.push(`- **最小耗时**: ${result.minTime.toFixed(2)}ms`);\n      report.push(`- **最大耗时**: ${result.maxTime.toFixed(2)}ms`);\n      report.push(`- **中位数耗时**: ${result.medianTime.toFixed(2)}ms`);\n      report.push(`- **每秒操作数**: ${result.operationsPerSecond.toFixed(0)} ops/sec`);\n      report.push('');\n      report.push('**内存使用情况**:');\n      report.push(`- 初始内存: ${(result.memoryUsage.initial / 1024 / 1024).toFixed(2)}MB`);\n      report.push(`- 峰值内存: ${(result.memoryUsage.peak / 1024 / 1024).toFixed(2)}MB`);\n      report.push(`- 最终内存: ${(result.memoryUsage.final / 1024 / 1024).toFixed(2)}MB`);\n      report.push(`- 内存变化: ${(result.memoryUsage.delta / 1024 / 1024).toFixed(2)}MB`);\n      report.push('');\n\n      if (result.metadata && Object.keys(result.metadata).length > 0) {\n        report.push('**元数据**:');\n        for (const [key, value] of Object.entries(result.metadata)) {\n          report.push(`- ${key}: ${value}`);\n        }\n        report.push('');\n      }\n    }\n\n    return report.join('\\n');\n  }\n\n  // 保存报告到文件\n  saveReport(filePath?: string): string {\n    const report = this.generateReport();\n    const outputPath = filePath || join(process.cwd(), 'benchmark-results', `benchmark-${Date.now()}.md`);\n    \n    writeFileSync(outputPath, report, 'utf8');\n    console.log(`📊 基准测试报告已保存到: ${outputPath}`);\n    \n    return outputPath;\n  }\n\n  // 清空结果\n  clearResults(): void {\n    this.results = [];\n  }\n\n  // 获取所有结果\n  getResults(): BenchmarkResult[] {\n    return [...this.results];\n  }\n\n  // 私有辅助方法\n  private getMemoryUsage(): number {\n    if (typeof performance !== 'undefined' && performance.memory) {\n      return performance.memory.usedJSHeapSize;\n    }\n    \n    // Node.js环境\n    if (typeof process !== 'undefined' && process.memoryUsage) {\n      return process.memoryUsage().heapUsed;\n    }\n    \n    return 0;\n  }\n\n  private async sleep(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  private printResult(result: BenchmarkResult): void {\n    console.log(`✅ ${result.name} 完成:`);\n    console.log(`   平均: ${result.averageTime.toFixed(2)}ms`);\n    console.log(`   范围: ${result.minTime.toFixed(2)}ms - ${result.maxTime.toFixed(2)}ms`);\n    console.log(`   OPS: ${result.operationsPerSecond.toFixed(0)}`);\n    console.log(`   内存变化: ${(result.memoryUsage.delta / 1024 / 1024).toFixed(2)}MB`);\n    console.log('');\n  }\n\n  private detectFormat(signature: Uint8Array): string {\n    // ZIP\n    if (signature[0] === 0x50 && signature[1] === 0x4b) return 'zip';\n    // RAR\n    if (signature[0] === 0x52 && signature[1] === 0x61) return 'rar';\n    // 7Z\n    if (signature[0] === 0x37 && signature[1] === 0x7a) return '7z';\n    // TAR\n    if (signature[257] === 0x75 && signature[258] === 0x73) return 'tar';\n    // GZIP\n    if (signature[0] === 0x1f && signature[1] === 0x8b) return 'gz';\n    \n    return 'unknown';\n  }\n}\n\n// 导出单例实例\nexport const benchmarkRunner = new BenchmarkRunner();","usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/tests/utils/global-setup.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'config' is defined but never used. Allowed unused args must match /^_/u.","line":5,"column":28,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":34}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { chromium, FullConfig } from '@playwright/test';\nimport fs from 'fs';\nimport path from 'path';\n\nasync function globalSetup(config: FullConfig) {\n  console.log('🚀 开始全局测试设置...');\n\n  // 创建测试结果目录\n  const testDirs = [\n    'test-results',\n    'test-results/e2e-artifacts',\n    'test-results/screenshots',\n    'test-results/videos',\n    'playwright-report',\n    'coverage'\n  ];\n\n  for (const dir of testDirs) {\n    const fullPath = path.resolve(dir);\n    if (!fs.existsSync(fullPath)) {\n      fs.mkdirSync(fullPath, { recursive: true });\n    }\n  }\n\n  // 启动浏览器进行预热\n  const browser = await chromium.launch({\n    args: [\n      '--enable-features=SharedArrayBuffer',\n      '--cross-origin-embedder-policy=require-corp',\n      '--cross-origin-opener-policy=same-origin'\n    ]\n  });\n\n  // 创建测试页面并预加载\n  const context = await browser.newContext({\n    viewport: { width: 1280, height: 720 }\n  });\n  \n  const page = await context.newPage();\n  \n  try {\n    // 预热应用\n    await page.goto('http://localhost:4173');\n    await page.waitForLoadState('networkidle');\n  } catch (error) {\n    console.warn('⚠️ 无法预热应用，可能服务器未启动');\n  }\n\n  await browser.close();\n\n  // 生成测试数据文件\n  await generateTestFixtures();\n\n  console.log('✅ 全局测试设置完成');\n}\n\nasync function generateTestFixtures() {\n  const fixturesDir = path.resolve('tests/fixtures');\n  \n  if (!fs.existsSync(fixturesDir)) {\n    fs.mkdirSync(fixturesDir, { recursive: true });\n  }\n\n  // 生成ZIP测试文件\n  const zipBuffer = Buffer.from([\n    0x50, 0x4b, 0x03, 0x04, 0x14, 0x00, 0x00, 0x00, 0x08, 0x00,\n    // ... ZIP文件头和数据\n    0x50, 0x4b, 0x05, 0x06, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,\n    0x01, 0x00, 0x2e, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00,\n    0x00, 0x00\n  ]);\n  \n  fs.writeFileSync(path.join(fixturesDir, 'test.zip'), zipBuffer);\n\n  // 生成RAR测试文件签名\n  const rarBuffer = Buffer.from([\n    0x52, 0x61, 0x72, 0x21, 0x1a, 0x07, 0x01, 0x00,\n    // RAR文件签名\n  ]);\n  \n  fs.writeFileSync(path.join(fixturesDir, 'test.rar'), rarBuffer);\n\n  // 生成7Z测试文件签名\n  const sevenZBuffer = Buffer.from([\n    0x37, 0x7a, 0xbc, 0xaf, 0x27, 0x1c, 0x00, 0x04\n  ]);\n  \n  fs.writeFileSync(path.join(fixturesDir, 'test.7z'), sevenZBuffer);\n\n  console.log('📦 测试数据文件生成完成');\n}\n\nexport default globalSetup;","usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/tests/utils/global-teardown.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'config' is defined but never used. Allowed unused args must match /^_/u.","line":5,"column":31,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":37}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { FullConfig } from '@playwright/test';\nimport fs from 'fs';\nimport path from 'path';\n\nasync function globalTeardown(config: FullConfig) {\n  console.log('🧹 开始全局测试清理...');\n\n  // 清理临时测试文件\n  const tempDirs = [\n    'tests/fixtures/temp',\n    'test-results/temp'\n  ];\n\n  for (const dir of tempDirs) {\n    const fullPath = path.resolve(dir);\n    if (fs.existsSync(fullPath)) {\n      fs.rmSync(fullPath, { recursive: true, force: true });\n    }\n  }\n\n  // 生成测试报告摘要\n  generateTestSummary();\n\n  console.log('✅ 全局测试清理完成');\n}\n\nfunction generateTestSummary() {\n  const summaryPath = path.resolve('test-results/summary.json');\n  const summary = {\n    timestamp: new Date().toISOString(),\n    testRun: 'completed',\n    environment: process.env.NODE_ENV || 'test',\n    artifacts: {\n      screenshots: fs.existsSync('test-results/screenshots'),\n      videos: fs.existsSync('test-results/videos'),\n      coverage: fs.existsSync('coverage'),\n      htmlReport: fs.existsSync('playwright-report')\n    }\n  };\n\n  fs.writeFileSync(summaryPath, JSON.stringify(summary, null, 2));\n  console.log('📊 测试摘要已生成');\n}\n\nexport default globalTeardown;","usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/tests/utils/performance-helpers.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'vi' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":12},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":180,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":180,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4564,4567],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4564,4567],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":180,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":180,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4571,4574],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4571,4574],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":229,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":229,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6108,6111],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6108,6111],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":262,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":262,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7156,7159],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7156,7159],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":265,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":265,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7314,7317],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7314,7317],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { vi } from 'vitest';\n\n/**\n * 性能测试辅助工具\n */\nexport class PerformanceHelpers {\n  private static measurements: Map<string, number> = new Map();\n\n  // 开始性能测量\n  static startMeasurement(label: string): void {\n    this.measurements.set(label, performance.now());\n  }\n\n  // 结束性能测量并返回耗时\n  static endMeasurement(label: string): number {\n    const startTime = this.measurements.get(label);\n    if (!startTime) {\n      throw new Error(`No measurement started for label: ${label}`);\n    }\n    \n    const endTime = performance.now();\n    const duration = endTime - startTime;\n    this.measurements.delete(label);\n    \n    return duration;\n  }\n\n  // 测量异步函数执行时间\n  static async measureAsync<T>(\n    fn: () => Promise<T>,\n    label: string = 'async-operation'\n  ): Promise<{ result: T; duration: number }> {\n    this.startMeasurement(label);\n    const result = await fn();\n    const duration = this.endMeasurement(label);\n    \n    return { result, duration };\n  }\n\n  // 测量同步函数执行时间\n  static measureSync<T>(\n    fn: () => T,\n    label: string = 'sync-operation'\n  ): { result: T; duration: number } {\n    this.startMeasurement(label);\n    const result = fn();\n    const duration = this.endMeasurement(label);\n    \n    return { result, duration };\n  }\n\n  // 模拟内存压力测试\n  static simulateMemoryPressure(sizeMB: number): ArrayBuffer[] {\n    const buffers: ArrayBuffer[] = [];\n    const chunkSize = 1024 * 1024; // 1MB chunks\n    \n    for (let i = 0; i < sizeMB; i++) {\n      const buffer = new ArrayBuffer(chunkSize);\n      const view = new Uint8Array(buffer);\n      \n      // 填充数据以确保内存被实际占用\n      for (let j = 0; j < chunkSize; j += 1024) {\n        view[j] = Math.floor(Math.random() * 256);\n      }\n      \n      buffers.push(buffer);\n    }\n    \n    return buffers;\n  }\n\n  // 清理内存压力测试的缓冲区\n  static cleanupMemoryPressure(buffers: ArrayBuffer[]): void {\n    buffers.length = 0;\n    \n    // 强制垃圾回收 (在测试环境中)\n    if (global.gc) {\n      global.gc();\n    }\n  }\n\n  // 监控内存使用情况\n  static getMemoryUsage(): {\n    used: number;\n    total: number;\n    percentage: number;\n  } {\n    const memory = performance.memory || {\n      usedJSHeapSize: 50 * 1024 * 1024,\n      totalJSHeapSize: 100 * 1024 * 1024,\n      jsHeapSizeLimit: 2 * 1024 * 1024 * 1024\n    };\n    \n    return {\n      used: memory.usedJSHeapSize,\n      total: memory.totalJSHeapSize,\n      percentage: (memory.usedJSHeapSize / memory.totalJSHeapSize) * 100\n    };\n  }\n\n  // 等待内存稳定\n  static async waitForMemoryStable(\n    maxWaitMs: number = 5000\n  ): Promise<void> {\n    const startTime = performance.now();\n    let lastMemoryUsage = this.getMemoryUsage().used;\n    \n    while (performance.now() - startTime < maxWaitMs) {\n      await new Promise(resolve => setTimeout(resolve, 100));\n      \n      const currentMemoryUsage = this.getMemoryUsage().used;\n      const memoryDiff = Math.abs(currentMemoryUsage - lastMemoryUsage);\n      \n      // 如果内存使用变化小于1MB，认为已稳定\n      if (memoryDiff < 1024 * 1024) {\n        return;\n      }\n      \n      lastMemoryUsage = currentMemoryUsage;\n    }\n  }\n\n  // 创建性能基准测试\n  static createBenchmark(\n    name: string,\n    fn: () => Promise<void> | void,\n    iterations: number = 100\n  ) {\n    return async () => {\n      const durations: number[] = [];\n      const memoryUsages: number[] = [];\n      \n      // 预热\n      for (let i = 0; i < 5; i++) {\n        await fn();\n      }\n      \n      // 等待内存稳定\n      await this.waitForMemoryStable();\n      \n      // 正式测试\n      for (let i = 0; i < iterations; i++) {\n        const initialMemory = this.getMemoryUsage().used;\n        const startTime = performance.now();\n        \n        await fn();\n        \n        const endTime = performance.now();\n        const finalMemory = this.getMemoryUsage().used;\n        \n        durations.push(endTime - startTime);\n        memoryUsages.push(finalMemory - initialMemory);\n      }\n      \n      // 计算统计信息\n      const avgDuration = durations.reduce((a, b) => a + b, 0) / durations.length;\n      const minDuration = Math.min(...durations);\n      const maxDuration = Math.max(...durations);\n      const avgMemory = memoryUsages.reduce((a, b) => a + b, 0) / memoryUsages.length;\n      \n      return {\n        name,\n        iterations,\n        duration: {\n          average: avgDuration,\n          min: minDuration,\n          max: maxDuration,\n          median: durations.sort((a, b) => a - b)[Math.floor(durations.length / 2)]\n        },\n        memory: {\n          average: avgMemory,\n          peak: Math.max(...memoryUsages)\n        }\n      };\n    };\n  }\n\n  // 性能断言辅助函数\n  static expectPerformance(\n    operation: () => Promise<any> | any,\n    constraints: {\n      maxDuration?: number;\n      maxMemory?: number;    // bytes\n      minThroughput?: number; // operations per second\n    }\n  ) {\n    return async () => {\n      const startTime = performance.now();\n      const initialMemory = this.getMemoryUsage().used;\n      \n      await operation();\n      \n      const endTime = performance.now();\n      const finalMemory = this.getMemoryUsage().used;\n      \n      const duration = endTime - startTime;\n      const memoryUsed = finalMemory - initialMemory;\n      \n      if (constraints.maxDuration && duration > constraints.maxDuration) {\n        throw new Error(\n          `Operation took ${duration.toFixed(2)}ms, exceeding limit of ${constraints.maxDuration}ms`\n        );\n      }\n      \n      if (constraints.maxMemory && memoryUsed > constraints.maxMemory) {\n        throw new Error(\n          `Operation used ${(memoryUsed / 1024 / 1024).toFixed(2)}MB, exceeding limit of ${(constraints.maxMemory / 1024 / 1024).toFixed(2)}MB`\n        );\n      }\n      \n      if (constraints.minThroughput) {\n        const throughput = 1000 / duration; // operations per second\n        if (throughput < constraints.minThroughput) {\n          throw new Error(\n            `Operation throughput ${throughput.toFixed(2)} ops/sec is below minimum ${constraints.minThroughput} ops/sec`\n          );\n        }\n      }\n      \n      return {\n        duration,\n        memoryUsed,\n        throughput: 1000 / duration\n      };\n    };\n  }\n\n  // 生成性能报告\n  static generatePerformanceReport(results: any[]): string {\n    let report = '# Performance Test Report\\n\\n';\n    report += `Generated: ${new Date().toISOString()}\\n\\n`;\n    \n    results.forEach(result => {\n      report += `## ${result.name}\\n`;\n      report += `- Iterations: ${result.iterations}\\n`;\n      report += `- Average Duration: ${result.duration.average.toFixed(2)}ms\\n`;\n      report += `- Min Duration: ${result.duration.min.toFixed(2)}ms\\n`;\n      report += `- Max Duration: ${result.duration.max.toFixed(2)}ms\\n`;\n      report += `- Median Duration: ${result.duration.median.toFixed(2)}ms\\n`;\n      report += `- Average Memory: ${(result.memory.average / 1024 / 1024).toFixed(2)}MB\\n`;\n      report += `- Peak Memory: ${(result.memory.peak / 1024 / 1024).toFixed(2)}MB\\n\\n`;\n    });\n    \n    return report;\n  }\n\n  // 清理所有测量数据\n  static cleanup(): void {\n    this.measurements.clear();\n  }\n}\n\n// 性能测试装饰器\nexport function benchmark(\n  name: string,\n  iterations: number = 100,\n  constraints?: {\n    maxDuration?: number;\n    maxMemory?: number;\n  }\n) {\n  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n    const originalMethod = descriptor.value;\n    \n    descriptor.value = async function (...args: any[]) {\n      const benchmark = PerformanceHelpers.createBenchmark(\n        name,\n        () => originalMethod.apply(this, args),\n        iterations\n      );\n      \n      const result = await benchmark();\n      \n      // 检查约束条件\n      if (constraints) {\n        if (constraints.maxDuration && result.duration.average > constraints.maxDuration) {\n          throw new Error(\n            `Benchmark ${name} exceeded max duration: ${result.duration.average.toFixed(2)}ms > ${constraints.maxDuration}ms`\n          );\n        }\n        \n        if (constraints.maxMemory && result.memory.average > constraints.maxMemory) {\n          throw new Error(\n            `Benchmark ${name} exceeded max memory: ${(result.memory.average / 1024 / 1024).toFixed(2)}MB > ${(constraints.maxMemory / 1024 / 1024).toFixed(2)}MB`\n          );\n        }\n      }\n      \n      return result;\n    };\n    \n    return descriptor;\n  };\n}\n\nexport default PerformanceHelpers;","usedDeprecatedRules":[]},{"filePath":"/Users/halton/work/ZhugeExtract/tests/utils/test-helpers.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":133,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":133,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3426,3429],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3426,3429],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":147,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":147,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3879,3882],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3879,3882],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":160,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":160,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4236,4239],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4236,4239],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":175,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":175,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4724,4727],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4724,4727],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'initialProps' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":182,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":182,"endColumn":23}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { vi } from 'vitest';\nimport { render, RenderOptions } from '@testing-library/react';\nimport { ReactElement } from 'react';\n\n// 测试工具函数\nexport class TestHelpers {\n  // 创建模拟文件\n  static createMockFile(\n    name: string,\n    content: string | ArrayBuffer,\n    type: string = 'text/plain'\n  ): File {\n    const file = new File([content], name, { type });\n    return file;\n  }\n\n  // 创建模拟压缩文件\n  static createMockArchiveFile(format: string, size: number = 1024): File {\n    const signatures = {\n      'zip': [0x50, 0x4b, 0x03, 0x04],\n      'rar': [0x52, 0x61, 0x72, 0x21],\n      '7z': [0x37, 0x7a, 0xbc, 0xaf],\n      'tar': [0x75, 0x73, 0x74, 0x61, 0x72],\n      'gz': [0x1f, 0x8b, 0x08, 0x00]\n    };\n\n    const signature = signatures[format as keyof typeof signatures] || [0x00];\n    const buffer = new ArrayBuffer(size);\n    const view = new Uint8Array(buffer);\n    \n    // 设置文件签名\n    signature.forEach((byte, index) => {\n      view[index] = byte;\n    });\n\n    return new File([buffer], `test.${format}`, { \n      type: `application/${format}` \n    });\n  }\n\n  // 模拟压缩文件结构\n  static createMockArchiveStructure(fileCount: number = 5) {\n    const structure = [];\n    \n    for (let i = 0; i < fileCount; i++) {\n      structure.push({\n        name: `file-${i}.txt`,\n        path: `folder-${Math.floor(i / 2)}/file-${i}.txt`,\n        size: Math.random() * 10000,\n        isDirectory: false,\n        lastModified: new Date(Date.now() - Math.random() * 10000000)\n      });\n    }\n\n    // 添加一些目录\n    structure.push({\n      name: 'folder-0',\n      path: 'folder-0/',\n      size: 0,\n      isDirectory: true,\n      lastModified: new Date()\n    });\n\n    return structure;\n  }\n\n  // 创建性能测试数据\n  static createPerformanceTestData(sizeInMB: number) {\n    const size = sizeInMB * 1024 * 1024;\n    const buffer = new ArrayBuffer(size);\n    const view = new Uint8Array(buffer);\n    \n    // 生成随机数据\n    for (let i = 0; i < size; i++) {\n      view[i] = Math.floor(Math.random() * 256);\n    }\n    \n    return buffer;\n  }\n\n  // 等待异步操作完成\n  static async waitForAsync(ms: number = 0) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  // 模拟网络延迟\n  static mockNetworkDelay(delay: number = 100) {\n    const originalFetch = global.fetch;\n    \n    global.fetch = vi.fn((...args) => {\n      return new Promise(resolve => {\n        setTimeout(() => {\n          resolve(originalFetch.apply(global, args));\n        }, delay);\n      });\n    });\n\n    return () => {\n      global.fetch = originalFetch;\n    };\n  }\n\n  // 模拟内存使用情况\n  static mockMemoryUsage(usedMB: number, totalMB: number = 1000) {\n    const mockPerformance = {\n      ...global.performance,\n      memory: {\n        usedJSHeapSize: usedMB * 1024 * 1024,\n        totalJSHeapSize: totalMB * 1024 * 1024,\n        jsHeapSizeLimit: totalMB * 2 * 1024 * 1024\n      }\n    };\n\n    Object.defineProperty(global, 'performance', {\n      value: mockPerformance,\n      writable: true\n    });\n  }\n\n  // 创建错误测试场景\n  static createErrorScenarios() {\n    return {\n      corruptedFile: this.createMockFile('corrupted.zip', 'invalid content'),\n      oversizedFile: this.createMockArchiveFile('zip', 100 * 1024 * 1024),\n      passwordProtected: this.createMockArchiveFile('zip', 1024),\n      networkError: new Error('Network request failed'),\n      memoryError: new Error('Out of memory'),\n      parseError: new Error('Failed to parse archive')\n    };\n  }\n\n  // 断言工具\n  static expectArchiveStructure(structure: any[]) {\n    expect(Array.isArray(structure)).toBe(true);\n    expect(structure.length).toBeGreaterThan(0);\n    \n    structure.forEach(item => {\n      expect(item).toHaveProperty('name');\n      expect(item).toHaveProperty('path');\n      expect(item).toHaveProperty('size');\n      expect(item).toHaveProperty('isDirectory');\n      expect(typeof item.isDirectory).toBe('boolean');\n    });\n  }\n\n  // 性能断言\n  static expectPerformance(operation: () => Promise<any>, maxTimeMs: number) {\n    return async () => {\n      const startTime = performance.now();\n      await operation();\n      const endTime = performance.now();\n      const duration = endTime - startTime;\n      \n      expect(duration).toBeLessThan(maxTimeMs);\n      return duration;\n    };\n  }\n\n  // 内存断言\n  static expectMemoryUsage(operation: () => Promise<any>, maxMemoryMB: number) {\n    return async () => {\n      const initialMemory = performance.memory?.usedJSHeapSize || 0;\n      await operation();\n      const finalMemory = performance.memory?.usedJSHeapSize || 0;\n      const memoryUsed = (finalMemory - initialMemory) / (1024 * 1024);\n      \n      expect(memoryUsed).toBeLessThan(maxMemoryMB);\n      return memoryUsed;\n    };\n  }\n}\n\n// React组件测试工具\ninterface CustomRenderOptions extends Omit<RenderOptions, 'wrapper'> {\n  initialProps?: any;\n}\n\nexport function renderWithContext(\n  ui: ReactElement,\n  options?: CustomRenderOptions\n) {\n  const { initialProps, ...renderOptions } = options || {};\n\n  // 可以在这里添加 Provider 包装器\n  return render(ui, renderOptions);\n}\n\n// 测试数据生成器\nexport class TestDataGenerator {\n  // 生成随机字符串\n  static randomString(length: number = 10): string {\n    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n    let result = '';\n    for (let i = 0; i < length; i++) {\n      result += chars.charAt(Math.floor(Math.random() * chars.length));\n    }\n    return result;\n  }\n\n  // 生成随机文件路径\n  static randomFilePath(depth: number = 3): string {\n    const parts = [];\n    for (let i = 0; i < depth; i++) {\n      parts.push(this.randomString(8));\n    }\n    return `${parts.join('/')  }.txt`;\n  }\n\n  // 生成测试用户数据\n  static generateUserData() {\n    return {\n      id: this.randomString(8),\n      name: this.randomString(12),\n      preferences: {\n        theme: Math.random() > 0.5 ? 'dark' : 'light',\n        language: Math.random() > 0.5 ? 'zh-CN' : 'en-US',\n        compressionLevel: Math.floor(Math.random() * 9) + 1\n      }\n    };\n  }\n\n  // 生成压缩历史记录\n  static generateCompressionHistory(count: number = 10) {\n    const history = [];\n    \n    for (let i = 0; i < count; i++) {\n      history.push({\n        id: this.randomString(16),\n        fileName: `archive-${i}.zip`,\n        originalSize: Math.floor(Math.random() * 1000000),\n        compressedSize: Math.floor(Math.random() * 500000),\n        timestamp: new Date(Date.now() - Math.random() * 10000000),\n        status: Math.random() > 0.8 ? 'failed' : 'completed'\n      });\n    }\n    \n    return history;\n  }\n}\n\n// 自定义匹配器\nexport const customMatchers = {\n  toBeValidFile(received: File) {\n    const pass = received instanceof File && \n                 received.name.length > 0 && \n                 received.size >= 0;\n    \n    return {\n      message: () => pass \n        ? `expected ${received} not to be a valid File object`\n        : `expected ${received} to be a valid File object`,\n      pass,\n    };\n  },\n\n  toHaveValidArchiveFormat(received: string) {\n    const validFormats = ['zip', 'rar', '7z', 'tar', 'gz', 'bz2'];\n    const pass = validFormats.includes(received.toLowerCase());\n    \n    return {\n      message: () =>  pass \n        ? `expected ${received} not to be a valid archive format`\n        : `expected ${received} to be one of: ${validFormats.join(', ')}`,\n      pass,\n    };\n  },\n\n  toBeWithinMemoryLimit(received: number, limitMB: number) {\n    const receivedMB = received / (1024 * 1024);\n    const pass = receivedMB <= limitMB;\n    \n    return {\n      message: () => pass \n        ? `expected ${receivedMB.toFixed(2)}MB not to be within ${limitMB}MB limit`\n        : `expected ${receivedMB.toFixed(2)}MB to be within ${limitMB}MB limit`,\n      pass,\n    };\n  }\n};\n\n// 导出所有工具\nexport default TestHelpers;","usedDeprecatedRules":[]}]